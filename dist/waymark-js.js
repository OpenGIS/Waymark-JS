/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Zp(u) {
  const m = /* @__PURE__ */ Object.create(null);
  for (const b of u.split(",")) m[b] = 1;
  return (b) => b in m;
}
const pi = {}, Cl = [], os = () => {
}, Uv = () => !1, Nh = (u) => u.charCodeAt(0) === 111 && u.charCodeAt(1) === 110 && // uppercase letter
(u.charCodeAt(2) > 122 || u.charCodeAt(2) < 97), Gp = (u) => u.startsWith("onUpdate:"), Zr = Object.assign, qp = (u, m) => {
  const b = u.indexOf(m);
  b > -1 && u.splice(b, 1);
}, Zv = Object.prototype.hasOwnProperty, li = (u, m) => Zv.call(u, m), Rt = Array.isArray, Il = (u) => $h(u) === "[object Map]", Mg = (u) => $h(u) === "[object Set]", Vt = (u) => typeof u == "function", tr = (u) => typeof u == "string", Vs = (u) => typeof u == "symbol", Mi = (u) => u !== null && typeof u == "object", Cg = (u) => (Mi(u) || Vt(u)) && Vt(u.then) && Vt(u.catch), Ig = Object.prototype.toString, $h = (u) => Ig.call(u), Gv = (u) => $h(u).slice(8, -1), Eg = (u) => $h(u) === "[object Object]", Hp = (u) => tr(u) && u !== "NaN" && u[0] !== "-" && "" + parseInt(u, 10) === u, Wc = /* @__PURE__ */ Zp(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Uh = (u) => {
  const m = /* @__PURE__ */ Object.create(null);
  return (b) => m[b] || (m[b] = u(b));
}, qv = /-(\w)/g, wo = Uh(
  (u) => u.replace(qv, (m, b) => b ? b.toUpperCase() : "")
), Hv = /\B([A-Z])/g, ya = Uh(
  (u) => u.replace(Hv, "-$1").toLowerCase()
), Ag = Uh((u) => u.charAt(0).toUpperCase() + u.slice(1)), gp = Uh(
  (u) => u ? `on${Ag(u)}` : ""
), bo = (u, m) => !Object.is(u, m), Th = (u, ...m) => {
  for (let b = 0; b < u.length; b++)
    u[b](...m);
}, kg = (u, m, b, S = !1) => {
  Object.defineProperty(u, m, {
    configurable: !0,
    enumerable: !1,
    writable: S,
    value: b
  });
}, Ep = (u) => {
  const m = parseFloat(u);
  return isNaN(m) ? u : m;
};
let Zm;
const Zh = () => Zm || (Zm = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function ma(u) {
  if (Rt(u)) {
    const m = {};
    for (let b = 0; b < u.length; b++) {
      const S = u[b], E = tr(S) ? Yv(S) : ma(S);
      if (E)
        for (const D in E)
          m[D] = E[D];
    }
    return m;
  } else if (tr(u) || Mi(u))
    return u;
}
const Wv = /;(?![^(]*\))/g, Xv = /:([^]+)/, Kv = /\/\*[^]*?\*\//g;
function Yv(u) {
  const m = {};
  return u.replace(Kv, "").split(Wv).forEach((b) => {
    if (b) {
      const S = b.split(Xv);
      S.length > 1 && (m[S[0].trim()] = S[1].trim());
    }
  }), m;
}
function us(u) {
  let m = "";
  if (tr(u))
    m = u;
  else if (Rt(u))
    for (let b = 0; b < u.length; b++) {
      const S = us(u[b]);
      S && (m += S + " ");
    }
  else if (Mi(u))
    for (const b in u)
      u[b] && (m += b + " ");
  return m.trim();
}
const Jv = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Qv = /* @__PURE__ */ Zp(Jv);
function zg(u) {
  return !!u || u === "";
}
const Rg = (u) => !!(u && u.__v_isRef === !0), as = (u) => tr(u) ? u : u == null ? "" : Rt(u) || Mi(u) && (u.toString === Ig || !Vt(u.toString)) ? Rg(u) ? as(u.value) : JSON.stringify(u, Dg, 2) : String(u), Dg = (u, m) => Rg(m) ? Dg(u, m.value) : Il(m) ? {
  [`Map(${m.size})`]: [...m.entries()].reduce(
    (b, [S, E], D) => (b[_p(S, D) + " =>"] = E, b),
    {}
  )
} : Mg(m) ? {
  [`Set(${m.size})`]: [...m.values()].map((b) => _p(b))
} : Vs(m) ? _p(m) : Mi(m) && !Rt(m) && !Eg(m) ? String(m) : m, _p = (u, m = "") => {
  var b;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Vs(u) ? `Symbol(${(b = u.description) != null ? b : m})` : u
  );
};
/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let $r;
class Lg {
  constructor(m = !1) {
    this.detached = m, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = $r, !m && $r && (this.index = ($r.scopes || ($r.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let m, b;
      if (this.scopes)
        for (m = 0, b = this.scopes.length; m < b; m++)
          this.scopes[m].pause();
      for (m = 0, b = this.effects.length; m < b; m++)
        this.effects[m].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let m, b;
      if (this.scopes)
        for (m = 0, b = this.scopes.length; m < b; m++)
          this.scopes[m].resume();
      for (m = 0, b = this.effects.length; m < b; m++)
        this.effects[m].resume();
    }
  }
  run(m) {
    if (this._active) {
      const b = $r;
      try {
        return $r = this, m();
      } finally {
        $r = b;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    $r = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    $r = this.parent;
  }
  stop(m) {
    if (this._active) {
      this._active = !1;
      let b, S;
      for (b = 0, S = this.effects.length; b < S; b++)
        this.effects[b].stop();
      for (this.effects.length = 0, b = 0, S = this.cleanups.length; b < S; b++)
        this.cleanups[b]();
      if (this.cleanups.length = 0, this.scopes) {
        for (b = 0, S = this.scopes.length; b < S; b++)
          this.scopes[b].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !m) {
        const E = this.parent.scopes.pop();
        E && E !== this && (this.parent.scopes[this.index] = E, E.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Fg(u) {
  return new Lg(u);
}
function Bg() {
  return $r;
}
function ex(u, m = !1) {
  $r && $r.cleanups.push(u);
}
let yi;
const yp = /* @__PURE__ */ new WeakSet();
class Og {
  constructor(m) {
    this.fn = m, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, $r && $r.active && $r.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, yp.has(this) && (yp.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Vg(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Gm(this), Ng(this);
    const m = yi, b = jn;
    yi = this, jn = !0;
    try {
      return this.fn();
    } finally {
      $g(this), yi = m, jn = b, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let m = this.deps; m; m = m.nextDep)
        Kp(m);
      this.deps = this.depsTail = void 0, Gm(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? yp.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Ap(this) && this.run();
  }
  get dirty() {
    return Ap(this);
  }
}
let jg = 0, Xc, Kc;
function Vg(u, m = !1) {
  if (u.flags |= 8, m) {
    u.next = Kc, Kc = u;
    return;
  }
  u.next = Xc, Xc = u;
}
function Wp() {
  jg++;
}
function Xp() {
  if (--jg > 0)
    return;
  if (Kc) {
    let m = Kc;
    for (Kc = void 0; m; ) {
      const b = m.next;
      m.next = void 0, m.flags &= -9, m = b;
    }
  }
  let u;
  for (; Xc; ) {
    let m = Xc;
    for (Xc = void 0; m; ) {
      const b = m.next;
      if (m.next = void 0, m.flags &= -9, m.flags & 1)
        try {
          m.trigger();
        } catch (S) {
          u || (u = S);
        }
      m = b;
    }
  }
  if (u) throw u;
}
function Ng(u) {
  for (let m = u.deps; m; m = m.nextDep)
    m.version = -1, m.prevActiveLink = m.dep.activeLink, m.dep.activeLink = m;
}
function $g(u) {
  let m, b = u.depsTail, S = b;
  for (; S; ) {
    const E = S.prevDep;
    S.version === -1 ? (S === b && (b = E), Kp(S), tx(S)) : m = S, S.dep.activeLink = S.prevActiveLink, S.prevActiveLink = void 0, S = E;
  }
  u.deps = m, u.depsTail = b;
}
function Ap(u) {
  for (let m = u.deps; m; m = m.nextDep)
    if (m.dep.version !== m.version || m.dep.computed && (Ug(m.dep.computed) || m.dep.version !== m.version))
      return !0;
  return !!u._dirty;
}
function Ug(u) {
  if (u.flags & 4 && !(u.flags & 16) || (u.flags &= -17, u.globalVersion === tu))
    return;
  u.globalVersion = tu;
  const m = u.dep;
  if (u.flags |= 2, m.version > 0 && !u.isSSR && u.deps && !Ap(u)) {
    u.flags &= -3;
    return;
  }
  const b = yi, S = jn;
  yi = u, jn = !0;
  try {
    Ng(u);
    const E = u.fn(u._value);
    (m.version === 0 || bo(E, u._value)) && (u._value = E, m.version++);
  } catch (E) {
    throw m.version++, E;
  } finally {
    yi = b, jn = S, $g(u), u.flags &= -3;
  }
}
function Kp(u, m = !1) {
  const { dep: b, prevSub: S, nextSub: E } = u;
  if (S && (S.nextSub = E, u.prevSub = void 0), E && (E.prevSub = S, u.nextSub = void 0), b.subs === u && (b.subs = S, !S && b.computed)) {
    b.computed.flags &= -5;
    for (let D = b.computed.deps; D; D = D.nextDep)
      Kp(D, !0);
  }
  !m && !--b.sc && b.map && b.map.delete(b.key);
}
function tx(u) {
  const { prevDep: m, nextDep: b } = u;
  m && (m.nextDep = b, u.prevDep = void 0), b && (b.prevDep = m, u.nextDep = void 0);
}
let jn = !0;
const Zg = [];
function Po() {
  Zg.push(jn), jn = !1;
}
function Mo() {
  const u = Zg.pop();
  jn = u === void 0 ? !0 : u;
}
function Gm(u) {
  const { cleanup: m } = u;
  if (u.cleanup = void 0, m) {
    const b = yi;
    yi = void 0;
    try {
      m();
    } finally {
      yi = b;
    }
  }
}
let tu = 0;
class ix {
  constructor(m, b) {
    this.sub = m, this.dep = b, this.version = b.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Yp {
  constructor(m) {
    this.computed = m, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0;
  }
  track(m) {
    if (!yi || !jn || yi === this.computed)
      return;
    let b = this.activeLink;
    if (b === void 0 || b.sub !== yi)
      b = this.activeLink = new ix(yi, this), yi.deps ? (b.prevDep = yi.depsTail, yi.depsTail.nextDep = b, yi.depsTail = b) : yi.deps = yi.depsTail = b, Gg(b);
    else if (b.version === -1 && (b.version = this.version, b.nextDep)) {
      const S = b.nextDep;
      S.prevDep = b.prevDep, b.prevDep && (b.prevDep.nextDep = S), b.prevDep = yi.depsTail, b.nextDep = void 0, yi.depsTail.nextDep = b, yi.depsTail = b, yi.deps === b && (yi.deps = S);
    }
    return b;
  }
  trigger(m) {
    this.version++, tu++, this.notify(m);
  }
  notify(m) {
    Wp();
    try {
      for (let b = this.subs; b; b = b.prevSub)
        b.sub.notify() && b.sub.dep.notify();
    } finally {
      Xp();
    }
  }
}
function Gg(u) {
  if (u.dep.sc++, u.sub.flags & 4) {
    const m = u.dep.computed;
    if (m && !u.dep.subs) {
      m.flags |= 20;
      for (let S = m.deps; S; S = S.nextDep)
        Gg(S);
    }
    const b = u.dep.subs;
    b !== u && (u.prevSub = b, b && (b.nextSub = u)), u.dep.subs = u;
  }
}
const Eh = /* @__PURE__ */ new WeakMap(), ha = Symbol(
  ""
), kp = Symbol(
  ""
), iu = Symbol(
  ""
);
function zr(u, m, b) {
  if (jn && yi) {
    let S = Eh.get(u);
    S || Eh.set(u, S = /* @__PURE__ */ new Map());
    let E = S.get(b);
    E || (S.set(b, E = new Yp()), E.map = S, E.key = b), E.track();
  }
}
function Fs(u, m, b, S, E, D) {
  const T = Eh.get(u);
  if (!T) {
    tu++;
    return;
  }
  const a = (U) => {
    U && U.trigger();
  };
  if (Wp(), m === "clear")
    T.forEach(a);
  else {
    const U = Rt(u), ue = U && Hp(b);
    if (U && b === "length") {
      const ce = Number(S);
      T.forEach((ve, we) => {
        (we === "length" || we === iu || !Vs(we) && we >= ce) && a(ve);
      });
    } else
      switch ((b !== void 0 || T.has(void 0)) && a(T.get(b)), ue && a(T.get(iu)), m) {
        case "add":
          U ? ue && a(T.get("length")) : (a(T.get(ha)), Il(u) && a(T.get(kp)));
          break;
        case "delete":
          U || (a(T.get(ha)), Il(u) && a(T.get(kp)));
          break;
        case "set":
          Il(u) && a(T.get(ha));
          break;
      }
  }
  Xp();
}
function rx(u, m) {
  const b = Eh.get(u);
  return b && b.get(m);
}
function xl(u) {
  const m = Qt(u);
  return m === u ? m : (zr(m, "iterate", iu), Mn(u) ? m : m.map(Rr));
}
function Gh(u) {
  return zr(u = Qt(u), "iterate", iu), u;
}
const nx = {
  __proto__: null,
  [Symbol.iterator]() {
    return vp(this, Symbol.iterator, Rr);
  },
  concat(...u) {
    return xl(this).concat(
      ...u.map((m) => Rt(m) ? xl(m) : m)
    );
  },
  entries() {
    return vp(this, "entries", (u) => (u[1] = Rr(u[1]), u));
  },
  every(u, m) {
    return Ds(this, "every", u, m, void 0, arguments);
  },
  filter(u, m) {
    return Ds(this, "filter", u, m, (b) => b.map(Rr), arguments);
  },
  find(u, m) {
    return Ds(this, "find", u, m, Rr, arguments);
  },
  findIndex(u, m) {
    return Ds(this, "findIndex", u, m, void 0, arguments);
  },
  findLast(u, m) {
    return Ds(this, "findLast", u, m, Rr, arguments);
  },
  findLastIndex(u, m) {
    return Ds(this, "findLastIndex", u, m, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(u, m) {
    return Ds(this, "forEach", u, m, void 0, arguments);
  },
  includes(...u) {
    return xp(this, "includes", u);
  },
  indexOf(...u) {
    return xp(this, "indexOf", u);
  },
  join(u) {
    return xl(this).join(u);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...u) {
    return xp(this, "lastIndexOf", u);
  },
  map(u, m) {
    return Ds(this, "map", u, m, void 0, arguments);
  },
  pop() {
    return Uc(this, "pop");
  },
  push(...u) {
    return Uc(this, "push", u);
  },
  reduce(u, ...m) {
    return qm(this, "reduce", u, m);
  },
  reduceRight(u, ...m) {
    return qm(this, "reduceRight", u, m);
  },
  shift() {
    return Uc(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(u, m) {
    return Ds(this, "some", u, m, void 0, arguments);
  },
  splice(...u) {
    return Uc(this, "splice", u);
  },
  toReversed() {
    return xl(this).toReversed();
  },
  toSorted(u) {
    return xl(this).toSorted(u);
  },
  toSpliced(...u) {
    return xl(this).toSpliced(...u);
  },
  unshift(...u) {
    return Uc(this, "unshift", u);
  },
  values() {
    return vp(this, "values", Rr);
  }
};
function vp(u, m, b) {
  const S = Gh(u), E = S[m]();
  return S !== u && !Mn(u) && (E._next = E.next, E.next = () => {
    const D = E._next();
    return D.value && (D.value = b(D.value)), D;
  }), E;
}
const sx = Array.prototype;
function Ds(u, m, b, S, E, D) {
  const T = Gh(u), a = T !== u && !Mn(u), U = T[m];
  if (U !== sx[m]) {
    const ve = U.apply(u, D);
    return a ? Rr(ve) : ve;
  }
  let ue = b;
  T !== u && (a ? ue = function(ve, we) {
    return b.call(this, Rr(ve), we, u);
  } : b.length > 2 && (ue = function(ve, we) {
    return b.call(this, ve, we, u);
  }));
  const ce = U.call(T, ue, S);
  return a && E ? E(ce) : ce;
}
function qm(u, m, b, S) {
  const E = Gh(u);
  let D = b;
  return E !== u && (Mn(u) ? b.length > 3 && (D = function(T, a, U) {
    return b.call(this, T, a, U, u);
  }) : D = function(T, a, U) {
    return b.call(this, T, Rr(a), U, u);
  }), E[m](D, ...S);
}
function xp(u, m, b) {
  const S = Qt(u);
  zr(S, "iterate", iu);
  const E = S[m](...b);
  return (E === -1 || E === !1) && ef(b[0]) ? (b[0] = Qt(b[0]), S[m](...b)) : E;
}
function Uc(u, m, b = []) {
  Po(), Wp();
  const S = Qt(u)[m].apply(u, b);
  return Xp(), Mo(), S;
}
const ox = /* @__PURE__ */ Zp("__proto__,__v_isRef,__isVue"), qg = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((u) => u !== "arguments" && u !== "caller").map((u) => Symbol[u]).filter(Vs)
);
function ax(u) {
  Vs(u) || (u = String(u));
  const m = Qt(this);
  return zr(m, "has", u), m.hasOwnProperty(u);
}
class Hg {
  constructor(m = !1, b = !1) {
    this._isReadonly = m, this._isShallow = b;
  }
  get(m, b, S) {
    if (b === "__v_skip") return m.__v_skip;
    const E = this._isReadonly, D = this._isShallow;
    if (b === "__v_isReactive")
      return !E;
    if (b === "__v_isReadonly")
      return E;
    if (b === "__v_isShallow")
      return D;
    if (b === "__v_raw")
      return S === (E ? D ? _x : Yg : D ? Kg : Xg).get(m) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(m) === Object.getPrototypeOf(S) ? m : void 0;
    const T = Rt(m);
    if (!E) {
      let U;
      if (T && (U = nx[b]))
        return U;
      if (b === "hasOwnProperty")
        return ax;
    }
    const a = Reflect.get(
      m,
      b,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Ai(m) ? m : S
    );
    return (Vs(b) ? qg.has(b) : ox(b)) || (E || zr(m, "get", b), D) ? a : Ai(a) ? T && Hp(b) ? a : a.value : Mi(a) ? E ? Jg(a) : qh(a) : a;
  }
}
class Wg extends Hg {
  constructor(m = !1) {
    super(!1, m);
  }
  set(m, b, S, E) {
    let D = m[b];
    if (!this._isShallow) {
      const U = ga(D);
      if (!Mn(S) && !ga(S) && (D = Qt(D), S = Qt(S)), !Rt(m) && Ai(D) && !Ai(S))
        return U ? !1 : (D.value = S, !0);
    }
    const T = Rt(m) && Hp(b) ? Number(b) < m.length : li(m, b), a = Reflect.set(
      m,
      b,
      S,
      Ai(m) ? m : E
    );
    return m === Qt(E) && (T ? bo(S, D) && Fs(m, "set", b, S) : Fs(m, "add", b, S)), a;
  }
  deleteProperty(m, b) {
    const S = li(m, b);
    m[b];
    const E = Reflect.deleteProperty(m, b);
    return E && S && Fs(m, "delete", b, void 0), E;
  }
  has(m, b) {
    const S = Reflect.has(m, b);
    return (!Vs(b) || !qg.has(b)) && zr(m, "has", b), S;
  }
  ownKeys(m) {
    return zr(
      m,
      "iterate",
      Rt(m) ? "length" : ha
    ), Reflect.ownKeys(m);
  }
}
class lx extends Hg {
  constructor(m = !1) {
    super(!0, m);
  }
  set(m, b) {
    return !0;
  }
  deleteProperty(m, b) {
    return !0;
  }
}
const cx = /* @__PURE__ */ new Wg(), ux = /* @__PURE__ */ new lx(), hx = /* @__PURE__ */ new Wg(!0);
const zp = (u) => u, yh = (u) => Reflect.getPrototypeOf(u);
function dx(u, m, b) {
  return function(...S) {
    const E = this.__v_raw, D = Qt(E), T = Il(D), a = u === "entries" || u === Symbol.iterator && T, U = u === "keys" && T, ue = E[u](...S), ce = b ? zp : m ? Rp : Rr;
    return !m && zr(
      D,
      "iterate",
      U ? kp : ha
    ), {
      // iterator protocol
      next() {
        const { value: ve, done: we } = ue.next();
        return we ? { value: ve, done: we } : {
          value: a ? [ce(ve[0]), ce(ve[1])] : ce(ve),
          done: we
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function vh(u) {
  return function(...m) {
    return u === "delete" ? !1 : u === "clear" ? void 0 : this;
  };
}
function px(u, m) {
  const b = {
    get(E) {
      const D = this.__v_raw, T = Qt(D), a = Qt(E);
      u || (bo(E, a) && zr(T, "get", E), zr(T, "get", a));
      const { has: U } = yh(T), ue = m ? zp : u ? Rp : Rr;
      if (U.call(T, E))
        return ue(D.get(E));
      if (U.call(T, a))
        return ue(D.get(a));
      D !== T && D.get(E);
    },
    get size() {
      const E = this.__v_raw;
      return !u && zr(Qt(E), "iterate", ha), Reflect.get(E, "size", E);
    },
    has(E) {
      const D = this.__v_raw, T = Qt(D), a = Qt(E);
      return u || (bo(E, a) && zr(T, "has", E), zr(T, "has", a)), E === a ? D.has(E) : D.has(E) || D.has(a);
    },
    forEach(E, D) {
      const T = this, a = T.__v_raw, U = Qt(a), ue = m ? zp : u ? Rp : Rr;
      return !u && zr(U, "iterate", ha), a.forEach((ce, ve) => E.call(D, ue(ce), ue(ve), T));
    }
  };
  return Zr(
    b,
    u ? {
      add: vh("add"),
      set: vh("set"),
      delete: vh("delete"),
      clear: vh("clear")
    } : {
      add(E) {
        !m && !Mn(E) && !ga(E) && (E = Qt(E));
        const D = Qt(this);
        return yh(D).has.call(D, E) || (D.add(E), Fs(D, "add", E, E)), this;
      },
      set(E, D) {
        !m && !Mn(D) && !ga(D) && (D = Qt(D));
        const T = Qt(this), { has: a, get: U } = yh(T);
        let ue = a.call(T, E);
        ue || (E = Qt(E), ue = a.call(T, E));
        const ce = U.call(T, E);
        return T.set(E, D), ue ? bo(D, ce) && Fs(T, "set", E, D) : Fs(T, "add", E, D), this;
      },
      delete(E) {
        const D = Qt(this), { has: T, get: a } = yh(D);
        let U = T.call(D, E);
        U || (E = Qt(E), U = T.call(D, E)), a && a.call(D, E);
        const ue = D.delete(E);
        return U && Fs(D, "delete", E, void 0), ue;
      },
      clear() {
        const E = Qt(this), D = E.size !== 0, T = E.clear();
        return D && Fs(
          E,
          "clear",
          void 0,
          void 0
        ), T;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((E) => {
    b[E] = dx(E, u, m);
  }), b;
}
function Jp(u, m) {
  const b = px(u, m);
  return (S, E, D) => E === "__v_isReactive" ? !u : E === "__v_isReadonly" ? u : E === "__v_raw" ? S : Reflect.get(
    li(b, E) && E in S ? b : S,
    E,
    D
  );
}
const fx = {
  get: /* @__PURE__ */ Jp(!1, !1)
}, mx = {
  get: /* @__PURE__ */ Jp(!1, !0)
}, gx = {
  get: /* @__PURE__ */ Jp(!0, !1)
};
const Xg = /* @__PURE__ */ new WeakMap(), Kg = /* @__PURE__ */ new WeakMap(), Yg = /* @__PURE__ */ new WeakMap(), _x = /* @__PURE__ */ new WeakMap();
function yx(u) {
  switch (u) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function vx(u) {
  return u.__v_skip || !Object.isExtensible(u) ? 0 : yx(Gv(u));
}
function qh(u) {
  return ga(u) ? u : Qp(
    u,
    !1,
    cx,
    fx,
    Xg
  );
}
function xx(u) {
  return Qp(
    u,
    !1,
    hx,
    mx,
    Kg
  );
}
function Jg(u) {
  return Qp(
    u,
    !0,
    ux,
    gx,
    Yg
  );
}
function Qp(u, m, b, S, E) {
  if (!Mi(u) || u.__v_raw && !(m && u.__v_isReactive))
    return u;
  const D = E.get(u);
  if (D)
    return D;
  const T = vx(u);
  if (T === 0)
    return u;
  const a = new Proxy(
    u,
    T === 2 ? S : b
  );
  return E.set(u, a), a;
}
function Os(u) {
  return ga(u) ? Os(u.__v_raw) : !!(u && u.__v_isReactive);
}
function ga(u) {
  return !!(u && u.__v_isReadonly);
}
function Mn(u) {
  return !!(u && u.__v_isShallow);
}
function ef(u) {
  return u ? !!u.__v_raw : !1;
}
function Qt(u) {
  const m = u && u.__v_raw;
  return m ? Qt(m) : u;
}
function tf(u) {
  return !li(u, "__v_skip") && Object.isExtensible(u) && kg(u, "__v_skip", !0), u;
}
const Rr = (u) => Mi(u) ? qh(u) : u, Rp = (u) => Mi(u) ? Jg(u) : u;
function Ai(u) {
  return u ? u.__v_isRef === !0 : !1;
}
function ls(u) {
  return Qg(u, !1);
}
function On(u) {
  return Qg(u, !0);
}
function Qg(u, m) {
  return Ai(u) ? u : new bx(u, m);
}
class bx {
  constructor(m, b) {
    this.dep = new Yp(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = b ? m : Qt(m), this._value = b ? m : Rr(m), this.__v_isShallow = b;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(m) {
    const b = this._rawValue, S = this.__v_isShallow || Mn(m) || ga(m);
    m = S ? m : Qt(m), bo(m, b) && (this._rawValue = m, this._value = S ? m : Rr(m), this.dep.trigger());
  }
}
function Xe(u) {
  return Ai(u) ? u.value : u;
}
const wx = {
  get: (u, m, b) => m === "__v_raw" ? u : Xe(Reflect.get(u, m, b)),
  set: (u, m, b, S) => {
    const E = u[m];
    return Ai(E) && !Ai(b) ? (E.value = b, !0) : Reflect.set(u, m, b, S);
  }
};
function e_(u) {
  return Os(u) ? u : new Proxy(u, wx);
}
function Tx(u) {
  const m = Rt(u) ? new Array(u.length) : {};
  for (const b in u)
    m[b] = t_(u, b);
  return m;
}
class Sx {
  constructor(m, b, S) {
    this._object = m, this._key = b, this._defaultValue = S, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const m = this._object[this._key];
    return this._value = m === void 0 ? this._defaultValue : m;
  }
  set value(m) {
    this._object[this._key] = m;
  }
  get dep() {
    return rx(Qt(this._object), this._key);
  }
}
class Px {
  constructor(m) {
    this._getter = m, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function Mx(u, m, b) {
  return Ai(u) ? u : Vt(u) ? new Px(u) : Mi(u) && arguments.length > 1 ? t_(u, m, b) : ls(u);
}
function t_(u, m, b) {
  const S = u[m];
  return Ai(S) ? S : new Sx(u, m, b);
}
class Cx {
  constructor(m, b, S) {
    this.fn = m, this.setter = b, this._value = void 0, this.dep = new Yp(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = tu - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !b, this.isSSR = S;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    yi !== this)
      return Vg(this, !0), !0;
  }
  get value() {
    const m = this.dep.track();
    return Ug(this), m && (m.version = this.dep.version), this._value;
  }
  set value(m) {
    this.setter && this.setter(m);
  }
}
function Ix(u, m, b = !1) {
  let S, E;
  return Vt(u) ? S = u : (S = u.get, E = u.set), new Cx(S, E, b);
}
const xh = {}, Ah = /* @__PURE__ */ new WeakMap();
let ca;
function Ex(u, m = !1, b = ca) {
  if (b) {
    let S = Ah.get(b);
    S || Ah.set(b, S = []), S.push(u);
  }
}
function Ax(u, m, b = pi) {
  const { immediate: S, deep: E, once: D, scheduler: T, augmentJob: a, call: U } = b, ue = (Qe) => E ? Qe : Mn(Qe) || E === !1 || E === 0 ? Bs(Qe, 1) : Bs(Qe);
  let ce, ve, we, Q, Je = !1, it = !1;
  if (Ai(u) ? (ve = () => u.value, Je = Mn(u)) : Os(u) ? (ve = () => ue(u), Je = !0) : Rt(u) ? (it = !0, Je = u.some((Qe) => Os(Qe) || Mn(Qe)), ve = () => u.map((Qe) => {
    if (Ai(Qe))
      return Qe.value;
    if (Os(Qe))
      return ue(Qe);
    if (Vt(Qe))
      return U ? U(Qe, 2) : Qe();
  })) : Vt(u) ? m ? ve = U ? () => U(u, 2) : u : ve = () => {
    if (we) {
      Po();
      try {
        we();
      } finally {
        Mo();
      }
    }
    const Qe = ca;
    ca = ce;
    try {
      return U ? U(u, 3, [Q]) : u(Q);
    } finally {
      ca = Qe;
    }
  } : ve = os, m && E) {
    const Qe = ve, It = E === !0 ? 1 / 0 : E;
    ve = () => Bs(Qe(), It);
  }
  const vt = Bg(), Ze = () => {
    ce.stop(), vt && vt.active && qp(vt.effects, ce);
  };
  if (D && m) {
    const Qe = m;
    m = (...It) => {
      Qe(...It), Ze();
    };
  }
  let Ke = it ? new Array(u.length).fill(xh) : xh;
  const ut = (Qe) => {
    if (!(!(ce.flags & 1) || !ce.dirty && !Qe))
      if (m) {
        const It = ce.run();
        if (E || Je || (it ? It.some((ki, pt) => bo(ki, Ke[pt])) : bo(It, Ke))) {
          we && we();
          const ki = ca;
          ca = ce;
          try {
            const pt = [
              It,
              // pass undefined as the old value when it's changed for the first time
              Ke === xh ? void 0 : it && Ke[0] === xh ? [] : Ke,
              Q
            ];
            U ? U(m, 3, pt) : (
              // @ts-expect-error
              m(...pt)
            ), Ke = It;
          } finally {
            ca = ki;
          }
        }
      } else
        ce.run();
  };
  return a && a(ut), ce = new Og(ve), ce.scheduler = T ? () => T(ut, !1) : ut, Q = (Qe) => Ex(Qe, !1, ce), we = ce.onStop = () => {
    const Qe = Ah.get(ce);
    if (Qe) {
      if (U)
        U(Qe, 4);
      else
        for (const It of Qe) It();
      Ah.delete(ce);
    }
  }, m ? S ? ut(!0) : Ke = ce.run() : T ? T(ut.bind(null, !0), !0) : ce.run(), Ze.pause = ce.pause.bind(ce), Ze.resume = ce.resume.bind(ce), Ze.stop = Ze, Ze;
}
function Bs(u, m = 1 / 0, b) {
  if (m <= 0 || !Mi(u) || u.__v_skip || (b = b || /* @__PURE__ */ new Set(), b.has(u)))
    return u;
  if (b.add(u), m--, Ai(u))
    Bs(u.value, m, b);
  else if (Rt(u))
    for (let S = 0; S < u.length; S++)
      Bs(u[S], m, b);
  else if (Mg(u) || Il(u))
    u.forEach((S) => {
      Bs(S, m, b);
    });
  else if (Eg(u)) {
    for (const S in u)
      Bs(u[S], m, b);
    for (const S of Object.getOwnPropertySymbols(u))
      Object.prototype.propertyIsEnumerable.call(u, S) && Bs(u[S], m, b);
  }
  return u;
}
/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function ou(u, m, b, S) {
  try {
    return S ? u(...S) : u();
  } catch (E) {
    Hh(E, m, b);
  }
}
function cs(u, m, b, S) {
  if (Vt(u)) {
    const E = ou(u, m, b, S);
    return E && Cg(E) && E.catch((D) => {
      Hh(D, m, b);
    }), E;
  }
  if (Rt(u)) {
    const E = [];
    for (let D = 0; D < u.length; D++)
      E.push(cs(u[D], m, b, S));
    return E;
  }
}
function Hh(u, m, b, S = !0) {
  const E = m ? m.vnode : null, { errorHandler: D, throwUnhandledErrorInProduction: T } = m && m.appContext.config || pi;
  if (m) {
    let a = m.parent;
    const U = m.proxy, ue = `https://vuejs.org/error-reference/#runtime-${b}`;
    for (; a; ) {
      const ce = a.ec;
      if (ce) {
        for (let ve = 0; ve < ce.length; ve++)
          if (ce[ve](u, U, ue) === !1)
            return;
      }
      a = a.parent;
    }
    if (D) {
      Po(), ou(D, null, 10, [
        u,
        U,
        ue
      ]), Mo();
      return;
    }
  }
  kx(u, b, E, S, T);
}
function kx(u, m, b, S = !0, E = !1) {
  if (E)
    throw u;
  console.error(u);
}
const Ur = [];
let ns = -1;
const El = [];
let vo = null, Tl = 0;
const i_ = /* @__PURE__ */ Promise.resolve();
let kh = null;
function r_(u) {
  const m = kh || i_;
  return u ? m.then(this ? u.bind(this) : u) : m;
}
function zx(u) {
  let m = ns + 1, b = Ur.length;
  for (; m < b; ) {
    const S = m + b >>> 1, E = Ur[S], D = ru(E);
    D < u || D === u && E.flags & 2 ? m = S + 1 : b = S;
  }
  return m;
}
function rf(u) {
  if (!(u.flags & 1)) {
    const m = ru(u), b = Ur[Ur.length - 1];
    !b || // fast path when the job id is larger than the tail
    !(u.flags & 2) && m >= ru(b) ? Ur.push(u) : Ur.splice(zx(m), 0, u), u.flags |= 1, n_();
  }
}
function n_() {
  kh || (kh = i_.then(o_));
}
function Rx(u) {
  Rt(u) ? El.push(...u) : vo && u.id === -1 ? vo.splice(Tl + 1, 0, u) : u.flags & 1 || (El.push(u), u.flags |= 1), n_();
}
function Hm(u, m, b = ns + 1) {
  for (; b < Ur.length; b++) {
    const S = Ur[b];
    if (S && S.flags & 2) {
      if (u && S.id !== u.uid)
        continue;
      Ur.splice(b, 1), b--, S.flags & 4 && (S.flags &= -2), S(), S.flags & 4 || (S.flags &= -2);
    }
  }
}
function s_(u) {
  if (El.length) {
    const m = [...new Set(El)].sort(
      (b, S) => ru(b) - ru(S)
    );
    if (El.length = 0, vo) {
      vo.push(...m);
      return;
    }
    for (vo = m, Tl = 0; Tl < vo.length; Tl++) {
      const b = vo[Tl];
      b.flags & 4 && (b.flags &= -2), b.flags & 8 || b(), b.flags &= -2;
    }
    vo = null, Tl = 0;
  }
}
const ru = (u) => u.id == null ? u.flags & 2 ? -1 : 1 / 0 : u.id;
function o_(u) {
  try {
    for (ns = 0; ns < Ur.length; ns++) {
      const m = Ur[ns];
      m && !(m.flags & 8) && (m.flags & 4 && (m.flags &= -2), ou(
        m,
        m.i,
        m.i ? 15 : 14
      ), m.flags & 4 || (m.flags &= -2));
    }
  } finally {
    for (; ns < Ur.length; ns++) {
      const m = Ur[ns];
      m && (m.flags &= -2);
    }
    ns = -1, Ur.length = 0, s_(), kh = null, (Ur.length || El.length) && o_();
  }
}
let _r = null, a_ = null;
function zh(u) {
  const m = _r;
  return _r = u, a_ = u && u.type.__scopeId || null, m;
}
function da(u, m = _r, b) {
  if (!m || u._n)
    return u;
  const S = (...E) => {
    S._d && ig(-1);
    const D = zh(m);
    let T;
    try {
      T = u(...E);
    } finally {
      zh(D), S._d && ig(1);
    }
    return T;
  };
  return S._n = !0, S._c = !0, S._d = !0, S;
}
function qc(u, m) {
  if (_r === null)
    return u;
  const b = Yh(_r), S = u.dirs || (u.dirs = []);
  for (let E = 0; E < m.length; E++) {
    let [D, T, a, U = pi] = m[E];
    D && (Vt(D) && (D = {
      mounted: D,
      updated: D
    }), D.deep && Bs(T), S.push({
      dir: D,
      instance: b,
      value: T,
      oldValue: void 0,
      arg: a,
      modifiers: U
    }));
  }
  return u;
}
function aa(u, m, b, S) {
  const E = u.dirs, D = m && m.dirs;
  for (let T = 0; T < E.length; T++) {
    const a = E[T];
    D && (a.oldValue = D[T].value);
    let U = a.dir[S];
    U && (Po(), cs(U, b, 8, [
      u.el,
      a,
      u,
      m
    ]), Mo());
  }
}
const Dx = Symbol("_vte"), Lx = (u) => u.__isTeleport;
function nf(u, m) {
  u.shapeFlag & 6 && u.component ? (u.transition = m, nf(u.component.subTree, m)) : u.shapeFlag & 128 ? (u.ssContent.transition = m.clone(u.ssContent), u.ssFallback.transition = m.clone(u.ssFallback)) : u.transition = m;
}
function l_(u) {
  u.ids = [u.ids[0] + u.ids[2]++ + "-", 0, 0];
}
function Fx(u) {
  const m = R0(), b = On(null);
  if (m) {
    const E = m.refs === pi ? m.refs = {} : m.refs;
    Object.defineProperty(E, u, {
      enumerable: !0,
      get: () => b.value,
      set: (D) => b.value = D
    });
  }
  return b;
}
function Rh(u, m, b, S, E = !1) {
  if (Rt(u)) {
    u.forEach(
      (Je, it) => Rh(
        Je,
        m && (Rt(m) ? m[it] : m),
        b,
        S,
        E
      )
    );
    return;
  }
  if (Al(S) && !E) {
    S.shapeFlag & 512 && S.type.__asyncResolved && S.component.subTree.component && Rh(u, m, b, S.component.subTree);
    return;
  }
  const D = S.shapeFlag & 4 ? Yh(S.component) : S.el, T = E ? null : D, { i: a, r: U } = u, ue = m && m.r, ce = a.refs === pi ? a.refs = {} : a.refs, ve = a.setupState, we = Qt(ve), Q = ve === pi ? () => !1 : (Je) => li(we, Je);
  if (ue != null && ue !== U && (tr(ue) ? (ce[ue] = null, Q(ue) && (ve[ue] = null)) : Ai(ue) && (ue.value = null)), Vt(U))
    ou(U, a, 12, [T, ce]);
  else {
    const Je = tr(U), it = Ai(U);
    if (Je || it) {
      const vt = () => {
        if (u.f) {
          const Ze = Je ? Q(U) ? ve[U] : ce[U] : U.value;
          E ? Rt(Ze) && qp(Ze, D) : Rt(Ze) ? Ze.includes(D) || Ze.push(D) : Je ? (ce[U] = [D], Q(U) && (ve[U] = ce[U])) : (U.value = [D], u.k && (ce[u.k] = U.value));
        } else Je ? (ce[U] = T, Q(U) && (ve[U] = T)) : it && (U.value = T, u.k && (ce[u.k] = T));
      };
      T ? (vt.id = -1, _n(vt, b)) : vt();
    }
  }
}
Zh().requestIdleCallback;
Zh().cancelIdleCallback;
const Al = (u) => !!u.type.__asyncLoader, c_ = (u) => u.type.__isKeepAlive;
function Bx(u, m) {
  u_(u, "a", m);
}
function Ox(u, m) {
  u_(u, "da", m);
}
function u_(u, m, b = Pr) {
  const S = u.__wdc || (u.__wdc = () => {
    let E = b;
    for (; E; ) {
      if (E.isDeactivated)
        return;
      E = E.parent;
    }
    return u();
  });
  if (Wh(m, S, b), b) {
    let E = b.parent;
    for (; E && E.parent; )
      c_(E.parent.vnode) && jx(S, m, b, E), E = E.parent;
  }
}
function jx(u, m, b, S) {
  const E = Wh(
    m,
    u,
    S,
    !0
    /* prepend */
  );
  d_(() => {
    qp(S[m], E);
  }, b);
}
function Wh(u, m, b = Pr, S = !1) {
  if (b) {
    const E = b[u] || (b[u] = []), D = m.__weh || (m.__weh = (...T) => {
      Po();
      const a = au(b), U = cs(m, b, u, T);
      return a(), Mo(), U;
    });
    return S ? E.unshift(D) : E.push(D), D;
  }
}
const Ns = (u) => (m, b = Pr) => {
  (!su || u === "sp") && Wh(u, (...S) => m(...S), b);
}, Vx = Ns("bm"), h_ = Ns("m"), Nx = Ns(
  "bu"
), $x = Ns("u"), Ux = Ns(
  "bum"
), d_ = Ns("um"), Zx = Ns(
  "sp"
), Gx = Ns("rtg"), qx = Ns("rtc");
function Hx(u, m = Pr) {
  Wh("ec", u, m);
}
const Wx = Symbol.for("v-ndc");
function kl(u, m, b, S) {
  let E;
  const D = b, T = Rt(u);
  if (T || tr(u)) {
    const a = T && Os(u);
    let U = !1;
    a && (U = !Mn(u), u = Gh(u)), E = new Array(u.length);
    for (let ue = 0, ce = u.length; ue < ce; ue++)
      E[ue] = m(
        U ? Rr(u[ue]) : u[ue],
        ue,
        void 0,
        D
      );
  } else if (typeof u == "number") {
    E = new Array(u);
    for (let a = 0; a < u; a++)
      E[a] = m(a + 1, a, void 0, D);
  } else if (Mi(u))
    if (u[Symbol.iterator])
      E = Array.from(
        u,
        (a, U) => m(a, U, void 0, D)
      );
    else {
      const a = Object.keys(u);
      E = new Array(a.length);
      for (let U = 0, ue = a.length; U < ue; U++) {
        const ce = a[U];
        E[U] = m(u[ce], ce, U, D);
      }
    }
  else
    E = [];
  return E;
}
function Xx(u, m, b = {}, S, E) {
  if (_r.ce || _r.parent && Al(_r.parent) && _r.parent.ce)
    return wt(), gr(
      lr,
      null,
      [ci("slot", b, S)],
      64
    );
  let D = u[m];
  D && D._c && (D._d = !1), wt();
  const T = D && p_(D(b)), a = b.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  T && T.key, U = gr(
    lr,
    {
      key: (a && !Vs(a) ? a : `_${m}`) + // #7256 force differentiate fallback content from actual content
      ""
    },
    T || [],
    T && u._ === 1 ? 64 : -2
  );
  return U.scopeId && (U.slotScopeIds = [U.scopeId + "-s"]), D && D._c && (D._d = !0), U;
}
function p_(u) {
  return u.some((m) => of(m) ? !(m.type === To || m.type === lr && !p_(m.children)) : !0) ? u : null;
}
const Dp = (u) => u ? D_(u) ? Yh(u) : Dp(u.parent) : null, Yc = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Zr(/* @__PURE__ */ Object.create(null), {
    $: (u) => u,
    $el: (u) => u.vnode.el,
    $data: (u) => u.data,
    $props: (u) => u.props,
    $attrs: (u) => u.attrs,
    $slots: (u) => u.slots,
    $refs: (u) => u.refs,
    $parent: (u) => Dp(u.parent),
    $root: (u) => Dp(u.root),
    $host: (u) => u.ce,
    $emit: (u) => u.emit,
    $options: (u) => m_(u),
    $forceUpdate: (u) => u.f || (u.f = () => {
      rf(u.update);
    }),
    $nextTick: (u) => u.n || (u.n = r_.bind(u.proxy)),
    $watch: (u) => y0.bind(u)
  })
), bp = (u, m) => u !== pi && !u.__isScriptSetup && li(u, m), Kx = {
  get({ _: u }, m) {
    if (m === "__v_skip")
      return !0;
    const { ctx: b, setupState: S, data: E, props: D, accessCache: T, type: a, appContext: U } = u;
    let ue;
    if (m[0] !== "$") {
      const Q = T[m];
      if (Q !== void 0)
        switch (Q) {
          case 1:
            return S[m];
          case 2:
            return E[m];
          case 4:
            return b[m];
          case 3:
            return D[m];
        }
      else {
        if (bp(S, m))
          return T[m] = 1, S[m];
        if (E !== pi && li(E, m))
          return T[m] = 2, E[m];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (ue = u.propsOptions[0]) && li(ue, m)
        )
          return T[m] = 3, D[m];
        if (b !== pi && li(b, m))
          return T[m] = 4, b[m];
        Lp && (T[m] = 0);
      }
    }
    const ce = Yc[m];
    let ve, we;
    if (ce)
      return m === "$attrs" && zr(u.attrs, "get", ""), ce(u);
    if (
      // css module (injected by vue-loader)
      (ve = a.__cssModules) && (ve = ve[m])
    )
      return ve;
    if (b !== pi && li(b, m))
      return T[m] = 4, b[m];
    if (
      // global properties
      we = U.config.globalProperties, li(we, m)
    )
      return we[m];
  },
  set({ _: u }, m, b) {
    const { data: S, setupState: E, ctx: D } = u;
    return bp(E, m) ? (E[m] = b, !0) : S !== pi && li(S, m) ? (S[m] = b, !0) : li(u.props, m) || m[0] === "$" && m.slice(1) in u ? !1 : (D[m] = b, !0);
  },
  has({
    _: { data: u, setupState: m, accessCache: b, ctx: S, appContext: E, propsOptions: D }
  }, T) {
    let a;
    return !!b[T] || u !== pi && li(u, T) || bp(m, T) || (a = D[0]) && li(a, T) || li(S, T) || li(Yc, T) || li(E.config.globalProperties, T);
  },
  defineProperty(u, m, b) {
    return b.get != null ? u._.accessCache[m] = 0 : li(b, "value") && this.set(u, m, b.value, null), Reflect.defineProperty(u, m, b);
  }
};
function Wm(u) {
  return Rt(u) ? u.reduce(
    (m, b) => (m[b] = null, m),
    {}
  ) : u;
}
let Lp = !0;
function Yx(u) {
  const m = m_(u), b = u.proxy, S = u.ctx;
  Lp = !1, m.beforeCreate && Xm(m.beforeCreate, u, "bc");
  const {
    // state
    data: E,
    computed: D,
    methods: T,
    watch: a,
    provide: U,
    inject: ue,
    // lifecycle
    created: ce,
    beforeMount: ve,
    mounted: we,
    beforeUpdate: Q,
    updated: Je,
    activated: it,
    deactivated: vt,
    beforeDestroy: Ze,
    beforeUnmount: Ke,
    destroyed: ut,
    unmounted: Qe,
    render: It,
    renderTracked: ki,
    renderTriggered: pt,
    errorCaptured: at,
    serverPrefetch: _t,
    // public API
    expose: Et,
    inheritAttrs: Ut,
    // assets
    components: fi,
    directives: ir,
    filters: Jr
  } = m;
  if (ue && Jx(ue, S, null), T)
    for (const At in T) {
      const Jt = T[At];
      Vt(Jt) && (S[At] = Jt.bind(b));
    }
  if (E) {
    const At = E.call(b, b);
    Mi(At) && (u.data = qh(At));
  }
  if (Lp = !0, D)
    for (const At in D) {
      const Jt = D[At], Zt = Vt(Jt) ? Jt.bind(b, b) : Vt(Jt.get) ? Jt.get.bind(b, b) : os, qr = !Vt(Jt) && Vt(Jt.set) ? Jt.set.bind(b) : os, mi = cr({
        get: Zt,
        set: qr
      });
      Object.defineProperty(S, At, {
        enumerable: !0,
        configurable: !0,
        get: () => mi.value,
        set: (Gi) => mi.value = Gi
      });
    }
  if (a)
    for (const At in a)
      f_(a[At], S, b, At);
  if (U) {
    const At = Vt(U) ? U.call(b) : U;
    Reflect.ownKeys(At).forEach((Jt) => {
      n0(Jt, At[Jt]);
    });
  }
  ce && Xm(ce, u, "c");
  function ti(At, Jt) {
    Rt(Jt) ? Jt.forEach((Zt) => At(Zt.bind(b))) : Jt && At(Jt.bind(b));
  }
  if (ti(Vx, ve), ti(h_, we), ti(Nx, Q), ti($x, Je), ti(Bx, it), ti(Ox, vt), ti(Hx, at), ti(qx, ki), ti(Gx, pt), ti(Ux, Ke), ti(d_, Qe), ti(Zx, _t), Rt(Et))
    if (Et.length) {
      const At = u.exposed || (u.exposed = {});
      Et.forEach((Jt) => {
        Object.defineProperty(At, Jt, {
          get: () => b[Jt],
          set: (Zt) => b[Jt] = Zt
        });
      });
    } else u.exposed || (u.exposed = {});
  It && u.render === os && (u.render = It), Ut != null && (u.inheritAttrs = Ut), fi && (u.components = fi), ir && (u.directives = ir), _t && l_(u);
}
function Jx(u, m, b = os) {
  Rt(u) && (u = Fp(u));
  for (const S in u) {
    const E = u[S];
    let D;
    Mi(E) ? "default" in E ? D = Jc(
      E.from || S,
      E.default,
      !0
    ) : D = Jc(E.from || S) : D = Jc(E), Ai(D) ? Object.defineProperty(m, S, {
      enumerable: !0,
      configurable: !0,
      get: () => D.value,
      set: (T) => D.value = T
    }) : m[S] = D;
  }
}
function Xm(u, m, b) {
  cs(
    Rt(u) ? u.map((S) => S.bind(m.proxy)) : u.bind(m.proxy),
    m,
    b
  );
}
function f_(u, m, b, S) {
  let E = S.includes(".") ? E_(b, S) : () => b[S];
  if (tr(u)) {
    const D = m[u];
    Vt(D) && Sh(E, D);
  } else if (Vt(u))
    Sh(E, u.bind(b));
  else if (Mi(u))
    if (Rt(u))
      u.forEach((D) => f_(D, m, b, S));
    else {
      const D = Vt(u.handler) ? u.handler.bind(b) : m[u.handler];
      Vt(D) && Sh(E, D, u);
    }
}
function m_(u) {
  const m = u.type, { mixins: b, extends: S } = m, {
    mixins: E,
    optionsCache: D,
    config: { optionMergeStrategies: T }
  } = u.appContext, a = D.get(m);
  let U;
  return a ? U = a : !E.length && !b && !S ? U = m : (U = {}, E.length && E.forEach(
    (ue) => Dh(U, ue, T, !0)
  ), Dh(U, m, T)), Mi(m) && D.set(m, U), U;
}
function Dh(u, m, b, S = !1) {
  const { mixins: E, extends: D } = m;
  D && Dh(u, D, b, !0), E && E.forEach(
    (T) => Dh(u, T, b, !0)
  );
  for (const T in m)
    if (!(S && T === "expose")) {
      const a = Qx[T] || b && b[T];
      u[T] = a ? a(u[T], m[T]) : m[T];
    }
  return u;
}
const Qx = {
  data: Km,
  props: Ym,
  emits: Ym,
  // objects
  methods: Hc,
  computed: Hc,
  // lifecycle
  beforeCreate: Nr,
  created: Nr,
  beforeMount: Nr,
  mounted: Nr,
  beforeUpdate: Nr,
  updated: Nr,
  beforeDestroy: Nr,
  beforeUnmount: Nr,
  destroyed: Nr,
  unmounted: Nr,
  activated: Nr,
  deactivated: Nr,
  errorCaptured: Nr,
  serverPrefetch: Nr,
  // assets
  components: Hc,
  directives: Hc,
  // watch
  watch: t0,
  // provide / inject
  provide: Km,
  inject: e0
};
function Km(u, m) {
  return m ? u ? function() {
    return Zr(
      Vt(u) ? u.call(this, this) : u,
      Vt(m) ? m.call(this, this) : m
    );
  } : m : u;
}
function e0(u, m) {
  return Hc(Fp(u), Fp(m));
}
function Fp(u) {
  if (Rt(u)) {
    const m = {};
    for (let b = 0; b < u.length; b++)
      m[u[b]] = u[b];
    return m;
  }
  return u;
}
function Nr(u, m) {
  return u ? [...new Set([].concat(u, m))] : m;
}
function Hc(u, m) {
  return u ? Zr(/* @__PURE__ */ Object.create(null), u, m) : m;
}
function Ym(u, m) {
  return u ? Rt(u) && Rt(m) ? [.../* @__PURE__ */ new Set([...u, ...m])] : Zr(
    /* @__PURE__ */ Object.create(null),
    Wm(u),
    Wm(m ?? {})
  ) : m;
}
function t0(u, m) {
  if (!u) return m;
  if (!m) return u;
  const b = Zr(/* @__PURE__ */ Object.create(null), u);
  for (const S in m)
    b[S] = Nr(u[S], m[S]);
  return b;
}
function g_() {
  return {
    app: null,
    config: {
      isNativeTag: Uv,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let i0 = 0;
function r0(u, m) {
  return function(S, E = null) {
    Vt(S) || (S = Zr({}, S)), E != null && !Mi(E) && (E = null);
    const D = g_(), T = /* @__PURE__ */ new WeakSet(), a = [];
    let U = !1;
    const ue = D.app = {
      _uid: i0++,
      _component: S,
      _props: E,
      _container: null,
      _context: D,
      _instance: null,
      version: j0,
      get config() {
        return D.config;
      },
      set config(ce) {
      },
      use(ce, ...ve) {
        return T.has(ce) || (ce && Vt(ce.install) ? (T.add(ce), ce.install(ue, ...ve)) : Vt(ce) && (T.add(ce), ce(ue, ...ve))), ue;
      },
      mixin(ce) {
        return D.mixins.includes(ce) || D.mixins.push(ce), ue;
      },
      component(ce, ve) {
        return ve ? (D.components[ce] = ve, ue) : D.components[ce];
      },
      directive(ce, ve) {
        return ve ? (D.directives[ce] = ve, ue) : D.directives[ce];
      },
      mount(ce, ve, we) {
        if (!U) {
          const Q = ue._ceVNode || ci(S, E);
          return Q.appContext = D, we === !0 ? we = "svg" : we === !1 && (we = void 0), u(Q, ce, we), U = !0, ue._container = ce, ce.__vue_app__ = ue, Yh(Q.component);
        }
      },
      onUnmount(ce) {
        a.push(ce);
      },
      unmount() {
        U && (cs(
          a,
          ue._instance,
          16
        ), u(null, ue._container), delete ue._container.__vue_app__);
      },
      provide(ce, ve) {
        return D.provides[ce] = ve, ue;
      },
      runWithContext(ce) {
        const ve = pa;
        pa = ue;
        try {
          return ce();
        } finally {
          pa = ve;
        }
      }
    };
    return ue;
  };
}
let pa = null;
function n0(u, m) {
  if (Pr) {
    let b = Pr.provides;
    const S = Pr.parent && Pr.parent.provides;
    S === b && (b = Pr.provides = Object.create(S)), b[u] = m;
  }
}
function Jc(u, m, b = !1) {
  const S = Pr || _r;
  if (S || pa) {
    const E = pa ? pa._context.provides : S ? S.parent == null ? S.vnode.appContext && S.vnode.appContext.provides : S.parent.provides : void 0;
    if (E && u in E)
      return E[u];
    if (arguments.length > 1)
      return b && Vt(m) ? m.call(S && S.proxy) : m;
  }
}
function s0() {
  return !!(Pr || _r || pa);
}
const __ = {}, y_ = () => Object.create(__), v_ = (u) => Object.getPrototypeOf(u) === __;
function o0(u, m, b, S = !1) {
  const E = {}, D = y_();
  u.propsDefaults = /* @__PURE__ */ Object.create(null), x_(u, m, E, D);
  for (const T in u.propsOptions[0])
    T in E || (E[T] = void 0);
  b ? u.props = S ? E : xx(E) : u.type.props ? u.props = E : u.props = D, u.attrs = D;
}
function a0(u, m, b, S) {
  const {
    props: E,
    attrs: D,
    vnode: { patchFlag: T }
  } = u, a = Qt(E), [U] = u.propsOptions;
  let ue = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (S || T > 0) && !(T & 16)
  ) {
    if (T & 8) {
      const ce = u.vnode.dynamicProps;
      for (let ve = 0; ve < ce.length; ve++) {
        let we = ce[ve];
        if (Xh(u.emitsOptions, we))
          continue;
        const Q = m[we];
        if (U)
          if (li(D, we))
            Q !== D[we] && (D[we] = Q, ue = !0);
          else {
            const Je = wo(we);
            E[Je] = Bp(
              U,
              a,
              Je,
              Q,
              u,
              !1
            );
          }
        else
          Q !== D[we] && (D[we] = Q, ue = !0);
      }
    }
  } else {
    x_(u, m, E, D) && (ue = !0);
    let ce;
    for (const ve in a)
      (!m || // for camelCase
      !li(m, ve) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((ce = ya(ve)) === ve || !li(m, ce))) && (U ? b && // for camelCase
      (b[ve] !== void 0 || // for kebab-case
      b[ce] !== void 0) && (E[ve] = Bp(
        U,
        a,
        ve,
        void 0,
        u,
        !0
      )) : delete E[ve]);
    if (D !== a)
      for (const ve in D)
        (!m || !li(m, ve)) && (delete D[ve], ue = !0);
  }
  ue && Fs(u.attrs, "set", "");
}
function x_(u, m, b, S) {
  const [E, D] = u.propsOptions;
  let T = !1, a;
  if (m)
    for (let U in m) {
      if (Wc(U))
        continue;
      const ue = m[U];
      let ce;
      E && li(E, ce = wo(U)) ? !D || !D.includes(ce) ? b[ce] = ue : (a || (a = {}))[ce] = ue : Xh(u.emitsOptions, U) || (!(U in S) || ue !== S[U]) && (S[U] = ue, T = !0);
    }
  if (D) {
    const U = Qt(b), ue = a || pi;
    for (let ce = 0; ce < D.length; ce++) {
      const ve = D[ce];
      b[ve] = Bp(
        E,
        U,
        ve,
        ue[ve],
        u,
        !li(ue, ve)
      );
    }
  }
  return T;
}
function Bp(u, m, b, S, E, D) {
  const T = u[b];
  if (T != null) {
    const a = li(T, "default");
    if (a && S === void 0) {
      const U = T.default;
      if (T.type !== Function && !T.skipFactory && Vt(U)) {
        const { propsDefaults: ue } = E;
        if (b in ue)
          S = ue[b];
        else {
          const ce = au(E);
          S = ue[b] = U.call(
            null,
            m
          ), ce();
        }
      } else
        S = U;
      E.ce && E.ce._setProp(b, S);
    }
    T[
      0
      /* shouldCast */
    ] && (D && !a ? S = !1 : T[
      1
      /* shouldCastTrue */
    ] && (S === "" || S === ya(b)) && (S = !0));
  }
  return S;
}
const l0 = /* @__PURE__ */ new WeakMap();
function b_(u, m, b = !1) {
  const S = b ? l0 : m.propsCache, E = S.get(u);
  if (E)
    return E;
  const D = u.props, T = {}, a = [];
  let U = !1;
  if (!Vt(u)) {
    const ce = (ve) => {
      U = !0;
      const [we, Q] = b_(ve, m, !0);
      Zr(T, we), Q && a.push(...Q);
    };
    !b && m.mixins.length && m.mixins.forEach(ce), u.extends && ce(u.extends), u.mixins && u.mixins.forEach(ce);
  }
  if (!D && !U)
    return Mi(u) && S.set(u, Cl), Cl;
  if (Rt(D))
    for (let ce = 0; ce < D.length; ce++) {
      const ve = wo(D[ce]);
      Jm(ve) && (T[ve] = pi);
    }
  else if (D)
    for (const ce in D) {
      const ve = wo(ce);
      if (Jm(ve)) {
        const we = D[ce], Q = T[ve] = Rt(we) || Vt(we) ? { type: we } : Zr({}, we), Je = Q.type;
        let it = !1, vt = !0;
        if (Rt(Je))
          for (let Ze = 0; Ze < Je.length; ++Ze) {
            const Ke = Je[Ze], ut = Vt(Ke) && Ke.name;
            if (ut === "Boolean") {
              it = !0;
              break;
            } else ut === "String" && (vt = !1);
          }
        else
          it = Vt(Je) && Je.name === "Boolean";
        Q[
          0
          /* shouldCast */
        ] = it, Q[
          1
          /* shouldCastTrue */
        ] = vt, (it || li(Q, "default")) && a.push(ve);
      }
    }
  const ue = [T, a];
  return Mi(u) && S.set(u, ue), ue;
}
function Jm(u) {
  return u[0] !== "$" && !Wc(u);
}
const w_ = (u) => u[0] === "_" || u === "$stable", sf = (u) => Rt(u) ? u.map(ss) : [ss(u)], c0 = (u, m, b) => {
  if (m._n)
    return m;
  const S = da((...E) => sf(m(...E)), b);
  return S._c = !1, S;
}, T_ = (u, m, b) => {
  const S = u._ctx;
  for (const E in u) {
    if (w_(E)) continue;
    const D = u[E];
    if (Vt(D))
      m[E] = c0(E, D, S);
    else if (D != null) {
      const T = sf(D);
      m[E] = () => T;
    }
  }
}, S_ = (u, m) => {
  const b = sf(m);
  u.slots.default = () => b;
}, P_ = (u, m, b) => {
  for (const S in m)
    (b || S !== "_") && (u[S] = m[S]);
}, u0 = (u, m, b) => {
  const S = u.slots = y_();
  if (u.vnode.shapeFlag & 32) {
    const E = m._;
    E ? (P_(S, m, b), b && kg(S, "_", E, !0)) : T_(m, S);
  } else m && S_(u, m);
}, h0 = (u, m, b) => {
  const { vnode: S, slots: E } = u;
  let D = !0, T = pi;
  if (S.shapeFlag & 32) {
    const a = m._;
    a ? b && a === 1 ? D = !1 : P_(E, m, b) : (D = !m.$stable, T_(m, E)), T = m;
  } else m && (S_(u, m), T = { default: 1 });
  if (D)
    for (const a in E)
      !w_(a) && T[a] == null && delete E[a];
}, _n = P0;
function d0(u) {
  return p0(u);
}
function p0(u, m) {
  const b = Zh();
  b.__VUE__ = !0;
  const {
    insert: S,
    remove: E,
    patchProp: D,
    createElement: T,
    createText: a,
    createComment: U,
    setText: ue,
    setElementText: ce,
    parentNode: ve,
    nextSibling: we,
    setScopeId: Q = os,
    insertStaticContent: Je
  } = u, it = (ne, ae, Se, ze = null, Ae = null, Re = null, He = void 0, Ue = null, Ge = !!ae.dynamicChildren) => {
    if (ne === ae)
      return;
    ne && !Zc(ne, ae) && (ze = Qr(ne), Gi(ne, Ae, Re, !0), ne = null), ae.patchFlag === -2 && (Ge = !1, ae.dynamicChildren = null);
    const { type: De, ref: ht, shapeFlag: Ye } = ae;
    switch (De) {
      case Kh:
        vt(ne, ae, Se, ze);
        break;
      case To:
        Ze(ne, ae, Se, ze);
        break;
      case Tp:
        ne == null && Ke(ae, Se, ze, He);
        break;
      case lr:
        fi(
          ne,
          ae,
          Se,
          ze,
          Ae,
          Re,
          He,
          Ue,
          Ge
        );
        break;
      default:
        Ye & 1 ? It(
          ne,
          ae,
          Se,
          ze,
          Ae,
          Re,
          He,
          Ue,
          Ge
        ) : Ye & 6 ? ir(
          ne,
          ae,
          Se,
          ze,
          Ae,
          Re,
          He,
          Ue,
          Ge
        ) : (Ye & 64 || Ye & 128) && De.process(
          ne,
          ae,
          Se,
          ze,
          Ae,
          Re,
          He,
          Ue,
          Ge,
          Hr
        );
    }
    ht != null && Ae && Rh(ht, ne && ne.ref, Re, ae || ne, !ae);
  }, vt = (ne, ae, Se, ze) => {
    if (ne == null)
      S(
        ae.el = a(ae.children),
        Se,
        ze
      );
    else {
      const Ae = ae.el = ne.el;
      ae.children !== ne.children && ue(Ae, ae.children);
    }
  }, Ze = (ne, ae, Se, ze) => {
    ne == null ? S(
      ae.el = U(ae.children || ""),
      Se,
      ze
    ) : ae.el = ne.el;
  }, Ke = (ne, ae, Se, ze) => {
    [ne.el, ne.anchor] = Je(
      ne.children,
      ae,
      Se,
      ze,
      ne.el,
      ne.anchor
    );
  }, ut = ({ el: ne, anchor: ae }, Se, ze) => {
    let Ae;
    for (; ne && ne !== ae; )
      Ae = we(ne), S(ne, Se, ze), ne = Ae;
    S(ae, Se, ze);
  }, Qe = ({ el: ne, anchor: ae }) => {
    let Se;
    for (; ne && ne !== ae; )
      Se = we(ne), E(ne), ne = Se;
    E(ae);
  }, It = (ne, ae, Se, ze, Ae, Re, He, Ue, Ge) => {
    ae.type === "svg" ? He = "svg" : ae.type === "math" && (He = "mathml"), ne == null ? ki(
      ae,
      Se,
      ze,
      Ae,
      Re,
      He,
      Ue,
      Ge
    ) : _t(
      ne,
      ae,
      Ae,
      Re,
      He,
      Ue,
      Ge
    );
  }, ki = (ne, ae, Se, ze, Ae, Re, He, Ue) => {
    let Ge, De;
    const { props: ht, shapeFlag: Ye, transition: ct, dirs: gt } = ne;
    if (Ge = ne.el = T(
      ne.type,
      Re,
      ht && ht.is,
      ht
    ), Ye & 8 ? ce(Ge, ne.children) : Ye & 16 && at(
      ne.children,
      Ge,
      null,
      ze,
      Ae,
      wp(ne, Re),
      He,
      Ue
    ), gt && aa(ne, null, ze, "created"), pt(Ge, ne, ne.scopeId, He, ze), ht) {
      for (const Wt in ht)
        Wt !== "value" && !Wc(Wt) && D(Ge, Wt, null, ht[Wt], Re, ze);
      "value" in ht && D(Ge, "value", null, ht.value, Re), (De = ht.onVnodeBeforeMount) && rs(De, ze, ne);
    }
    gt && aa(ne, null, ze, "beforeMount");
    const zt = f0(Ae, ct);
    zt && ct.beforeEnter(Ge), S(Ge, ae, Se), ((De = ht && ht.onVnodeMounted) || zt || gt) && _n(() => {
      De && rs(De, ze, ne), zt && ct.enter(Ge), gt && aa(ne, null, ze, "mounted");
    }, Ae);
  }, pt = (ne, ae, Se, ze, Ae) => {
    if (Se && Q(ne, Se), ze)
      for (let Re = 0; Re < ze.length; Re++)
        Q(ne, ze[Re]);
    if (Ae) {
      let Re = Ae.subTree;
      if (ae === Re || k_(Re.type) && (Re.ssContent === ae || Re.ssFallback === ae)) {
        const He = Ae.vnode;
        pt(
          ne,
          He,
          He.scopeId,
          He.slotScopeIds,
          Ae.parent
        );
      }
    }
  }, at = (ne, ae, Se, ze, Ae, Re, He, Ue, Ge = 0) => {
    for (let De = Ge; De < ne.length; De++) {
      const ht = ne[De] = Ue ? xo(ne[De]) : ss(ne[De]);
      it(
        null,
        ht,
        ae,
        Se,
        ze,
        Ae,
        Re,
        He,
        Ue
      );
    }
  }, _t = (ne, ae, Se, ze, Ae, Re, He) => {
    const Ue = ae.el = ne.el;
    let { patchFlag: Ge, dynamicChildren: De, dirs: ht } = ae;
    Ge |= ne.patchFlag & 16;
    const Ye = ne.props || pi, ct = ae.props || pi;
    let gt;
    if (Se && la(Se, !1), (gt = ct.onVnodeBeforeUpdate) && rs(gt, Se, ae, ne), ht && aa(ae, ne, Se, "beforeUpdate"), Se && la(Se, !0), (Ye.innerHTML && ct.innerHTML == null || Ye.textContent && ct.textContent == null) && ce(Ue, ""), De ? Et(
      ne.dynamicChildren,
      De,
      Ue,
      Se,
      ze,
      wp(ae, Ae),
      Re
    ) : He || Jt(
      ne,
      ae,
      Ue,
      null,
      Se,
      ze,
      wp(ae, Ae),
      Re,
      !1
    ), Ge > 0) {
      if (Ge & 16)
        Ut(Ue, Ye, ct, Se, Ae);
      else if (Ge & 2 && Ye.class !== ct.class && D(Ue, "class", null, ct.class, Ae), Ge & 4 && D(Ue, "style", Ye.style, ct.style, Ae), Ge & 8) {
        const zt = ae.dynamicProps;
        for (let Wt = 0; Wt < zt.length; Wt++) {
          const Ht = zt[Wt], oe = Ye[Ht], B = ct[Ht];
          (B !== oe || Ht === "value") && D(Ue, Ht, oe, B, Ae, Se);
        }
      }
      Ge & 1 && ne.children !== ae.children && ce(Ue, ae.children);
    } else !He && De == null && Ut(Ue, Ye, ct, Se, Ae);
    ((gt = ct.onVnodeUpdated) || ht) && _n(() => {
      gt && rs(gt, Se, ae, ne), ht && aa(ae, ne, Se, "updated");
    }, ze);
  }, Et = (ne, ae, Se, ze, Ae, Re, He) => {
    for (let Ue = 0; Ue < ae.length; Ue++) {
      const Ge = ne[Ue], De = ae[Ue], ht = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        Ge.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (Ge.type === lr || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Zc(Ge, De) || // - In the case of a component, it could contain anything.
        Ge.shapeFlag & 70) ? ve(Ge.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          Se
        )
      );
      it(
        Ge,
        De,
        ht,
        null,
        ze,
        Ae,
        Re,
        He,
        !0
      );
    }
  }, Ut = (ne, ae, Se, ze, Ae) => {
    if (ae !== Se) {
      if (ae !== pi)
        for (const Re in ae)
          !Wc(Re) && !(Re in Se) && D(
            ne,
            Re,
            ae[Re],
            null,
            Ae,
            ze
          );
      for (const Re in Se) {
        if (Wc(Re)) continue;
        const He = Se[Re], Ue = ae[Re];
        He !== Ue && Re !== "value" && D(ne, Re, Ue, He, Ae, ze);
      }
      "value" in Se && D(ne, "value", ae.value, Se.value, Ae);
    }
  }, fi = (ne, ae, Se, ze, Ae, Re, He, Ue, Ge) => {
    const De = ae.el = ne ? ne.el : a(""), ht = ae.anchor = ne ? ne.anchor : a("");
    let { patchFlag: Ye, dynamicChildren: ct, slotScopeIds: gt } = ae;
    gt && (Ue = Ue ? Ue.concat(gt) : gt), ne == null ? (S(De, Se, ze), S(ht, Se, ze), at(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      ae.children || [],
      Se,
      ht,
      Ae,
      Re,
      He,
      Ue,
      Ge
    )) : Ye > 0 && Ye & 64 && ct && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    ne.dynamicChildren ? (Et(
      ne.dynamicChildren,
      ct,
      Se,
      Ae,
      Re,
      He,
      Ue
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (ae.key != null || Ae && ae === Ae.subTree) && M_(
      ne,
      ae,
      !0
      /* shallow */
    )) : Jt(
      ne,
      ae,
      Se,
      ht,
      Ae,
      Re,
      He,
      Ue,
      Ge
    );
  }, ir = (ne, ae, Se, ze, Ae, Re, He, Ue, Ge) => {
    ae.slotScopeIds = Ue, ne == null ? ae.shapeFlag & 512 ? Ae.ctx.activate(
      ae,
      Se,
      ze,
      He,
      Ge
    ) : Jr(
      ae,
      Se,
      ze,
      Ae,
      Re,
      He,
      Ge
    ) : Gr(ne, ae, Ge);
  }, Jr = (ne, ae, Se, ze, Ae, Re, He) => {
    const Ue = ne.component = z0(
      ne,
      ze,
      Ae
    );
    if (c_(ne) && (Ue.ctx.renderer = Hr), D0(Ue, !1, He), Ue.asyncDep) {
      if (Ae && Ae.registerDep(Ue, ti, He), !ne.el) {
        const Ge = Ue.subTree = ci(To);
        Ze(null, Ge, ae, Se);
      }
    } else
      ti(
        Ue,
        ne,
        ae,
        Se,
        Ae,
        Re,
        He
      );
  }, Gr = (ne, ae, Se) => {
    const ze = ae.component = ne.component;
    if (T0(ne, ae, Se))
      if (ze.asyncDep && !ze.asyncResolved) {
        At(ze, ae, Se);
        return;
      } else
        ze.next = ae, ze.update();
    else
      ae.el = ne.el, ze.vnode = ae;
  }, ti = (ne, ae, Se, ze, Ae, Re, He) => {
    const Ue = () => {
      if (ne.isMounted) {
        let { next: Ye, bu: ct, u: gt, parent: zt, vnode: Wt } = ne;
        {
          const N = C_(ne);
          if (N) {
            Ye && (Ye.el = Wt.el, At(ne, Ye, He)), N.asyncDep.then(() => {
              ne.isUnmounted || Ue();
            });
            return;
          }
        }
        let Ht = Ye, oe;
        la(ne, !1), Ye ? (Ye.el = Wt.el, At(ne, Ye, He)) : Ye = Wt, ct && Th(ct), (oe = Ye.props && Ye.props.onVnodeBeforeUpdate) && rs(oe, zt, Ye, Wt), la(ne, !0);
        const B = eg(ne), j = ne.subTree;
        ne.subTree = B, it(
          j,
          B,
          // parent may have changed if it's in a teleport
          ve(j.el),
          // anchor may have changed if it's in a fragment
          Qr(j),
          ne,
          Ae,
          Re
        ), Ye.el = B.el, Ht === null && S0(ne, B.el), gt && _n(gt, Ae), (oe = Ye.props && Ye.props.onVnodeUpdated) && _n(
          () => rs(oe, zt, Ye, Wt),
          Ae
        );
      } else {
        let Ye;
        const { el: ct, props: gt } = ae, { bm: zt, m: Wt, parent: Ht, root: oe, type: B } = ne, j = Al(ae);
        la(ne, !1), zt && Th(zt), !j && (Ye = gt && gt.onVnodeBeforeMount) && rs(Ye, Ht, ae), la(ne, !0);
        {
          oe.ce && oe.ce._injectChildStyle(B);
          const N = ne.subTree = eg(ne);
          it(
            null,
            N,
            Se,
            ze,
            ne,
            Ae,
            Re
          ), ae.el = N.el;
        }
        if (Wt && _n(Wt, Ae), !j && (Ye = gt && gt.onVnodeMounted)) {
          const N = ae;
          _n(
            () => rs(Ye, Ht, N),
            Ae
          );
        }
        (ae.shapeFlag & 256 || Ht && Al(Ht.vnode) && Ht.vnode.shapeFlag & 256) && ne.a && _n(ne.a, Ae), ne.isMounted = !0, ae = Se = ze = null;
      }
    };
    ne.scope.on();
    const Ge = ne.effect = new Og(Ue);
    ne.scope.off();
    const De = ne.update = Ge.run.bind(Ge), ht = ne.job = Ge.runIfDirty.bind(Ge);
    ht.i = ne, ht.id = ne.uid, Ge.scheduler = () => rf(ht), la(ne, !0), De();
  }, At = (ne, ae, Se) => {
    ae.component = ne;
    const ze = ne.vnode.props;
    ne.vnode = ae, ne.next = null, a0(ne, ae.props, ze, Se), h0(ne, ae.children, Se), Po(), Hm(ne), Mo();
  }, Jt = (ne, ae, Se, ze, Ae, Re, He, Ue, Ge = !1) => {
    const De = ne && ne.children, ht = ne ? ne.shapeFlag : 0, Ye = ae.children, { patchFlag: ct, shapeFlag: gt } = ae;
    if (ct > 0) {
      if (ct & 128) {
        qr(
          De,
          Ye,
          Se,
          ze,
          Ae,
          Re,
          He,
          Ue,
          Ge
        );
        return;
      } else if (ct & 256) {
        Zt(
          De,
          Ye,
          Se,
          ze,
          Ae,
          Re,
          He,
          Ue,
          Ge
        );
        return;
      }
    }
    gt & 8 ? (ht & 16 && zi(De, Ae, Re), Ye !== De && ce(Se, Ye)) : ht & 16 ? gt & 16 ? qr(
      De,
      Ye,
      Se,
      ze,
      Ae,
      Re,
      He,
      Ue,
      Ge
    ) : zi(De, Ae, Re, !0) : (ht & 8 && ce(Se, ""), gt & 16 && at(
      Ye,
      Se,
      ze,
      Ae,
      Re,
      He,
      Ue,
      Ge
    ));
  }, Zt = (ne, ae, Se, ze, Ae, Re, He, Ue, Ge) => {
    ne = ne || Cl, ae = ae || Cl;
    const De = ne.length, ht = ae.length, Ye = Math.min(De, ht);
    let ct;
    for (ct = 0; ct < Ye; ct++) {
      const gt = ae[ct] = Ge ? xo(ae[ct]) : ss(ae[ct]);
      it(
        ne[ct],
        gt,
        Se,
        null,
        Ae,
        Re,
        He,
        Ue,
        Ge
      );
    }
    De > ht ? zi(
      ne,
      Ae,
      Re,
      !0,
      !1,
      Ye
    ) : at(
      ae,
      Se,
      ze,
      Ae,
      Re,
      He,
      Ue,
      Ge,
      Ye
    );
  }, qr = (ne, ae, Se, ze, Ae, Re, He, Ue, Ge) => {
    let De = 0;
    const ht = ae.length;
    let Ye = ne.length - 1, ct = ht - 1;
    for (; De <= Ye && De <= ct; ) {
      const gt = ne[De], zt = ae[De] = Ge ? xo(ae[De]) : ss(ae[De]);
      if (Zc(gt, zt))
        it(
          gt,
          zt,
          Se,
          null,
          Ae,
          Re,
          He,
          Ue,
          Ge
        );
      else
        break;
      De++;
    }
    for (; De <= Ye && De <= ct; ) {
      const gt = ne[Ye], zt = ae[ct] = Ge ? xo(ae[ct]) : ss(ae[ct]);
      if (Zc(gt, zt))
        it(
          gt,
          zt,
          Se,
          null,
          Ae,
          Re,
          He,
          Ue,
          Ge
        );
      else
        break;
      Ye--, ct--;
    }
    if (De > Ye) {
      if (De <= ct) {
        const gt = ct + 1, zt = gt < ht ? ae[gt].el : ze;
        for (; De <= ct; )
          it(
            null,
            ae[De] = Ge ? xo(ae[De]) : ss(ae[De]),
            Se,
            zt,
            Ae,
            Re,
            He,
            Ue,
            Ge
          ), De++;
      }
    } else if (De > ct)
      for (; De <= Ye; )
        Gi(ne[De], Ae, Re, !0), De++;
    else {
      const gt = De, zt = De, Wt = /* @__PURE__ */ new Map();
      for (De = zt; De <= ct; De++) {
        const le = ae[De] = Ge ? xo(ae[De]) : ss(ae[De]);
        le.key != null && Wt.set(le.key, De);
      }
      let Ht, oe = 0;
      const B = ct - zt + 1;
      let j = !1, N = 0;
      const X = new Array(B);
      for (De = 0; De < B; De++) X[De] = 0;
      for (De = gt; De <= Ye; De++) {
        const le = ne[De];
        if (oe >= B) {
          Gi(le, Ae, Re, !0);
          continue;
        }
        let me;
        if (le.key != null)
          me = Wt.get(le.key);
        else
          for (Ht = zt; Ht <= ct; Ht++)
            if (X[Ht - zt] === 0 && Zc(le, ae[Ht])) {
              me = Ht;
              break;
            }
        me === void 0 ? Gi(le, Ae, Re, !0) : (X[me - zt] = De + 1, me >= N ? N = me : j = !0, it(
          le,
          ae[me],
          Se,
          null,
          Ae,
          Re,
          He,
          Ue,
          Ge
        ), oe++);
      }
      const ie = j ? m0(X) : Cl;
      for (Ht = ie.length - 1, De = B - 1; De >= 0; De--) {
        const le = zt + De, me = ae[le], de = le + 1 < ht ? ae[le + 1].el : ze;
        X[De] === 0 ? it(
          null,
          me,
          Se,
          de,
          Ae,
          Re,
          He,
          Ue,
          Ge
        ) : j && (Ht < 0 || De !== ie[Ht] ? mi(me, Se, de, 2) : Ht--);
      }
    }
  }, mi = (ne, ae, Se, ze, Ae = null) => {
    const { el: Re, type: He, transition: Ue, children: Ge, shapeFlag: De } = ne;
    if (De & 6) {
      mi(ne.component.subTree, ae, Se, ze);
      return;
    }
    if (De & 128) {
      ne.suspense.move(ae, Se, ze);
      return;
    }
    if (De & 64) {
      He.move(ne, ae, Se, Hr);
      return;
    }
    if (He === lr) {
      S(Re, ae, Se);
      for (let Ye = 0; Ye < Ge.length; Ye++)
        mi(Ge[Ye], ae, Se, ze);
      S(ne.anchor, ae, Se);
      return;
    }
    if (He === Tp) {
      ut(ne, ae, Se);
      return;
    }
    if (ze !== 2 && De & 1 && Ue)
      if (ze === 0)
        Ue.beforeEnter(Re), S(Re, ae, Se), _n(() => Ue.enter(Re), Ae);
      else {
        const { leave: Ye, delayLeave: ct, afterLeave: gt } = Ue, zt = () => S(Re, ae, Se), Wt = () => {
          Ye(Re, () => {
            zt(), gt && gt();
          });
        };
        ct ? ct(Re, zt, Wt) : Wt();
      }
    else
      S(Re, ae, Se);
  }, Gi = (ne, ae, Se, ze = !1, Ae = !1) => {
    const {
      type: Re,
      props: He,
      ref: Ue,
      children: Ge,
      dynamicChildren: De,
      shapeFlag: ht,
      patchFlag: Ye,
      dirs: ct,
      cacheIndex: gt
    } = ne;
    if (Ye === -2 && (Ae = !1), Ue != null && Rh(Ue, null, Se, ne, !0), gt != null && (ae.renderCache[gt] = void 0), ht & 256) {
      ae.ctx.deactivate(ne);
      return;
    }
    const zt = ht & 1 && ct, Wt = !Al(ne);
    let Ht;
    if (Wt && (Ht = He && He.onVnodeBeforeUnmount) && rs(Ht, ae, ne), ht & 6)
      Cn(ne.component, Se, ze);
    else {
      if (ht & 128) {
        ne.suspense.unmount(Se, ze);
        return;
      }
      zt && aa(ne, null, ae, "beforeUnmount"), ht & 64 ? ne.type.remove(
        ne,
        ae,
        Se,
        Hr,
        ze
      ) : De && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !De.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (Re !== lr || Ye > 0 && Ye & 64) ? zi(
        De,
        ae,
        Se,
        !1,
        !0
      ) : (Re === lr && Ye & 384 || !Ae && ht & 16) && zi(Ge, ae, Se), ze && Dr(ne);
    }
    (Wt && (Ht = He && He.onVnodeUnmounted) || zt) && _n(() => {
      Ht && rs(Ht, ae, ne), zt && aa(ne, null, ae, "unmounted");
    }, Se);
  }, Dr = (ne) => {
    const { type: ae, el: Se, anchor: ze, transition: Ae } = ne;
    if (ae === lr) {
      vn(Se, ze);
      return;
    }
    if (ae === Tp) {
      Qe(ne);
      return;
    }
    const Re = () => {
      E(Se), Ae && !Ae.persisted && Ae.afterLeave && Ae.afterLeave();
    };
    if (ne.shapeFlag & 1 && Ae && !Ae.persisted) {
      const { leave: He, delayLeave: Ue } = Ae, Ge = () => He(Se, Re);
      Ue ? Ue(ne.el, Re, Ge) : Ge();
    } else
      Re();
  }, vn = (ne, ae) => {
    let Se;
    for (; ne !== ae; )
      Se = we(ne), E(ne), ne = Se;
    E(ae);
  }, Cn = (ne, ae, Se) => {
    const { bum: ze, scope: Ae, job: Re, subTree: He, um: Ue, m: Ge, a: De } = ne;
    Qm(Ge), Qm(De), ze && Th(ze), Ae.stop(), Re && (Re.flags |= 8, Gi(He, ne, ae, Se)), Ue && _n(Ue, ae), _n(() => {
      ne.isUnmounted = !0;
    }, ae), ae && ae.pendingBranch && !ae.isUnmounted && ne.asyncDep && !ne.asyncResolved && ne.suspenseId === ae.pendingId && (ae.deps--, ae.deps === 0 && ae.resolve());
  }, zi = (ne, ae, Se, ze = !1, Ae = !1, Re = 0) => {
    for (let He = Re; He < ne.length; He++)
      Gi(ne[He], ae, Se, ze, Ae);
  }, Qr = (ne) => {
    if (ne.shapeFlag & 6)
      return Qr(ne.component.subTree);
    if (ne.shapeFlag & 128)
      return ne.suspense.next();
    const ae = we(ne.anchor || ne.el), Se = ae && ae[Dx];
    return Se ? we(Se) : ae;
  };
  let ur = !1;
  const Mr = (ne, ae, Se) => {
    ne == null ? ae._vnode && Gi(ae._vnode, null, null, !0) : it(
      ae._vnode || null,
      ne,
      ae,
      null,
      null,
      null,
      Se
    ), ae._vnode = ne, ur || (ur = !0, Hm(), s_(), ur = !1);
  }, Hr = {
    p: it,
    um: Gi,
    m: mi,
    r: Dr,
    mt: Jr,
    mc: at,
    pc: Jt,
    pbc: Et,
    n: Qr,
    o: u
  };
  return {
    render: Mr,
    hydrate: void 0,
    createApp: r0(Mr)
  };
}
function wp({ type: u, props: m }, b) {
  return b === "svg" && u === "foreignObject" || b === "mathml" && u === "annotation-xml" && m && m.encoding && m.encoding.includes("html") ? void 0 : b;
}
function la({ effect: u, job: m }, b) {
  b ? (u.flags |= 32, m.flags |= 4) : (u.flags &= -33, m.flags &= -5);
}
function f0(u, m) {
  return (!u || u && !u.pendingBranch) && m && !m.persisted;
}
function M_(u, m, b = !1) {
  const S = u.children, E = m.children;
  if (Rt(S) && Rt(E))
    for (let D = 0; D < S.length; D++) {
      const T = S[D];
      let a = E[D];
      a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = E[D] = xo(E[D]), a.el = T.el), !b && a.patchFlag !== -2 && M_(T, a)), a.type === Kh && (a.el = T.el);
    }
}
function m0(u) {
  const m = u.slice(), b = [0];
  let S, E, D, T, a;
  const U = u.length;
  for (S = 0; S < U; S++) {
    const ue = u[S];
    if (ue !== 0) {
      if (E = b[b.length - 1], u[E] < ue) {
        m[S] = E, b.push(S);
        continue;
      }
      for (D = 0, T = b.length - 1; D < T; )
        a = D + T >> 1, u[b[a]] < ue ? D = a + 1 : T = a;
      ue < u[b[D]] && (D > 0 && (m[S] = b[D - 1]), b[D] = S);
    }
  }
  for (D = b.length, T = b[D - 1]; D-- > 0; )
    b[D] = T, T = m[T];
  return b;
}
function C_(u) {
  const m = u.subTree.component;
  if (m)
    return m.asyncDep && !m.asyncResolved ? m : C_(m);
}
function Qm(u) {
  if (u)
    for (let m = 0; m < u.length; m++)
      u[m].flags |= 8;
}
const g0 = Symbol.for("v-scx"), _0 = () => Jc(g0);
function Sh(u, m, b) {
  return I_(u, m, b);
}
function I_(u, m, b = pi) {
  const { immediate: S, deep: E, flush: D, once: T } = b, a = Zr({}, b), U = m && S || !m && D !== "post";
  let ue;
  if (su) {
    if (D === "sync") {
      const Q = _0();
      ue = Q.__watcherHandles || (Q.__watcherHandles = []);
    } else if (!U) {
      const Q = () => {
      };
      return Q.stop = os, Q.resume = os, Q.pause = os, Q;
    }
  }
  const ce = Pr;
  a.call = (Q, Je, it) => cs(Q, ce, Je, it);
  let ve = !1;
  D === "post" ? a.scheduler = (Q) => {
    _n(Q, ce && ce.suspense);
  } : D !== "sync" && (ve = !0, a.scheduler = (Q, Je) => {
    Je ? Q() : rf(Q);
  }), a.augmentJob = (Q) => {
    m && (Q.flags |= 4), ve && (Q.flags |= 2, ce && (Q.id = ce.uid, Q.i = ce));
  };
  const we = Ax(u, m, a);
  return su && (ue ? ue.push(we) : U && we()), we;
}
function y0(u, m, b) {
  const S = this.proxy, E = tr(u) ? u.includes(".") ? E_(S, u) : () => S[u] : u.bind(S, S);
  let D;
  Vt(m) ? D = m : (D = m.handler, b = m);
  const T = au(this), a = I_(E, D.bind(S), b);
  return T(), a;
}
function E_(u, m) {
  const b = m.split(".");
  return () => {
    let S = u;
    for (let E = 0; E < b.length && S; E++)
      S = S[b[E]];
    return S;
  };
}
const v0 = (u, m) => m === "modelValue" || m === "model-value" ? u.modelModifiers : u[`${m}Modifiers`] || u[`${wo(m)}Modifiers`] || u[`${ya(m)}Modifiers`];
function x0(u, m, ...b) {
  if (u.isUnmounted) return;
  const S = u.vnode.props || pi;
  let E = b;
  const D = m.startsWith("update:"), T = D && v0(S, m.slice(7));
  T && (T.trim && (E = b.map((ce) => tr(ce) ? ce.trim() : ce)), T.number && (E = b.map(Ep)));
  let a, U = S[a = gp(m)] || // also try camelCase event handler (#2249)
  S[a = gp(wo(m))];
  !U && D && (U = S[a = gp(ya(m))]), U && cs(
    U,
    u,
    6,
    E
  );
  const ue = S[a + "Once"];
  if (ue) {
    if (!u.emitted)
      u.emitted = {};
    else if (u.emitted[a])
      return;
    u.emitted[a] = !0, cs(
      ue,
      u,
      6,
      E
    );
  }
}
function A_(u, m, b = !1) {
  const S = m.emitsCache, E = S.get(u);
  if (E !== void 0)
    return E;
  const D = u.emits;
  let T = {}, a = !1;
  if (!Vt(u)) {
    const U = (ue) => {
      const ce = A_(ue, m, !0);
      ce && (a = !0, Zr(T, ce));
    };
    !b && m.mixins.length && m.mixins.forEach(U), u.extends && U(u.extends), u.mixins && u.mixins.forEach(U);
  }
  return !D && !a ? (Mi(u) && S.set(u, null), null) : (Rt(D) ? D.forEach((U) => T[U] = null) : Zr(T, D), Mi(u) && S.set(u, T), T);
}
function Xh(u, m) {
  return !u || !Nh(m) ? !1 : (m = m.slice(2).replace(/Once$/, ""), li(u, m[0].toLowerCase() + m.slice(1)) || li(u, ya(m)) || li(u, m));
}
function eg(u) {
  const {
    type: m,
    vnode: b,
    proxy: S,
    withProxy: E,
    propsOptions: [D],
    slots: T,
    attrs: a,
    emit: U,
    render: ue,
    renderCache: ce,
    props: ve,
    data: we,
    setupState: Q,
    ctx: Je,
    inheritAttrs: it
  } = u, vt = zh(u);
  let Ze, Ke;
  try {
    if (b.shapeFlag & 4) {
      const Qe = E || S, It = Qe;
      Ze = ss(
        ue.call(
          It,
          Qe,
          ce,
          ve,
          Q,
          we,
          Je
        )
      ), Ke = a;
    } else {
      const Qe = m;
      Ze = ss(
        Qe.length > 1 ? Qe(
          ve,
          { attrs: a, slots: T, emit: U }
        ) : Qe(
          ve,
          null
        )
      ), Ke = m.props ? a : b0(a);
    }
  } catch (Qe) {
    Qc.length = 0, Hh(Qe, u, 1), Ze = ci(To);
  }
  let ut = Ze;
  if (Ke && it !== !1) {
    const Qe = Object.keys(Ke), { shapeFlag: It } = ut;
    Qe.length && It & 7 && (D && Qe.some(Gp) && (Ke = w0(
      Ke,
      D
    )), ut = zl(ut, Ke, !1, !0));
  }
  return b.dirs && (ut = zl(ut, null, !1, !0), ut.dirs = ut.dirs ? ut.dirs.concat(b.dirs) : b.dirs), b.transition && nf(ut, b.transition), Ze = ut, zh(vt), Ze;
}
const b0 = (u) => {
  let m;
  for (const b in u)
    (b === "class" || b === "style" || Nh(b)) && ((m || (m = {}))[b] = u[b]);
  return m;
}, w0 = (u, m) => {
  const b = {};
  for (const S in u)
    (!Gp(S) || !(S.slice(9) in m)) && (b[S] = u[S]);
  return b;
};
function T0(u, m, b) {
  const { props: S, children: E, component: D } = u, { props: T, children: a, patchFlag: U } = m, ue = D.emitsOptions;
  if (m.dirs || m.transition)
    return !0;
  if (b && U >= 0) {
    if (U & 1024)
      return !0;
    if (U & 16)
      return S ? tg(S, T, ue) : !!T;
    if (U & 8) {
      const ce = m.dynamicProps;
      for (let ve = 0; ve < ce.length; ve++) {
        const we = ce[ve];
        if (T[we] !== S[we] && !Xh(ue, we))
          return !0;
      }
    }
  } else
    return (E || a) && (!a || !a.$stable) ? !0 : S === T ? !1 : S ? T ? tg(S, T, ue) : !0 : !!T;
  return !1;
}
function tg(u, m, b) {
  const S = Object.keys(m);
  if (S.length !== Object.keys(u).length)
    return !0;
  for (let E = 0; E < S.length; E++) {
    const D = S[E];
    if (m[D] !== u[D] && !Xh(b, D))
      return !0;
  }
  return !1;
}
function S0({ vnode: u, parent: m }, b) {
  for (; m; ) {
    const S = m.subTree;
    if (S.suspense && S.suspense.activeBranch === u && (S.el = u.el), S === u)
      (u = m.vnode).el = b, m = m.parent;
    else
      break;
  }
}
const k_ = (u) => u.__isSuspense;
function P0(u, m) {
  m && m.pendingBranch ? Rt(u) ? m.effects.push(...u) : m.effects.push(u) : Rx(u);
}
const lr = Symbol.for("v-fgt"), Kh = Symbol.for("v-txt"), To = Symbol.for("v-cmt"), Tp = Symbol.for("v-stc"), Qc = [];
let yn = null;
function wt(u = !1) {
  Qc.push(yn = u ? null : []);
}
function M0() {
  Qc.pop(), yn = Qc[Qc.length - 1] || null;
}
let nu = 1;
function ig(u, m = !1) {
  nu += u, u < 0 && yn && m && (yn.hasOnce = !0);
}
function z_(u) {
  return u.dynamicChildren = nu > 0 ? yn || Cl : null, M0(), nu > 0 && yn && yn.push(u), u;
}
function Yt(u, m, b, S, E, D) {
  return z_(
    yt(
      u,
      m,
      b,
      S,
      E,
      D,
      !0
    )
  );
}
function gr(u, m, b, S, E) {
  return z_(
    ci(
      u,
      m,
      b,
      S,
      E,
      !0
    )
  );
}
function of(u) {
  return u ? u.__v_isVNode === !0 : !1;
}
function Zc(u, m) {
  return u.type === m.type && u.key === m.key;
}
const R_ = ({ key: u }) => u ?? null, Ph = ({
  ref: u,
  ref_key: m,
  ref_for: b
}) => (typeof u == "number" && (u = "" + u), u != null ? tr(u) || Ai(u) || Vt(u) ? { i: _r, r: u, k: m, f: !!b } : u : null);
function yt(u, m = null, b = null, S = 0, E = null, D = u === lr ? 0 : 1, T = !1, a = !1) {
  const U = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: u,
    props: m,
    key: m && R_(m),
    ref: m && Ph(m),
    scopeId: a_,
    slotScopeIds: null,
    children: b,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: D,
    patchFlag: S,
    dynamicProps: E,
    dynamicChildren: null,
    appContext: null,
    ctx: _r
  };
  return a ? (af(U, b), D & 128 && u.normalize(U)) : b && (U.shapeFlag |= tr(b) ? 8 : 16), nu > 0 && // avoid a block node from tracking itself
  !T && // has current parent block
  yn && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (U.patchFlag > 0 || D & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  U.patchFlag !== 32 && yn.push(U), U;
}
const ci = C0;
function C0(u, m = null, b = null, S = 0, E = null, D = !1) {
  if ((!u || u === Wx) && (u = To), of(u)) {
    const a = zl(
      u,
      m,
      !0
      /* mergeRef: true */
    );
    return b && af(a, b), nu > 0 && !D && yn && (a.shapeFlag & 6 ? yn[yn.indexOf(u)] = a : yn.push(a)), a.patchFlag = -2, a;
  }
  if (O0(u) && (u = u.__vccOpts), m) {
    m = I0(m);
    let { class: a, style: U } = m;
    a && !tr(a) && (m.class = us(a)), Mi(U) && (ef(U) && !Rt(U) && (U = Zr({}, U)), m.style = ma(U));
  }
  const T = tr(u) ? 1 : k_(u) ? 128 : Lx(u) ? 64 : Mi(u) ? 4 : Vt(u) ? 2 : 0;
  return yt(
    u,
    m,
    b,
    S,
    E,
    T,
    D,
    !0
  );
}
function I0(u) {
  return u ? ef(u) || v_(u) ? Zr({}, u) : u : null;
}
function zl(u, m, b = !1, S = !1) {
  const { props: E, ref: D, patchFlag: T, children: a, transition: U } = u, ue = m ? E0(E || {}, m) : E, ce = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: u.type,
    props: ue,
    key: ue && R_(ue),
    ref: m && m.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      b && D ? Rt(D) ? D.concat(Ph(m)) : [D, Ph(m)] : Ph(m)
    ) : D,
    scopeId: u.scopeId,
    slotScopeIds: u.slotScopeIds,
    children: a,
    target: u.target,
    targetStart: u.targetStart,
    targetAnchor: u.targetAnchor,
    staticCount: u.staticCount,
    shapeFlag: u.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: m && u.type !== lr ? T === -1 ? 16 : T | 16 : T,
    dynamicProps: u.dynamicProps,
    dynamicChildren: u.dynamicChildren,
    appContext: u.appContext,
    dirs: u.dirs,
    transition: U,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: u.component,
    suspense: u.suspense,
    ssContent: u.ssContent && zl(u.ssContent),
    ssFallback: u.ssFallback && zl(u.ssFallback),
    el: u.el,
    anchor: u.anchor,
    ctx: u.ctx,
    ce: u.ce
  };
  return U && S && nf(
    ce,
    U.clone(ce)
  ), ce;
}
function Lh(u = " ", m = 0) {
  return ci(Kh, null, u, m);
}
function Ei(u = "", m = !1) {
  return m ? (wt(), gr(To, null, u)) : ci(To, null, u);
}
function ss(u) {
  return u == null || typeof u == "boolean" ? ci(To) : Rt(u) ? ci(
    lr,
    null,
    // #3666, avoid reference pollution when reusing vnode
    u.slice()
  ) : of(u) ? xo(u) : ci(Kh, null, String(u));
}
function xo(u) {
  return u.el === null && u.patchFlag !== -1 || u.memo ? u : zl(u);
}
function af(u, m) {
  let b = 0;
  const { shapeFlag: S } = u;
  if (m == null)
    m = null;
  else if (Rt(m))
    b = 16;
  else if (typeof m == "object")
    if (S & 65) {
      const E = m.default;
      E && (E._c && (E._d = !1), af(u, E()), E._c && (E._d = !0));
      return;
    } else {
      b = 32;
      const E = m._;
      !E && !v_(m) ? m._ctx = _r : E === 3 && _r && (_r.slots._ === 1 ? m._ = 1 : (m._ = 2, u.patchFlag |= 1024));
    }
  else Vt(m) ? (m = { default: m, _ctx: _r }, b = 32) : (m = String(m), S & 64 ? (b = 16, m = [Lh(m)]) : b = 8);
  u.children = m, u.shapeFlag |= b;
}
function E0(...u) {
  const m = {};
  for (let b = 0; b < u.length; b++) {
    const S = u[b];
    for (const E in S)
      if (E === "class")
        m.class !== S.class && (m.class = us([m.class, S.class]));
      else if (E === "style")
        m.style = ma([m.style, S.style]);
      else if (Nh(E)) {
        const D = m[E], T = S[E];
        T && D !== T && !(Rt(D) && D.includes(T)) && (m[E] = D ? [].concat(D, T) : T);
      } else E !== "" && (m[E] = S[E]);
  }
  return m;
}
function rs(u, m, b, S = null) {
  cs(u, m, 7, [
    b,
    S
  ]);
}
const A0 = g_();
let k0 = 0;
function z0(u, m, b) {
  const S = u.type, E = (m ? m.appContext : u.appContext) || A0, D = {
    uid: k0++,
    vnode: u,
    type: S,
    parent: m,
    appContext: E,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Lg(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: m ? m.provides : Object.create(E.provides),
    ids: m ? m.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: b_(S, E),
    emitsOptions: A_(S, E),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: pi,
    // inheritAttrs
    inheritAttrs: S.inheritAttrs,
    // state
    ctx: pi,
    data: pi,
    props: pi,
    attrs: pi,
    slots: pi,
    refs: pi,
    setupState: pi,
    setupContext: null,
    // suspense related
    suspense: b,
    suspenseId: b ? b.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return D.ctx = { _: D }, D.root = m ? m.root : D, D.emit = x0.bind(null, D), u.ce && u.ce(D), D;
}
let Pr = null;
const R0 = () => Pr || _r;
let Fh, Op;
{
  const u = Zh(), m = (b, S) => {
    let E;
    return (E = u[b]) || (E = u[b] = []), E.push(S), (D) => {
      E.length > 1 ? E.forEach((T) => T(D)) : E[0](D);
    };
  };
  Fh = m(
    "__VUE_INSTANCE_SETTERS__",
    (b) => Pr = b
  ), Op = m(
    "__VUE_SSR_SETTERS__",
    (b) => su = b
  );
}
const au = (u) => {
  const m = Pr;
  return Fh(u), u.scope.on(), () => {
    u.scope.off(), Fh(m);
  };
}, rg = () => {
  Pr && Pr.scope.off(), Fh(null);
};
function D_(u) {
  return u.vnode.shapeFlag & 4;
}
let su = !1;
function D0(u, m = !1, b = !1) {
  m && Op(m);
  const { props: S, children: E } = u.vnode, D = D_(u);
  o0(u, S, D, m), u0(u, E, b);
  const T = D ? L0(u, m) : void 0;
  return m && Op(!1), T;
}
function L0(u, m) {
  const b = u.type;
  u.accessCache = /* @__PURE__ */ Object.create(null), u.proxy = new Proxy(u.ctx, Kx);
  const { setup: S } = b;
  if (S) {
    Po();
    const E = u.setupContext = S.length > 1 ? B0(u) : null, D = au(u), T = ou(
      S,
      u,
      0,
      [
        u.props,
        E
      ]
    ), a = Cg(T);
    if (Mo(), D(), (a || u.sp) && !Al(u) && l_(u), a) {
      if (T.then(rg, rg), m)
        return T.then((U) => {
          ng(u, U);
        }).catch((U) => {
          Hh(U, u, 0);
        });
      u.asyncDep = T;
    } else
      ng(u, T);
  } else
    L_(u);
}
function ng(u, m, b) {
  Vt(m) ? u.type.__ssrInlineRender ? u.ssrRender = m : u.render = m : Mi(m) && (u.setupState = e_(m)), L_(u);
}
function L_(u, m, b) {
  const S = u.type;
  u.render || (u.render = S.render || os);
  {
    const E = au(u);
    Po();
    try {
      Yx(u);
    } finally {
      Mo(), E();
    }
  }
}
const F0 = {
  get(u, m) {
    return zr(u, "get", ""), u[m];
  }
};
function B0(u) {
  const m = (b) => {
    u.exposed = b || {};
  };
  return {
    attrs: new Proxy(u.attrs, F0),
    slots: u.slots,
    emit: u.emit,
    expose: m
  };
}
function Yh(u) {
  return u.exposed ? u.exposeProxy || (u.exposeProxy = new Proxy(e_(tf(u.exposed)), {
    get(m, b) {
      if (b in m)
        return m[b];
      if (b in Yc)
        return Yc[b](u);
    },
    has(m, b) {
      return b in m || b in Yc;
    }
  })) : u.proxy;
}
function O0(u) {
  return Vt(u) && "__vccOpts" in u;
}
const cr = (u, m) => Ix(u, m, su), j0 = "3.5.13";
/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let jp;
const sg = typeof window < "u" && window.trustedTypes;
if (sg)
  try {
    jp = /* @__PURE__ */ sg.createPolicy("vue", {
      createHTML: (u) => u
    });
  } catch {
  }
const F_ = jp ? (u) => jp.createHTML(u) : (u) => u, V0 = "http://www.w3.org/2000/svg", N0 = "http://www.w3.org/1998/Math/MathML", Ls = typeof document < "u" ? document : null, og = Ls && /* @__PURE__ */ Ls.createElement("template"), $0 = {
  insert: (u, m, b) => {
    m.insertBefore(u, b || null);
  },
  remove: (u) => {
    const m = u.parentNode;
    m && m.removeChild(u);
  },
  createElement: (u, m, b, S) => {
    const E = m === "svg" ? Ls.createElementNS(V0, u) : m === "mathml" ? Ls.createElementNS(N0, u) : b ? Ls.createElement(u, { is: b }) : Ls.createElement(u);
    return u === "select" && S && S.multiple != null && E.setAttribute("multiple", S.multiple), E;
  },
  createText: (u) => Ls.createTextNode(u),
  createComment: (u) => Ls.createComment(u),
  setText: (u, m) => {
    u.nodeValue = m;
  },
  setElementText: (u, m) => {
    u.textContent = m;
  },
  parentNode: (u) => u.parentNode,
  nextSibling: (u) => u.nextSibling,
  querySelector: (u) => Ls.querySelector(u),
  setScopeId(u, m) {
    u.setAttribute(m, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(u, m, b, S, E, D) {
    const T = b ? b.previousSibling : m.lastChild;
    if (E && (E === D || E.nextSibling))
      for (; m.insertBefore(E.cloneNode(!0), b), !(E === D || !(E = E.nextSibling)); )
        ;
    else {
      og.innerHTML = F_(
        S === "svg" ? `<svg>${u}</svg>` : S === "mathml" ? `<math>${u}</math>` : u
      );
      const a = og.content;
      if (S === "svg" || S === "mathml") {
        const U = a.firstChild;
        for (; U.firstChild; )
          a.appendChild(U.firstChild);
        a.removeChild(U);
      }
      m.insertBefore(a, b);
    }
    return [
      // first
      T ? T.nextSibling : m.firstChild,
      // last
      b ? b.previousSibling : m.lastChild
    ];
  }
}, U0 = Symbol("_vtc");
function Z0(u, m, b) {
  const S = u[U0];
  S && (m = (m ? [m, ...S] : [...S]).join(" ")), m == null ? u.removeAttribute("class") : b ? u.setAttribute("class", m) : u.className = m;
}
const Bh = Symbol("_vod"), B_ = Symbol("_vsh"), Mh = {
  beforeMount(u, { value: m }, { transition: b }) {
    u[Bh] = u.style.display === "none" ? "" : u.style.display, b && m ? b.beforeEnter(u) : Gc(u, m);
  },
  mounted(u, { value: m }, { transition: b }) {
    b && m && b.enter(u);
  },
  updated(u, { value: m, oldValue: b }, { transition: S }) {
    !m != !b && (S ? m ? (S.beforeEnter(u), Gc(u, !0), S.enter(u)) : S.leave(u, () => {
      Gc(u, !1);
    }) : Gc(u, m));
  },
  beforeUnmount(u, { value: m }) {
    Gc(u, m);
  }
};
function Gc(u, m) {
  u.style.display = m ? u[Bh] : "none", u[B_] = !m;
}
const G0 = Symbol(""), q0 = /(^|;)\s*display\s*:/;
function H0(u, m, b) {
  const S = u.style, E = tr(b);
  let D = !1;
  if (b && !E) {
    if (m)
      if (tr(m))
        for (const T of m.split(";")) {
          const a = T.slice(0, T.indexOf(":")).trim();
          b[a] == null && Ch(S, a, "");
        }
      else
        for (const T in m)
          b[T] == null && Ch(S, T, "");
    for (const T in b)
      T === "display" && (D = !0), Ch(S, T, b[T]);
  } else if (E) {
    if (m !== b) {
      const T = S[G0];
      T && (b += ";" + T), S.cssText = b, D = q0.test(b);
    }
  } else m && u.removeAttribute("style");
  Bh in u && (u[Bh] = D ? S.display : "", u[B_] && (S.display = "none"));
}
const ag = /\s*!important$/;
function Ch(u, m, b) {
  if (Rt(b))
    b.forEach((S) => Ch(u, m, S));
  else if (b == null && (b = ""), m.startsWith("--"))
    u.setProperty(m, b);
  else {
    const S = W0(u, m);
    ag.test(b) ? u.setProperty(
      ya(S),
      b.replace(ag, ""),
      "important"
    ) : u[S] = b;
  }
}
const lg = ["Webkit", "Moz", "ms"], Sp = {};
function W0(u, m) {
  const b = Sp[m];
  if (b)
    return b;
  let S = wo(m);
  if (S !== "filter" && S in u)
    return Sp[m] = S;
  S = Ag(S);
  for (let E = 0; E < lg.length; E++) {
    const D = lg[E] + S;
    if (D in u)
      return Sp[m] = D;
  }
  return m;
}
const cg = "http://www.w3.org/1999/xlink";
function ug(u, m, b, S, E, D = Qv(m)) {
  S && m.startsWith("xlink:") ? b == null ? u.removeAttributeNS(cg, m.slice(6, m.length)) : u.setAttributeNS(cg, m, b) : b == null || D && !zg(b) ? u.removeAttribute(m) : u.setAttribute(
    m,
    D ? "" : Vs(b) ? String(b) : b
  );
}
function hg(u, m, b, S, E) {
  if (m === "innerHTML" || m === "textContent") {
    b != null && (u[m] = m === "innerHTML" ? F_(b) : b);
    return;
  }
  const D = u.tagName;
  if (m === "value" && D !== "PROGRESS" && // custom elements may use _value internally
  !D.includes("-")) {
    const a = D === "OPTION" ? u.getAttribute("value") || "" : u.value, U = b == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      u.type === "checkbox" ? "on" : ""
    ) : String(b);
    (a !== U || !("_value" in u)) && (u.value = U), b == null && u.removeAttribute(m), u._value = b;
    return;
  }
  let T = !1;
  if (b === "" || b == null) {
    const a = typeof u[m];
    a === "boolean" ? b = zg(b) : b == null && a === "string" ? (b = "", T = !0) : a === "number" && (b = 0, T = !0);
  }
  try {
    u[m] = b;
  } catch {
  }
  T && u.removeAttribute(E || m);
}
function Sl(u, m, b, S) {
  u.addEventListener(m, b, S);
}
function X0(u, m, b, S) {
  u.removeEventListener(m, b, S);
}
const dg = Symbol("_vei");
function K0(u, m, b, S, E = null) {
  const D = u[dg] || (u[dg] = {}), T = D[m];
  if (S && T)
    T.value = S;
  else {
    const [a, U] = Y0(m);
    if (S) {
      const ue = D[m] = eb(
        S,
        E
      );
      Sl(u, a, ue, U);
    } else T && (X0(u, a, T, U), D[m] = void 0);
  }
}
const pg = /(?:Once|Passive|Capture)$/;
function Y0(u) {
  let m;
  if (pg.test(u)) {
    m = {};
    let S;
    for (; S = u.match(pg); )
      u = u.slice(0, u.length - S[0].length), m[S[0].toLowerCase()] = !0;
  }
  return [u[2] === ":" ? u.slice(3) : ya(u.slice(2)), m];
}
let Pp = 0;
const J0 = /* @__PURE__ */ Promise.resolve(), Q0 = () => Pp || (J0.then(() => Pp = 0), Pp = Date.now());
function eb(u, m) {
  const b = (S) => {
    if (!S._vts)
      S._vts = Date.now();
    else if (S._vts <= b.attached)
      return;
    cs(
      tb(S, b.value),
      m,
      5,
      [S]
    );
  };
  return b.value = u, b.attached = Q0(), b;
}
function tb(u, m) {
  if (Rt(m)) {
    const b = u.stopImmediatePropagation;
    return u.stopImmediatePropagation = () => {
      b.call(u), u._stopped = !0;
    }, m.map(
      (S) => (E) => !E._stopped && S && S(E)
    );
  } else
    return m;
}
const fg = (u) => u.charCodeAt(0) === 111 && u.charCodeAt(1) === 110 && // lowercase letter
u.charCodeAt(2) > 96 && u.charCodeAt(2) < 123, ib = (u, m, b, S, E, D) => {
  const T = E === "svg";
  m === "class" ? Z0(u, S, T) : m === "style" ? H0(u, b, S) : Nh(m) ? Gp(m) || K0(u, m, b, S, D) : (m[0] === "." ? (m = m.slice(1), !0) : m[0] === "^" ? (m = m.slice(1), !1) : rb(u, m, S, T)) ? (hg(u, m, S), !u.tagName.includes("-") && (m === "value" || m === "checked" || m === "selected") && ug(u, m, S, T, D, m !== "value")) : /* #11081 force set props for possible async custom element */ u._isVueCE && (/[A-Z]/.test(m) || !tr(S)) ? hg(u, wo(m), S, D, m) : (m === "true-value" ? u._trueValue = S : m === "false-value" && (u._falseValue = S), ug(u, m, S, T));
};
function rb(u, m, b, S) {
  if (S)
    return !!(m === "innerHTML" || m === "textContent" || m in u && fg(m) && Vt(b));
  if (m === "spellcheck" || m === "draggable" || m === "translate" || m === "form" || m === "list" && u.tagName === "INPUT" || m === "type" && u.tagName === "TEXTAREA")
    return !1;
  if (m === "width" || m === "height") {
    const E = u.tagName;
    if (E === "IMG" || E === "VIDEO" || E === "CANVAS" || E === "SOURCE")
      return !1;
  }
  return fg(m) && tr(b) ? !1 : m in u;
}
const mg = (u) => {
  const m = u.props["onUpdate:modelValue"] || !1;
  return Rt(m) ? (b) => Th(m, b) : m;
};
function nb(u) {
  u.target.composing = !0;
}
function gg(u) {
  const m = u.target;
  m.composing && (m.composing = !1, m.dispatchEvent(new Event("input")));
}
const Mp = Symbol("_assign"), sb = {
  created(u, { modifiers: { lazy: m, trim: b, number: S } }, E) {
    u[Mp] = mg(E);
    const D = S || E.props && E.props.type === "number";
    Sl(u, m ? "change" : "input", (T) => {
      if (T.target.composing) return;
      let a = u.value;
      b && (a = a.trim()), D && (a = Ep(a)), u[Mp](a);
    }), b && Sl(u, "change", () => {
      u.value = u.value.trim();
    }), m || (Sl(u, "compositionstart", nb), Sl(u, "compositionend", gg), Sl(u, "change", gg));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(u, { value: m }) {
    u.value = m ?? "";
  },
  beforeUpdate(u, { value: m, oldValue: b, modifiers: { lazy: S, trim: E, number: D } }, T) {
    if (u[Mp] = mg(T), u.composing) return;
    const a = (D || u.type === "number") && !/^0\d/.test(u.value) ? Ep(u.value) : u.value, U = m ?? "";
    a !== U && (document.activeElement === u && u.type !== "range" && (S && m === b || E && u.value.trim() === U) || (u.value = U));
  }
}, ob = ["ctrl", "shift", "alt", "meta"], ab = {
  stop: (u) => u.stopPropagation(),
  prevent: (u) => u.preventDefault(),
  self: (u) => u.target !== u.currentTarget,
  ctrl: (u) => !u.ctrlKey,
  shift: (u) => !u.shiftKey,
  alt: (u) => !u.altKey,
  meta: (u) => !u.metaKey,
  left: (u) => "button" in u && u.button !== 0,
  middle: (u) => "button" in u && u.button !== 1,
  right: (u) => "button" in u && u.button !== 2,
  exact: (u, m) => ob.some((b) => u[`${b}Key`] && !m.includes(b))
}, Oh = (u, m) => {
  const b = u._withMods || (u._withMods = {}), S = m.join(".");
  return b[S] || (b[S] = (E, ...D) => {
    for (let T = 0; T < m.length; T++) {
      const a = ab[m[T]];
      if (a && a(E, m)) return;
    }
    return u(E, ...D);
  });
}, lb = /* @__PURE__ */ Zr({ patchProp: ib }, $0);
let _g;
function cb() {
  return _g || (_g = d0(lb));
}
const ub = (...u) => {
  const m = cb().createApp(...u), { mount: b } = m;
  return m.mount = (S) => {
    const E = db(S);
    if (!E) return;
    const D = m._component;
    !Vt(D) && !D.render && !D.template && (D.template = E.innerHTML), E.nodeType === 1 && (E.textContent = "");
    const T = b(E, !1, hb(E));
    return E instanceof Element && (E.removeAttribute("v-cloak"), E.setAttribute("data-v-app", "")), T;
  }, m;
};
function hb(u) {
  if (u instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && u instanceof MathMLElement)
    return "mathml";
}
function db(u) {
  return tr(u) ? document.querySelector(u) : u;
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let O_;
const Jh = (u) => O_ = u, j_ = (
  /* istanbul ignore next */
  Symbol()
);
function Vp(u) {
  return u && typeof u == "object" && Object.prototype.toString.call(u) === "[object Object]" && typeof u.toJSON != "function";
}
var eu;
(function(u) {
  u.direct = "direct", u.patchObject = "patch object", u.patchFunction = "patch function";
})(eu || (eu = {}));
function pb() {
  const u = Fg(!0), m = u.run(() => ls({}));
  let b = [], S = [];
  const E = tf({
    install(D) {
      Jh(E), E._a = D, D.provide(j_, E), D.config.globalProperties.$pinia = E, S.forEach((T) => b.push(T)), S = [];
    },
    use(D) {
      return this._a ? b.push(D) : S.push(D), this;
    },
    _p: b,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: u,
    _s: /* @__PURE__ */ new Map(),
    state: m
  });
  return E;
}
const V_ = () => {
};
function yg(u, m, b, S = V_) {
  u.push(m);
  const E = () => {
    const D = u.indexOf(m);
    D > -1 && (u.splice(D, 1), S());
  };
  return !b && Bg() && ex(E), E;
}
function bl(u, ...m) {
  u.slice().forEach((b) => {
    b(...m);
  });
}
const fb = (u) => u(), vg = Symbol(), Cp = Symbol();
function Np(u, m) {
  u instanceof Map && m instanceof Map ? m.forEach((b, S) => u.set(S, b)) : u instanceof Set && m instanceof Set && m.forEach(u.add, u);
  for (const b in m) {
    if (!m.hasOwnProperty(b))
      continue;
    const S = m[b], E = u[b];
    Vp(E) && Vp(S) && u.hasOwnProperty(b) && !Ai(S) && !Os(S) ? u[b] = Np(E, S) : u[b] = S;
  }
  return u;
}
const mb = (
  /* istanbul ignore next */
  Symbol()
);
function gb(u) {
  return !Vp(u) || !u.hasOwnProperty(mb);
}
const { assign: yo } = Object;
function _b(u) {
  return !!(Ai(u) && u.effect);
}
function yb(u, m, b, S) {
  const { state: E, actions: D, getters: T } = m, a = b.state.value[u];
  let U;
  function ue() {
    a || (b.state.value[u] = E ? E() : {});
    const ce = Tx(b.state.value[u]);
    return yo(ce, D, Object.keys(T || {}).reduce((ve, we) => (ve[we] = tf(cr(() => {
      Jh(b);
      const Q = b._s.get(u);
      return T[we].call(Q, Q);
    })), ve), {}));
  }
  return U = N_(u, ue, m, b, S, !0), U;
}
function N_(u, m, b = {}, S, E, D) {
  let T;
  const a = yo({ actions: {} }, b), U = { deep: !0 };
  let ue, ce, ve = [], we = [], Q;
  const Je = S.state.value[u];
  !D && !Je && (S.state.value[u] = {}), ls({});
  let it;
  function vt(at) {
    let _t;
    ue = ce = !1, typeof at == "function" ? (at(S.state.value[u]), _t = {
      type: eu.patchFunction,
      storeId: u,
      events: Q
    }) : (Np(S.state.value[u], at), _t = {
      type: eu.patchObject,
      payload: at,
      storeId: u,
      events: Q
    });
    const Et = it = Symbol();
    r_().then(() => {
      it === Et && (ue = !0);
    }), ce = !0, bl(ve, _t, S.state.value[u]);
  }
  const Ze = D ? function() {
    const { state: _t } = b, Et = _t ? _t() : {};
    this.$patch((Ut) => {
      yo(Ut, Et);
    });
  } : (
    /* istanbul ignore next */
    V_
  );
  function Ke() {
    T.stop(), ve = [], we = [], S._s.delete(u);
  }
  const ut = (at, _t = "") => {
    if (vg in at)
      return at[Cp] = _t, at;
    const Et = function() {
      Jh(S);
      const Ut = Array.from(arguments), fi = [], ir = [];
      function Jr(At) {
        fi.push(At);
      }
      function Gr(At) {
        ir.push(At);
      }
      bl(we, {
        args: Ut,
        name: Et[Cp],
        store: It,
        after: Jr,
        onError: Gr
      });
      let ti;
      try {
        ti = at.apply(this && this.$id === u ? this : It, Ut);
      } catch (At) {
        throw bl(ir, At), At;
      }
      return ti instanceof Promise ? ti.then((At) => (bl(fi, At), At)).catch((At) => (bl(ir, At), Promise.reject(At))) : (bl(fi, ti), ti);
    };
    return Et[vg] = !0, Et[Cp] = _t, Et;
  }, Qe = {
    _p: S,
    // _s: scope,
    $id: u,
    $onAction: yg.bind(null, we),
    $patch: vt,
    $reset: Ze,
    $subscribe(at, _t = {}) {
      const Et = yg(ve, at, _t.detached, () => Ut()), Ut = T.run(() => Sh(() => S.state.value[u], (fi) => {
        (_t.flush === "sync" ? ce : ue) && at({
          storeId: u,
          type: eu.direct,
          events: Q
        }, fi);
      }, yo({}, U, _t)));
      return Et;
    },
    $dispose: Ke
  }, It = qh(Qe);
  S._s.set(u, It);
  const pt = (S._a && S._a.runWithContext || fb)(() => S._e.run(() => (T = Fg()).run(() => m({ action: ut }))));
  for (const at in pt) {
    const _t = pt[at];
    if (Ai(_t) && !_b(_t) || Os(_t))
      D || (Je && gb(_t) && (Ai(_t) ? _t.value = Je[at] : Np(_t, Je[at])), S.state.value[u][at] = _t);
    else if (typeof _t == "function") {
      const Et = ut(_t, at);
      pt[at] = Et, a.actions[at] = _t;
    }
  }
  return yo(It, pt), yo(Qt(It), pt), Object.defineProperty(It, "$state", {
    get: () => S.state.value[u],
    set: (at) => {
      vt((_t) => {
        yo(_t, at);
      });
    }
  }), S._p.forEach((at) => {
    yo(It, T.run(() => at({
      store: It,
      app: S._a,
      pinia: S,
      options: a
    })));
  }), Je && D && b.hydrate && b.hydrate(It.$state, Je), ue = !0, ce = !0, It;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function vb(u, m, b) {
  let S, E;
  const D = typeof m == "function";
  S = u, E = D ? b : m;
  function T(a, U) {
    const ue = s0();
    return a = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    a || (ue ? Jc(j_, null) : null), a && Jh(a), a = O_, a._s.has(S) || (D ? N_(S, m, E, a) : yb(S, E, a)), a._s.get(S);
  }
  return T.$id = S, T;
}
function Vn(u) {
  {
    const m = Qt(u), b = {};
    for (const S in m) {
      const E = m[S];
      E.effect ? b[S] = // ...
      cr({
        get: () => u[S],
        set(D) {
          u[S] = D;
        }
      }) : (Ai(E) || Os(E)) && (b[S] = // ---
      Mx(u, S));
    }
    return b;
  }
}
const xb = {
  center: [-1.8261632, 51.1788144],
  // Default to Stonehenge
  zoom: 14,
  maxZoom: 18,
  style: "https://tiles.openfreemap.org/styles/bright",
  attributionControl: !1
}, bb = {
  padding: { top: 50, bottom: 50, left: 50, right: 50 },
  duration: 0
}, _a = {
  padding: { top: 50, bottom: 50, left: 50, right: 50 },
  duration: 500
}, wb = {
  duration: 500
}, bh = {
  duration: 500
}, $_ = ["marker", "line", "shape"];
function U_(u = {}) {
  if (!u || !u.geometry)
    return null;
  switch (u.geometry.type) {
    case "Point":
      return "marker";
    case "LineString":
    case "MultiLineString":
      return "line";
    case "Polygon":
    case "MultiPolygon":
      return "shape";
    default:
      return "shape";
  }
}
function Tb(u) {
  const m = {
    thumbnail: null,
    medium: null,
    large: null
  };
  return u.properties.image_thumbnail_url ? m.thumbnail = u.properties.image_thumbnail_url : u.properties.image_medium_url ? m.thumbnail = u.properties.image_medium_url : u.properties.image_large_url && (m.thumbnail = u.properties.image_large_url), u.properties.image_medium_url ? m.medium = u.properties.image_medium_url : u.properties.image_large_url && (m.medium = u.properties.image_large_url), u.properties.image_large_url && (m.large = u.properties.image_large_url), m;
}
function Sb(u = {}) {
  if (!(u instanceof ua))
    return null;
  var m = {
    className: "waymark-marker waymark-marker-" + u.typeKey
  };
  if (typeof u.data.marker_shape < "u" && typeof u.data.marker_size < "u") {
    switch (m.className += " waymark-marker-" + u.data.marker_shape, m.className += " waymark-marker-" + u.data.marker_size, u.data.marker_shape) {
      //Markers & Circles
      case "rectangle":
      case "circle":
      case "marker":
        switch (u.data.marker_size) {
          case "small":
            m.iconSize = [16, 16];
            break;
          case "medium":
            m.iconSize = [20, 20];
            break;
          default:
          case "large":
            m.iconSize = [24, 24];
            break;
        }
        break;
    }
    u.data.marker_shape == "marker" && (m.iconAnchor = [0, -Math.ceil(m.iconSize[1] / 1.5)]);
  }
  var b = "background:" + u.data.marker_colour + ";", S = "color:" + u.data.icon_colour + ";";
  m.html = '<div class="waymark-marker-background" style="' + b + '"></div>';
  var E = "waymark-marker-icon";
  switch (u.data.icon_type) {
    //Text
    case "text":
      E += " waymark-icon-text", m.html += '<div style="' + S + '" class="' + E + '">' + u.data.marker_icon + "</div>";
      break;
    //HTML
    case "html":
      E += " waymark-icon-html";
      var D = "<div>" + u.data.marker_icon + "</div>";
      m.html += '<div class="' + E + '">' + D + "</div>";
      break;
    //SVG
    case "svg":
      E += " waymark-icon-svg", m.html += '<div style="' + S + '" class="' + E + '">' + u.data.marker_icon + "</div>";
      break;
    //Icon Name
    case "icon":
    default:
      E += " waymark-icon-icon", u.data.marker_icon.indexOf("ion-") === 0 ? (E += " ion ", E += " " + u.data.marker_icon) : u.data.marker_icon.indexOf("fa-") === 0 ? (E += " fa", E += " " + u.data.marker_icon) : (E += " ion", E += " ion-" + u.data.marker_icon), m.html += '<i style="' + S + '" class="' + E + '"></i>';
      break;
  }
  return m;
}
const lf = "#b42714", xg = "#000000", bg = "#000000", wg = "#000000";
function Qh(u) {
  return u && (u = u.replace(/[^a-z0-9+]+/gi, ""), u = u.toLowerCase(), u);
}
function Z_(u) {
  return u ? "fa-eye" : "fa-eye-slash";
}
function Pb(u) {
  return u ? "fa-chevron-up" : "fa-chevron-down";
}
function jh(u) {
  let m = "";
  switch (u) {
    case "fontawesome":
      m = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css";
      break;
    case "ionicons":
      m = "https://cdnjs.cloudflare.com/ajax/libs/ionicons/2.0.1/css/ionicons.min.css";
      break;
    default:
      return;
  }
  if (document.querySelector(`link[href="${m}"]`))
    return;
  const b = document.createElement("link");
  b.rel = "stylesheet", b.href = m, b.crossOrigin = "anonymous", document.head.appendChild(b);
}
class ed {
  constructor(m) {
    this.data = m || {};
  }
}
class ua extends ed {
  // Set defaults
  constructor(m) {
    const b = {
      marker_title: "Marker",
      marker_shape: "marker",
      marker_size: "large",
      icon_type: "svg",
      marker_icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" style="fill: currentColor;"><path d="M215.7 499.2C267 435 384 279.4 384 192C384 86 298 0 192 0S0 86 0 192c0 87.4 117 243 168.3 307.2c12.3 15.3 35.1 15.3 47.4 0zM192 128a64 64 0 1 1 0 128 64 64 0 1 1 0-128z"/></svg>',
      marker_colour: xg,
      icon_colour: "#ffffff",
      marker_display: "1"
    };
    super({ ...b, ...m }), this.typeKey = Qh(this.data.marker_title) || null, this.iconData = Sb(this), this.data.marker_icon && (this.data.marker_icon.startsWith("fa-") ? jh("fontawesome") : this.data.marker_icon.startsWith("ion-") && jh("ionicons"));
  }
  getTitle() {
    return this.data.marker_title || "Marker";
  }
  getPrimaryColour() {
    return this.data.marker_colour || xg;
  }
  getIconColour() {
    return this.data.icon_colour || "#ffffff";
  }
}
class Pl extends ed {
  constructor(m) {
    const b = {
      line_title: "Line",
      line_colour: bg,
      line_weight: "3",
      line_opacity: "1",
      line_display: "1"
    };
    super({ ...b, ...m }), this.typeKey = Qh(this.data.line_title) || null;
  }
  getTitle() {
    return this.data.line_title || "Line";
  }
  getPrimaryColour() {
    return this.data.line_colour || bg;
  }
  getLineWeight() {
    return parseInt(this.data.line_weight) || 1;
  }
  getLineOpacity() {
    return parseFloat(this.data.line_opacity) || 1;
  }
  getLineStyle() {
    return {
      color: this.getPrimaryColour(),
      weight: this.getLineWeight(),
      opacity: this.getLineOpacity()
    };
  }
}
class Ml extends ed {
  constructor(m) {
    const b = {
      shape_title: "Shape",
      shape_colour: wg,
      fill_opacity: "0.5",
      shape_display: "1"
    };
    super({ ...b, ...m }), this.typeKey = Qh(this.data.shape_title) || null;
  }
  getTitle() {
    return this.data.shape_title || "Shape";
  }
  getPrimaryColour() {
    return this.data.shape_colour || wg;
  }
  getFillOpacity() {
    return parseFloat(this.data.fill_opacity) || 0.5;
  }
  getShapeStyle() {
    return {
      color: this.getPrimaryColour(),
      fillColor: this.getPrimaryColour(),
      fillOpacity: this.getFillOpacity()
    };
  }
}
class Mb {
  // Set defaults
  constructor(m) {
    const b = {
      layer_name: "Open Street Map",
      layer_url: "http://tile.openstreetmap.org/{z}/{x}/{y}.png",
      layer_attribution: ' <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      layer_max_zoom: "18",
      layer_visible: !0,
      layer_opacity: 1
    };
    this.data = { ...b, ...m }, this.id = "tile-layer-" + Qh(this.data.layer_name);
  }
  addTo(m, b = !1) {
    !m || !m.addLayer || (this.map = m, this.map.addSource(this.id, this.toSource()), this.source = this.map.getSource(this.id), this.map.addLayer(this.toStyle()), this.layer = this.map.getLayer(this.id));
  }
  toSource() {
    return {
      type: "raster",
      tiles: [this.data.layer_url],
      tileSize: 256,
      maxzoom: parseInt(this.data.layer_max_zoom) || 18
    };
  }
  toStyle() {
    const m = parseFloat(this.data.layer_opacity);
    return {
      id: this.id,
      type: "raster",
      source: this.id,
      attribution: this.data.layer_attribution || "",
      layout: {
        visibility: this.isVisible() ? "visible" : "none"
      },
      paint: {
        "raster-opacity": isNaN(m) ? 1 : m
      }
    };
  }
  getTitle() {
    return this.data.layer_name || "Tile Layer";
  }
  isVisible() {
    return this.data.layer_visible === !0 || this.data.layer_visible === "true" || this.data.layer_visible === "1" || this.data.layer_visible === 1;
  }
  /* tileLayer.previewCoords(map.getCenter().lat, map.getCenter().lng) */
  previewCoords(m, b, S = 12) {
    if (!m || !b)
      return this.data.layer_url;
    const E = Math.floor((b + 180) / 360 * Math.pow(2, S)), D = Math.floor(
      (1 - Math.log(
        Math.tan(m * Math.PI / 180) + 1 / Math.cos(m * Math.PI / 180)
      ) / Math.PI) / 2 * Math.pow(2, S)
    );
    return this.data.layer_url.replace("{z}", S).replace("{x}", E).replace("{y}", D);
  }
  toggleVisibility() {
    if (!this.map || !this.layer)
      return;
    const m = this.isVisible() ? "none" : "visible";
    this.map.setLayoutProperty(this.id, "visibility", m), this.data.layer_visible = !this.isVisible();
  }
  setOpacity(m) {
    !this.map || !this.layer || (m = parseFloat(m), !(isNaN(m) || m < 0 || m > 1) && (this.map.setPaintProperty(this.id, "raster-opacity", m), this.data.layer_opacity = m));
  }
}
const wl = {
  map_options: {
    div_id: "waymark-instance",
    tile_layers: [],
    marker_types: [new ua()],
    line_types: [new Pl()],
    shape_types: [new Ml()],
    maplibre_options: {},
    debug_mode: 0
  },
  viewer_options: {
    show_sidebar: 1,
    show_controls: 1,
    show_zoom_control: 1,
    show_location_control: 1
  },
  editor_options: {
    confirm_delete: 1,
    data_div_id: "waymark-data"
  }
};
class G_ {
  constructor(m = {}) {
    this.map_options = {
      ...wl.map_options,
      maplibre_options: { ...wl.map_options.maplibre_options }
    }, this.viewer_options = { ...wl.viewer_options }, this.editor_options = { ...wl.editor_options }, this.mergeConfig(m), this.tileLayers = [], this.importTileLayers(), this.lineTypes = {}, this.shapeTypes = {}, this.markerTypes = {}, this.importTypes();
  }
  mergeConfig(m) {
    Object.keys(wl).forEach((b) => {
      m[b] && this.mergeOptions(
        this[b],
        m[b],
        wl[b]
      );
    });
  }
  mergeOptions(m, b, S) {
    Object.keys(b).forEach((E) => {
      Object.prototype.hasOwnProperty.call(S, E) ? m[E] = E === "maplibre_options" ? { ...m[E], ...b[E] } : b[E] : console.warn(`Unknown config option: ${E}`);
    });
  }
  getMapLibreOptions() {
    return {
      ...xb,
      ...this.map_options.maplibre_options || {}
    };
  }
  importTileLayers() {
    this.map_options.hasOwnProperty("tile_layers") && Array.isArray(this.map_options.tile_layers) && this.map_options.tile_layers.forEach((m) => {
      this.tileLayers.push(new Mb(m));
    });
  }
  getTileLayers() {
    return this.tileLayers;
  }
  // Accept Types from config
  importTypes() {
    $_.forEach((m) => {
      const b = m + "_types";
      this.map_options.hasOwnProperty(b) && Array.isArray(this.map_options[b]) && this.map_options[b].forEach((S) => {
        switch (m) {
          case "marker":
            var E = S instanceof ua ? new ua(S.data) : new ua(S), D = E.typeKey;
            this.markerTypes.hasOwnProperty(D) || (this.markerTypes[D] = E), E.data.marker_icon && (E.data.marker_icon.startsWith("fa-") ? jh("fontawesome") : E.data.marker_icon.startsWith("ion-") && jh("ionicons"));
            break;
          case "line":
            var E = S instanceof Pl ? new Pl(S.data) : new Pl(S), D = E.typeKey;
            this.lineTypes.hasOwnProperty(D) || (this.lineTypes[D] = E);
            break;
          case "shape":
            var E = S instanceof Ml ? new Ml(S.data) : new Ml(S), D = E.typeKey;
            this.shapeTypes.hasOwnProperty(D) || (this.shapeTypes[D] = E);
            break;
        }
      });
    });
  }
  getInitialView() {
    return this.map_options.maplibre_options.hasOwnProperty("center") && this.map_options.maplibre_options.hasOwnProperty("zoom") ? {
      center: this.map_options.maplibre_options.center,
      zoom: this.map_options.maplibre_options.zoom
    } : null;
  }
  /**
   * Get a Type by featureType and typeKey
   * Returns a default in all cases except where featureType is invalid
   */
  getType(m, b) {
    if (!m) return null;
    switch (m) {
      case "marker":
        return this.markerTypes[b] || new ua();
      case "line":
        return this.lineTypes[b] || new Pl();
      case "shape":
        return this.shapeTypes[b] || new Ml();
      default:
        return null;
    }
  }
  // getType(featureType, typeKey) {
  //   if (!featureType) return null;
  //   switch (featureType) {
  //     case "marker":
  //       return (
  //         this.markerTypes["marker_types"].find(
  //           (type) => type.typeKey === typeKey,
  //         ) || new MarkerType()
  //       );
  //     case "line":
  //       return (
  //         this.lineTypes["line_types"].find(
  //           (type) => type.typeKey === typeKey,
  //         ) || new LineType()
  //       );
  //     case "shape":
  //       return (
  //         this.shapeTypes["shape_types"].find(
  //           (type) => type.typeKey === typeKey,
  //         ) || new ShapeType()
  //       );
  //     default:
  //       return null;
  //   }
  // }
  /**
   * Generic helper to get an option from a specific config object
   * @param {Object} configObject - The config object to search (e.g., this.map_options)
   * @param {Array} keys - The keys to traverse
   * @returns {any|null} The option value or null if not found
   */
  getOption(m, b) {
    if (b.length === 0) return null;
    let S = m;
    for (const E of b)
      if (S && S.hasOwnProperty(E))
        S = S[E];
      else
        return null;
    return JSON.parse(JSON.stringify(S));
  }
  /**
   * Get specific map option
   * Accepts any number of Strings as arguments to traverse nested options
   *
   * @param {...string} keys - The option keys to traverse
   * @returns {any|null} The option value or null if not found
   */
  getMapOption(...m) {
    return this.getOption(this.map_options, m);
  }
  /**
   * Get specific viewer option
   * Accepts any number of Strings as arguments to traverse nested options
   *
   * @param {...string} keys - The option keys to traverse
   * @returns {any|null} The option value or null if not found
   */
  getViewerOption(...m) {
    return this.getOption(this.viewer_options, m);
  }
  /**
   * Get specific editor option
   * Accepts any number of Strings as arguments to traverse nested options
   *
   * @param {...string} keys - The option keys to traverse
   * @returns {any|null} The option value or null if not found
   */
  getEditorOption(...m) {
    return this.getOption(this.editor_options, m);
  }
  toJSON() {
    const m = /* @__PURE__ */ new WeakSet(), b = (S) => {
      if (typeof S != "object" || S === null) return S;
      if (m.has(S)) return "[Circular]";
      if (m.add(S), Array.isArray(S))
        return S.map(b);
      const E = {};
      for (const D of Object.keys(S))
        E[D] = b(S[D]);
      return E;
    };
    return {
      map_options: b(this.map_options),
      viewer_options: b(this.viewer_options),
      editor_options: b(this.editor_options)
    };
  }
}
const Tg = On(null);
function js() {
  return {
    config: Tg,
    init: (m = {}) => {
      Tg.value = new G_(m);
    }
  };
}
function Cb(u) {
  return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
var Ih = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.7.1/LICENSE.txt
 */
var Ib = Ih.exports, Sg;
function Eb() {
  return Sg || (Sg = 1, function(u, m) {
    (function(b, S) {
      u.exports = S();
    })(Ib, function() {
      var b = {}, S = {};
      function E(T, a, U) {
        if (S[T] = U, T === "index") {
          var ue = "var sharedModule = {}; (" + S.shared + ")(sharedModule); (" + S.worker + ")(sharedModule);", ce = {};
          return S.shared(ce), S.index(b, ce), typeof window < "u" && b.setWorkerUrl(window.URL.createObjectURL(new Blob([ue], { type: "text/javascript" }))), b;
        }
      }
      E("shared", ["exports"], function(T) {
        function a(r, t, i, s) {
          return new (i || (i = Promise))(function(l, p) {
            function f(w) {
              try {
                y(s.next(w));
              } catch (P) {
                p(P);
              }
            }
            function _(w) {
              try {
                y(s.throw(w));
              } catch (P) {
                p(P);
              }
            }
            function y(w) {
              var P;
              w.done ? l(w.value) : (P = w.value, P instanceof i ? P : new i(function(I) {
                I(P);
              })).then(f, _);
            }
            y((s = s.apply(r, t || [])).next());
          });
        }
        function U(r, t) {
          this.x = r, this.y = t;
        }
        function ue(r) {
          return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
        }
        var ce, ve;
        typeof SuppressedError == "function" && SuppressedError, U.prototype = { clone() {
          return new U(this.x, this.y);
        }, add(r) {
          return this.clone()._add(r);
        }, sub(r) {
          return this.clone()._sub(r);
        }, multByPoint(r) {
          return this.clone()._multByPoint(r);
        }, divByPoint(r) {
          return this.clone()._divByPoint(r);
        }, mult(r) {
          return this.clone()._mult(r);
        }, div(r) {
          return this.clone()._div(r);
        }, rotate(r) {
          return this.clone()._rotate(r);
        }, rotateAround(r, t) {
          return this.clone()._rotateAround(r, t);
        }, matMult(r) {
          return this.clone()._matMult(r);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(r) {
          return this.x === r.x && this.y === r.y;
        }, dist(r) {
          return Math.sqrt(this.distSqr(r));
        }, distSqr(r) {
          const t = r.x - this.x, i = r.y - this.y;
          return t * t + i * i;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(r) {
          return Math.atan2(this.y - r.y, this.x - r.x);
        }, angleWith(r) {
          return this.angleWithSep(r.x, r.y);
        }, angleWithSep(r, t) {
          return Math.atan2(this.x * t - this.y * r, this.x * r + this.y * t);
        }, _matMult(r) {
          const t = r[2] * this.x + r[3] * this.y;
          return this.x = r[0] * this.x + r[1] * this.y, this.y = t, this;
        }, _add(r) {
          return this.x += r.x, this.y += r.y, this;
        }, _sub(r) {
          return this.x -= r.x, this.y -= r.y, this;
        }, _mult(r) {
          return this.x *= r, this.y *= r, this;
        }, _div(r) {
          return this.x /= r, this.y /= r, this;
        }, _multByPoint(r) {
          return this.x *= r.x, this.y *= r.y, this;
        }, _divByPoint(r) {
          return this.x /= r.x, this.y /= r.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const r = this.y;
          return this.y = this.x, this.x = -r, this;
        }, _rotate(r) {
          const t = Math.cos(r), i = Math.sin(r), s = i * this.x + t * this.y;
          return this.x = t * this.x - i * this.y, this.y = s, this;
        }, _rotateAround(r, t) {
          const i = Math.cos(r), s = Math.sin(r), l = t.y + s * (this.x - t.x) + i * (this.y - t.y);
          return this.x = t.x + i * (this.x - t.x) - s * (this.y - t.y), this.y = l, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: U }, U.convert = function(r) {
          if (r instanceof U) return r;
          if (Array.isArray(r)) return new U(+r[0], +r[1]);
          if (r.x !== void 0 && r.y !== void 0) return new U(+r.x, +r.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var we = function() {
          if (ve) return ce;
          function r(t, i, s, l) {
            this.cx = 3 * t, this.bx = 3 * (s - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (l - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = i, this.p2x = s, this.p2y = l;
          }
          return ve = 1, ce = r, r.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, i) {
            if (i === void 0 && (i = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var s = t, l = 0; l < 8; l++) {
              var p = this.sampleCurveX(s) - t;
              if (Math.abs(p) < i) return s;
              var f = this.sampleCurveDerivativeX(s);
              if (Math.abs(f) < 1e-6) break;
              s -= p / f;
            }
            var _ = 0, y = 1;
            for (s = t, l = 0; l < 20 && (p = this.sampleCurveX(s), !(Math.abs(p - t) < i)); l++) t > p ? _ = s : y = s, s = 0.5 * (y - _) + _;
            return s;
          }, solve: function(t, i) {
            return this.sampleCurveY(this.solveCurveX(t, i));
          } }, ce;
        }(), Q = ue(we);
        let Je, it;
        function vt() {
          return Je == null && (Je = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), Je;
        }
        function Ze() {
          if (it == null && (it = !1, vt())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
            if (t) {
              for (let s = 0; s < 5 * 5; s++) {
                const l = 4 * s;
                t.fillStyle = `rgb(${l},${l + 1},${l + 2})`, t.fillRect(s % 5, Math.floor(s / 5), 1, 1);
              }
              const i = t.getImageData(0, 0, 5, 5).data;
              for (let s = 0; s < 5 * 5 * 4; s++) if (s % 4 != 3 && i[s] !== s) {
                it = !0;
                break;
              }
            }
          }
          return it || !1;
        }
        var Ke = 1e-6, ut = typeof Float32Array < "u" ? Float32Array : Array;
        function Qe() {
          var r = new ut(9);
          return ut != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
        }
        function It(r) {
          return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
        }
        function ki() {
          var r = new ut(3);
          return ut != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
        }
        function pt(r) {
          var t = r[0], i = r[1], s = r[2];
          return Math.sqrt(t * t + i * i + s * s);
        }
        function at(r, t, i) {
          var s = new ut(3);
          return s[0] = r, s[1] = t, s[2] = i, s;
        }
        function _t(r, t, i) {
          return r[0] = t[0] + i[0], r[1] = t[1] + i[1], r[2] = t[2] + i[2], r;
        }
        function Et(r, t, i) {
          return r[0] = t[0] * i, r[1] = t[1] * i, r[2] = t[2] * i, r;
        }
        function Ut(r, t, i) {
          var s = t[0], l = t[1], p = t[2], f = i[0], _ = i[1], y = i[2];
          return r[0] = l * y - p * _, r[1] = p * f - s * y, r[2] = s * _ - l * f, r;
        }
        var fi, ir = pt;
        function Jr(r, t, i) {
          var s = t[0], l = t[1], p = t[2], f = t[3];
          return r[0] = i[0] * s + i[4] * l + i[8] * p + i[12] * f, r[1] = i[1] * s + i[5] * l + i[9] * p + i[13] * f, r[2] = i[2] * s + i[6] * l + i[10] * p + i[14] * f, r[3] = i[3] * s + i[7] * l + i[11] * p + i[15] * f, r;
        }
        function Gr() {
          var r = new ut(4);
          return ut != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r[3] = 1, r;
        }
        function ti(r, t, i, s) {
          var l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", p = Math.PI / 360;
          t *= p, s *= p, i *= p;
          var f = Math.sin(t), _ = Math.cos(t), y = Math.sin(i), w = Math.cos(i), P = Math.sin(s), I = Math.cos(s);
          switch (l) {
            case "xyz":
              r[0] = f * w * I + _ * y * P, r[1] = _ * y * I - f * w * P, r[2] = _ * w * P + f * y * I, r[3] = _ * w * I - f * y * P;
              break;
            case "xzy":
              r[0] = f * w * I - _ * y * P, r[1] = _ * y * I - f * w * P, r[2] = _ * w * P + f * y * I, r[3] = _ * w * I + f * y * P;
              break;
            case "yxz":
              r[0] = f * w * I + _ * y * P, r[1] = _ * y * I - f * w * P, r[2] = _ * w * P - f * y * I, r[3] = _ * w * I + f * y * P;
              break;
            case "yzx":
              r[0] = f * w * I + _ * y * P, r[1] = _ * y * I + f * w * P, r[2] = _ * w * P - f * y * I, r[3] = _ * w * I - f * y * P;
              break;
            case "zxy":
              r[0] = f * w * I - _ * y * P, r[1] = _ * y * I + f * w * P, r[2] = _ * w * P + f * y * I, r[3] = _ * w * I - f * y * P;
              break;
            case "zyx":
              r[0] = f * w * I - _ * y * P, r[1] = _ * y * I + f * w * P, r[2] = _ * w * P - f * y * I, r[3] = _ * w * I + f * y * P;
              break;
            default:
              throw new Error("Unknown angle order " + l);
          }
          return r;
        }
        function At() {
          var r = new ut(2);
          return ut != Float32Array && (r[0] = 0, r[1] = 0), r;
        }
        function Jt(r, t) {
          var i = new ut(2);
          return i[0] = r, i[1] = t, i;
        }
        ki(), fi = new ut(4), ut != Float32Array && (fi[0] = 0, fi[1] = 0, fi[2] = 0, fi[3] = 0), ki(), at(1, 0, 0), at(0, 1, 0), Gr(), Gr(), Qe(), At();
        const Zt = 8192;
        function qr(r, t, i) {
          return t * (Zt / (r.tileSize * Math.pow(2, i - r.tileID.overscaledZ)));
        }
        function mi(r, t) {
          return (r % t + t) % t;
        }
        function Gi(r, t, i) {
          return r * (1 - i) + t * i;
        }
        function Dr(r) {
          if (r <= 0) return 0;
          if (r >= 1) return 1;
          const t = r * r, i = t * r;
          return 4 * (r < 0.5 ? i : 3 * (r - t) + i - 0.75);
        }
        function vn(r, t, i, s) {
          const l = new Q(r, t, i, s);
          return (p) => l.solve(p);
        }
        const Cn = vn(0.25, 0.1, 0.25, 1);
        function zi(r, t, i) {
          return Math.min(i, Math.max(t, r));
        }
        function Qr(r, t, i) {
          const s = i - t, l = ((r - t) % s + s) % s + t;
          return l === t ? i : l;
        }
        function ur(r, ...t) {
          for (const i of t) for (const s in i) r[s] = i[s];
          return r;
        }
        let Mr = 1;
        function Hr(r, t, i) {
          const s = {};
          for (const l in r) s[l] = t.call(this, r[l], l, r);
          return s;
        }
        function hs(r, t, i) {
          const s = {};
          for (const l in r) t.call(this, r[l], l, r) && (s[l] = r[l]);
          return s;
        }
        function ne(r) {
          return Array.isArray(r) ? r.map(ne) : typeof r == "object" && r ? Hr(r, ne) : r;
        }
        const ae = {};
        function Se(r) {
          ae[r] || (typeof console < "u" && console.warn(r), ae[r] = !0);
        }
        function ze(r, t, i) {
          return (i.y - r.y) * (t.x - r.x) > (t.y - r.y) * (i.x - r.x);
        }
        function Ae(r) {
          return typeof WorkerGlobalScope < "u" && r !== void 0 && r instanceof WorkerGlobalScope;
        }
        let Re = null;
        function He(r) {
          return typeof ImageBitmap < "u" && r instanceof ImageBitmap;
        }
        const Ue = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function Ge(r, t, i, s, l) {
          return a(this, void 0, void 0, function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const p = new VideoFrame(r, { timestamp: 0 });
            try {
              const f = p == null ? void 0 : p.format;
              if (!f || !f.startsWith("BGR") && !f.startsWith("RGB")) throw new Error(`Unrecognized format ${f}`);
              const _ = f.startsWith("BGR"), y = new Uint8ClampedArray(s * l * 4);
              if (yield p.copyTo(y, function(w, P, I, z, L) {
                const F = 4 * Math.max(-P, 0), V = (Math.max(0, I) - I) * z * 4 + F, $ = 4 * z, H = Math.max(0, P), he = Math.max(0, I);
                return { rect: { x: H, y: he, width: Math.min(w.width, P + z) - H, height: Math.min(w.height, I + L) - he }, layout: [{ offset: V, stride: $ }] };
              }(r, t, i, s, l)), _) for (let w = 0; w < y.length; w += 4) {
                const P = y[w];
                y[w] = y[w + 2], y[w + 2] = P;
              }
              return y;
            } finally {
              p.close();
            }
          });
        }
        let De, ht;
        function Ye(r, t, i, s) {
          return r.addEventListener(t, i, s), { unsubscribe: () => {
            r.removeEventListener(t, i, s);
          } };
        }
        function ct(r) {
          return r * Math.PI / 180;
        }
        function gt(r) {
          return r / Math.PI * 180;
        }
        const zt = { touchstart: !0, touchmove: !0, touchmoveWindow: !0, touchend: !0, touchcancel: !0 }, Wt = { dblclick: !0, click: !0, mouseover: !0, mouseout: !0, mousedown: !0, mousemove: !0, mousemoveWindow: !0, mouseup: !0, mouseupWindow: !0, contextmenu: !0, wheel: !0 }, Ht = "AbortError";
        function oe() {
          return new Error(Ht);
        }
        const B = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function j(r) {
          return B.REGISTERED_PROTOCOLS[r.substring(0, r.indexOf("://"))];
        }
        const N = "global-dispatcher";
        class X extends Error {
          constructor(t, i, s, l) {
            super(`AJAXError: ${i} (${t}): ${s}`), this.status = t, this.statusText = i, this.url = s, this.body = l;
          }
        }
        const ie = () => Ae(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, le = function(r, t) {
          if (/:\/\//.test(r.url) && !/^https?:|^file:/.test(r.url)) {
            const s = j(r.url);
            if (s) return s(r, t);
            if (Ae(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r, targetMapId: N }, t);
          }
          if (!(/^file:/.test(i = r.url) || /^file:/.test(ie()) && !/^\w+:/.test(i))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(s, l) {
              return a(this, void 0, void 0, function* () {
                const p = new Request(s.url, { method: s.method || "GET", body: s.body, credentials: s.credentials, headers: s.headers, cache: s.cache, referrer: ie(), signal: l.signal });
                let f, _;
                s.type !== "json" || p.headers.has("Accept") || p.headers.set("Accept", "application/json");
                try {
                  f = yield fetch(p);
                } catch (w) {
                  throw new X(0, w.message, s.url, new Blob());
                }
                if (!f.ok) {
                  const w = yield f.blob();
                  throw new X(f.status, f.statusText, s.url, w);
                }
                _ = s.type === "arrayBuffer" || s.type === "image" ? f.arrayBuffer() : s.type === "json" ? f.json() : f.text();
                const y = yield _;
                if (l.signal.aborted) throw oe();
                return { data: y, cacheControl: f.headers.get("Cache-Control"), expires: f.headers.get("Expires") };
              });
            }(r, t);
            if (Ae(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r, mustQueue: !0, targetMapId: N }, t);
          }
          var i;
          return function(s, l) {
            return new Promise((p, f) => {
              var _;
              const y = new XMLHttpRequest();
              y.open(s.method || "GET", s.url, !0), s.type !== "arrayBuffer" && s.type !== "image" || (y.responseType = "arraybuffer");
              for (const w in s.headers) y.setRequestHeader(w, s.headers[w]);
              s.type === "json" && (y.responseType = "text", !((_ = s.headers) === null || _ === void 0) && _.Accept || y.setRequestHeader("Accept", "application/json")), y.withCredentials = s.credentials === "include", y.onerror = () => {
                f(new Error(y.statusText));
              }, y.onload = () => {
                if (!l.signal.aborted) if ((y.status >= 200 && y.status < 300 || y.status === 0) && y.response !== null) {
                  let w = y.response;
                  if (s.type === "json") try {
                    w = JSON.parse(y.response);
                  } catch (P) {
                    return void f(P);
                  }
                  p({ data: w, cacheControl: y.getResponseHeader("Cache-Control"), expires: y.getResponseHeader("Expires") });
                } else {
                  const w = new Blob([y.response], { type: y.getResponseHeader("Content-Type") });
                  f(new X(y.status, y.statusText, s.url, w));
                }
              }, l.signal.addEventListener("abort", () => {
                y.abort(), f(oe());
              }), y.send(s.body);
            });
          }(r, t);
        };
        function me(r) {
          if (!r || r.indexOf("://") <= 0 || r.indexOf("data:image/") === 0 || r.indexOf("blob:") === 0) return !0;
          const t = new URL(r), i = window.location;
          return t.protocol === i.protocol && t.host === i.host;
        }
        function de(r, t, i) {
          i[r] && i[r].indexOf(t) !== -1 || (i[r] = i[r] || [], i[r].push(t));
        }
        function Pe(r, t, i) {
          if (i && i[r]) {
            const s = i[r].indexOf(t);
            s !== -1 && i[r].splice(s, 1);
          }
        }
        class ke {
          constructor(t, i = {}) {
            ur(this, i), this.type = t;
          }
        }
        class Ce extends ke {
          constructor(t, i = {}) {
            super("error", ur({ error: t }, i));
          }
        }
        class rt {
          on(t, i) {
            return this._listeners = this._listeners || {}, de(t, i, this._listeners), { unsubscribe: () => {
              this.off(t, i);
            } };
          }
          off(t, i) {
            return Pe(t, i, this._listeners), Pe(t, i, this._oneTimeListeners), this;
          }
          once(t, i) {
            return i ? (this._oneTimeListeners = this._oneTimeListeners || {}, de(t, i, this._oneTimeListeners), this) : new Promise((s) => this.once(t, s));
          }
          fire(t, i) {
            typeof t == "string" && (t = new ke(t, i || {}));
            const s = t.type;
            if (this.listens(s)) {
              t.target = this;
              const l = this._listeners && this._listeners[s] ? this._listeners[s].slice() : [];
              for (const _ of l) _.call(this, t);
              const p = this._oneTimeListeners && this._oneTimeListeners[s] ? this._oneTimeListeners[s].slice() : [];
              for (const _ of p) Pe(s, _, this._oneTimeListeners), _.call(this, t);
              const f = this._eventedParent;
              f && (ur(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), f.fire(t));
            } else t instanceof Ce && console.error(t.error);
            return this;
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
          }
          setEventedParent(t, i) {
            return this._eventedParent = t, this._eventedParentData = i, this;
          }
        }
        var fe = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: !1, expression: { interpolated: !0, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const bt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function Dt(r, t) {
          const i = {};
          for (const s in r) s !== "ref" && (i[s] = r[s]);
          return bt.forEach((s) => {
            s in t && (i[s] = t[s]);
          }), i;
        }
        function ot(r, t) {
          if (Array.isArray(r)) {
            if (!Array.isArray(t) || r.length !== t.length) return !1;
            for (let i = 0; i < r.length; i++) if (!ot(r[i], t[i])) return !1;
            return !0;
          }
          if (typeof r == "object" && r !== null && t !== null) {
            if (typeof t != "object" || Object.keys(r).length !== Object.keys(t).length) return !1;
            for (const i in r) if (!ot(r[i], t[i])) return !1;
            return !0;
          }
          return r === t;
        }
        function St(r, t) {
          r.push(t);
        }
        function ui(r, t, i) {
          St(i, { command: "addSource", args: [r, t[r]] });
        }
        function ji(r, t, i) {
          St(t, { command: "removeSource", args: [r] }), i[r] = !0;
        }
        function Vi(r, t, i, s) {
          ji(r, i, s), ui(r, t, i);
        }
        function Ci(r, t, i) {
          let s;
          for (s in r[i]) if (Object.prototype.hasOwnProperty.call(r[i], s) && s !== "data" && !ot(r[i][s], t[i][s])) return !1;
          for (s in t[i]) if (Object.prototype.hasOwnProperty.call(t[i], s) && s !== "data" && !ot(r[i][s], t[i][s])) return !1;
          return !0;
        }
        function Ot(r, t, i, s, l, p) {
          r = r || {}, t = t || {};
          for (const f in r) Object.prototype.hasOwnProperty.call(r, f) && (ot(r[f], t[f]) || i.push({ command: p, args: [s, f, t[f], l] }));
          for (const f in t) Object.prototype.hasOwnProperty.call(t, f) && !Object.prototype.hasOwnProperty.call(r, f) && (ot(r[f], t[f]) || i.push({ command: p, args: [s, f, t[f], l] }));
        }
        function Gt(r) {
          return r.id;
        }
        function Ri(r, t) {
          return r[t.id] = t, r;
        }
        class Fe {
          constructor(t, i, s, l) {
            this.message = (t ? `${t}: ` : "") + s, l && (this.identifier = l), i != null && i.__line__ && (this.line = i.__line__);
          }
        }
        function hr(r, ...t) {
          for (const i of t) for (const s in i) r[s] = i[s];
          return r;
        }
        class vi extends Error {
          constructor(t, i) {
            super(i), this.message = i, this.key = t;
          }
        }
        class $n {
          constructor(t, i = []) {
            this.parent = t, this.bindings = {};
            for (const [s, l] of i) this.bindings[s] = l;
          }
          concat(t) {
            return new $n(this, t);
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`);
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t);
          }
        }
        const $s = { kind: "null" }, qe = { kind: "number" }, Lt = { kind: "string" }, kt = { kind: "boolean" }, rr = { kind: "color" }, ds = { kind: "projectionDefinition" }, Un = { kind: "object" }, Mt = { kind: "value" }, va = { kind: "collator" }, Zn = { kind: "formatted" }, xa = { kind: "padding" }, xn = { kind: "colorArray" }, Us = { kind: "numberArray" }, Ti = { kind: "resolvedImage" }, ba = { kind: "variableAnchorOffsetCollection" };
        function Cr(r, t) {
          return { kind: "array", itemType: r, N: t };
        }
        function si(r) {
          if (r.kind === "array") {
            const t = si(r.itemType);
            return typeof r.N == "number" ? `array<${t}, ${r.N}>` : r.itemType.kind === "value" ? "array" : `array<${t}>`;
          }
          return r.kind;
        }
        const lu = [$s, qe, Lt, kt, rr, ds, Zn, Un, Cr(Mt), xa, Us, xn, Ti, ba];
        function Co(r, t) {
          if (t.kind === "error") return null;
          if (r.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !Co(r.itemType, t.itemType)) && (typeof r.N != "number" || r.N === t.N)) return null;
          } else {
            if (r.kind === t.kind) return null;
            if (r.kind === "value") {
              for (const i of lu) if (!Co(i, t)) return null;
            }
          }
          return `Expected ${si(r)} but found ${si(t)} instead.`;
        }
        function Rl(r, t) {
          return t.some((i) => i.kind === r.kind);
        }
        function Gn(r, t) {
          return t.some((i) => i === "null" ? r === null : i === "array" ? Array.isArray(r) : i === "object" ? r && !Array.isArray(r) && typeof r == "object" : i === typeof r);
        }
        function qn(r, t) {
          return r.kind === "array" && t.kind === "array" ? r.itemType.kind === t.itemType.kind && typeof r.N == "number" : r.kind === t.kind;
        }
        const Dl = 0.96422, cu = 0.82521, uu = 4 / 29, Zs = 6 / 29, hu = 3 * Zs * Zs, id = Zs * Zs * Zs, rd = Math.PI / 180, nd = 180 / Math.PI;
        function Ll(r) {
          return (r %= 360) < 0 && (r += 360), r;
        }
        function Gs([r, t, i, s]) {
          let l, p;
          const f = Bl((0.2225045 * (r = Fl(r)) + 0.7168786 * (t = Fl(t)) + 0.0606169 * (i = Fl(i))) / 1);
          r === t && t === i ? l = p = f : (l = Bl((0.4360747 * r + 0.3850649 * t + 0.1430804 * i) / Dl), p = Bl((0.0139322 * r + 0.0971045 * t + 0.7141733 * i) / cu));
          const _ = 116 * f - 16;
          return [_ < 0 ? 0 : _, 500 * (l - f), 200 * (f - p), s];
        }
        function Fl(r) {
          return r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
        }
        function Bl(r) {
          return r > id ? Math.pow(r, 1 / 3) : r / hu + uu;
        }
        function qs([r, t, i, s]) {
          let l = (r + 16) / 116, p = isNaN(t) ? l : l + t / 500, f = isNaN(i) ? l : l - i / 200;
          return l = 1 * jl(l), p = Dl * jl(p), f = cu * jl(f), [Ol(3.1338561 * p - 1.6168667 * l - 0.4906146 * f), Ol(-0.9787684 * p + 1.9161415 * l + 0.033454 * f), Ol(0.0719453 * p - 0.2289914 * l + 1.4052427 * f), s];
        }
        function Ol(r) {
          return (r = r <= 304e-5 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055) < 0 ? 0 : r > 1 ? 1 : r;
        }
        function jl(r) {
          return r > Zs ? r * r * r : hu * (r - uu);
        }
        const sd = Object.hasOwn || function(r, t) {
          return Object.prototype.hasOwnProperty.call(r, t);
        };
        function Hs(r, t) {
          return sd(r, t) ? r[t] : void 0;
        }
        function Io(r) {
          return parseInt(r.padEnd(2, r), 16) / 255;
        }
        function en(r, t) {
          return Ft(t ? r / 100 : r, 0, 1);
        }
        function Ft(r, t, i) {
          return Math.min(Math.max(t, r), i);
        }
        function ps(r) {
          return !r.some(Number.isNaN);
        }
        const Hn = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function In(r, t, i) {
          return r + i * (t - r);
        }
        function fs(r, t, i) {
          return r.map((s, l) => In(s, t[l], i));
        }
        class Bt {
          constructor(t, i, s, l = 1, p = !0) {
            this.r = t, this.g = i, this.b = s, this.a = l, p || (this.r *= l, this.g *= l, this.b *= l, l || this.overwriteGetter("rgb", [t, i, s, l]));
          }
          static parse(t) {
            if (t instanceof Bt) return t;
            if (typeof t != "string") return;
            const i = function(s) {
              if ((s = s.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const l = Hs(Hn, s);
              if (l) {
                const [f, _, y] = l;
                return [f / 255, _ / 255, y / 255, 1];
              }
              if (s.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(s)) {
                const f = s.length < 6 ? 1 : 2;
                let _ = 1;
                return [Io(s.slice(_, _ += f)), Io(s.slice(_, _ += f)), Io(s.slice(_, _ += f)), Io(s.slice(_, _ + f) || "ff")];
              }
              if (s.startsWith("rgb")) {
                const f = s.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (f) {
                  const [_, y, w, P, I, z, L, F, V, $, H, he] = f, ee = [P || " ", L || " ", $].join("");
                  if (ee === "  " || ee === "  /" || ee === ",," || ee === ",,,") {
                    const re = [w, z, V].join(""), ye = re === "%%%" ? 100 : re === "" ? 255 : 0;
                    if (ye) {
                      const Te = [Ft(+y / ye, 0, 1), Ft(+I / ye, 0, 1), Ft(+F / ye, 0, 1), H ? en(+H, he) : 1];
                      if (ps(Te)) return Te;
                    }
                  }
                  return;
                }
              }
              const p = s.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (p) {
                const [f, _, y, w, P, I, z, L, F] = p, V = [y || " ", P || " ", z].join("");
                if (V === "  " || V === "  /" || V === ",," || V === ",,,") {
                  const $ = [+_, Ft(+w, 0, 100), Ft(+I, 0, 100), L ? en(+L, F) : 1];
                  if (ps($)) return function([H, he, ee, re]) {
                    function ye(Te) {
                      const Ee = (Te + H / 30) % 12, $e = he * Math.min(ee, 1 - ee);
                      return ee - $e * Math.max(-1, Math.min(Ee - 3, 9 - Ee, 1));
                    }
                    return H = Ll(H), he /= 100, ee /= 100, [ye(0), ye(8), ye(4), re];
                  }($);
                }
              }
            }(t);
            return i ? new Bt(...i, !1) : void 0;
          }
          get rgb() {
            const { r: t, g: i, b: s, a: l } = this, p = l || 1 / 0;
            return this.overwriteGetter("rgb", [t / p, i / p, s / p, l]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", function(t) {
              const [i, s, l, p] = Gs(t), f = Math.sqrt(s * s + l * l);
              return [Math.round(1e4 * f) ? Ll(Math.atan2(l, s) * nd) : NaN, f, i, p];
            }(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Gs(this.rgb));
          }
          overwriteGetter(t, i) {
            return Object.defineProperty(this, t, { value: i }), i;
          }
          toString() {
            const [t, i, s, l] = this.rgb;
            return `rgba(${[t, i, s].map((p) => Math.round(255 * p)).join(",")},${l})`;
          }
          static interpolate(t, i, s, l = "rgb") {
            switch (l) {
              case "rgb": {
                const [p, f, _, y] = fs(t.rgb, i.rgb, s);
                return new Bt(p, f, _, y, !1);
              }
              case "hcl": {
                const [p, f, _, y] = t.hcl, [w, P, I, z] = i.hcl;
                let L, F;
                if (isNaN(p) || isNaN(w)) isNaN(p) ? isNaN(w) ? L = NaN : (L = w, _ !== 1 && _ !== 0 || (F = P)) : (L = p, I !== 1 && I !== 0 || (F = f));
                else {
                  let ee = w - p;
                  w > p && ee > 180 ? ee -= 360 : w < p && p - w > 180 && (ee += 360), L = p + s * ee;
                }
                const [V, $, H, he] = function([ee, re, ye, Te]) {
                  return ee = isNaN(ee) ? 0 : ee * rd, qs([ye, Math.cos(ee) * re, Math.sin(ee) * re, Te]);
                }([L, F ?? In(f, P, s), In(_, I, s), In(y, z, s)]);
                return new Bt(V, $, H, he, !1);
              }
              case "lab": {
                const [p, f, _, y] = qs(fs(t.lab, i.lab, s));
                return new Bt(p, f, _, y, !1);
              }
            }
          }
        }
        Bt.black = new Bt(0, 0, 0, 1), Bt.white = new Bt(1, 1, 1, 1), Bt.transparent = new Bt(0, 0, 0, 0), Bt.red = new Bt(1, 0, 0, 1);
        class ms {
          constructor(t, i, s) {
            this.sensitivity = t ? i ? "variant" : "case" : i ? "accent" : "base", this.locale = s, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t, i) {
            return this.collator.compare(t, i);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const wa = ["bottom", "center", "top"];
        class Ta {
          constructor(t, i, s, l, p, f) {
            this.text = t, this.image = i, this.scale = s, this.fontStack = l, this.textColor = p, this.verticalAlign = f;
          }
        }
        class yr {
          constructor(t) {
            this.sections = t;
          }
          static fromString(t) {
            return new yr([new Ta(t, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0);
          }
          static factory(t) {
            return t instanceof yr ? t : yr.fromString(t);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t) => t.text).join("");
          }
        }
        class qi {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof qi) return t;
            if (typeof t == "number") return new qi([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const i of t) if (typeof i != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]];
              }
              return new qi(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, i, s) {
            return new qi(fs(t.values, i.values, s));
          }
        }
        class vr {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof vr) return t;
            if (typeof t == "number") return new vr([t]);
            if (Array.isArray(t)) {
              for (const i of t) if (typeof i != "number") return;
              return new vr(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, i, s) {
            return new vr(fs(t.values, i.values, s));
          }
        }
        class Di {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Di) return t;
            if (typeof t == "string") {
              const s = Bt.parse(t);
              return s ? new Di([s]) : void 0;
            }
            if (!Array.isArray(t)) return;
            const i = [];
            for (const s of t) {
              if (typeof s != "string") return;
              const l = Bt.parse(s);
              if (!l) return;
              i.push(l);
            }
            return new Di(i);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, i, s, l = "rgb") {
            const p = [];
            if (t.values.length != i.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${i.values.length}), cannot interpolate.`);
            for (let f = 0; f < t.values.length; f++) p.push(Bt.interpolate(t.values[f], i.values[f], s, l));
            return new Di(p);
          }
        }
        class oi extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const du = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class xr {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof xr) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let i = 0; i < t.length; i += 2) {
                const s = t[i], l = t[i + 1];
                if (typeof s != "string" || !du.has(s) || !Array.isArray(l) || l.length !== 2 || typeof l[0] != "number" || typeof l[1] != "number") return;
              }
              return new xr(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, i, s) {
            const l = t.values, p = i.values;
            if (l.length !== p.length) throw new oi(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${i.toString()}`);
            const f = [];
            for (let _ = 0; _ < l.length; _ += 2) {
              if (l[_] !== p[_]) throw new oi(`Cannot interpolate values containing mismatched anchors. from[${_}]: ${l[_]}, to[${_}]: ${p[_]}`);
              f.push(l[_]);
              const [y, w] = l[_ + 1], [P, I] = p[_ + 1];
              f.push([In(y, P, s), In(w, I, s)]);
            }
            return new xr(f);
          }
        }
        class Lr {
          constructor(t) {
            this.name = t.name, this.available = t.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t) {
            return t ? new Lr({ name: t, available: !1 }) : null;
          }
        }
        class dr {
          constructor(t, i, s) {
            this.from = t, this.to = i, this.transition = s;
          }
          static interpolate(t, i, s) {
            return new dr(t, i, s);
          }
          static parse(t) {
            return t instanceof dr ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new dr(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new dr(t.from, t.to, t.transition) : typeof t == "string" ? new dr(t, t, 1) : void 0;
          }
        }
        function hi(r, t, i, s) {
          return typeof r == "number" && r >= 0 && r <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof i == "number" && i >= 0 && i <= 255 ? s === void 0 || typeof s == "number" && s >= 0 && s <= 1 ? null : `Invalid rgba value [${[r, t, i, s].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof s == "number" ? [r, t, i, s] : [r, t, i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function gs(r) {
          if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof dr || r instanceof Bt || r instanceof ms || r instanceof yr || r instanceof qi || r instanceof vr || r instanceof Di || r instanceof xr || r instanceof Lr) return !0;
          if (Array.isArray(r)) {
            for (const t of r) if (!gs(t)) return !1;
            return !0;
          }
          if (typeof r == "object") {
            for (const t in r) if (!gs(r[t])) return !1;
            return !0;
          }
          return !1;
        }
        function ft(r) {
          if (r === null) return $s;
          if (typeof r == "string") return Lt;
          if (typeof r == "boolean") return kt;
          if (typeof r == "number") return qe;
          if (r instanceof Bt) return rr;
          if (r instanceof dr) return ds;
          if (r instanceof ms) return va;
          if (r instanceof yr) return Zn;
          if (r instanceof qi) return xa;
          if (r instanceof vr) return Us;
          if (r instanceof Di) return xn;
          if (r instanceof xr) return ba;
          if (r instanceof Lr) return Ti;
          if (Array.isArray(r)) {
            const t = r.length;
            let i;
            for (const s of r) {
              const l = ft(s);
              if (i) {
                if (i === l) continue;
                i = Mt;
                break;
              }
              i = l;
            }
            return Cr(i || Mt, t);
          }
          return Un;
        }
        function Tt(r) {
          const t = typeof r;
          return r === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(r) : r instanceof Bt || r instanceof dr || r instanceof yr || r instanceof qi || r instanceof vr || r instanceof Di || r instanceof xr || r instanceof Lr ? r.toString() : JSON.stringify(r);
        }
        class En {
          constructor(t, i) {
            this.type = t, this.value = i;
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (!gs(t[1])) return i.error("invalid value");
            const s = t[1];
            let l = ft(s);
            const p = i.expectedType;
            return l.kind !== "array" || l.N !== 0 || !p || p.kind !== "array" || typeof p.N == "number" && p.N !== 0 || (l = p), new En(l, s);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const qt = { string: Lt, number: qe, boolean: kt, object: Un };
        class Fr {
          constructor(t, i) {
            this.type = t, this.args = i;
          }
          static parse(t, i) {
            if (t.length < 2) return i.error("Expected at least one argument.");
            let s, l = 1;
            const p = t[0];
            if (p === "array") {
              let _, y;
              if (t.length > 2) {
                const w = t[1];
                if (typeof w != "string" || !(w in qt) || w === "object") return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
                _ = qt[w], l++;
              } else _ = Mt;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return i.error('The length argument to "array" must be a positive integer literal', 2);
                y = t[2], l++;
              }
              s = Cr(_, y);
            } else {
              if (!qt[p]) throw new Error(`Types doesn't contain name = ${p}`);
              s = qt[p];
            }
            const f = [];
            for (; l < t.length; l++) {
              const _ = i.parse(t[l], l, Mt);
              if (!_) return null;
              f.push(_);
            }
            return new Fr(s, f);
          }
          evaluate(t) {
            for (let i = 0; i < this.args.length; i++) {
              const s = this.args[i].evaluate(t);
              if (!Co(this.type, ft(s))) return s;
              if (i === this.args.length - 1) throw new oi(`Expected value to be of type ${si(this.type)}, but found ${si(ft(s))} instead.`);
            }
            throw new Error();
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every((t) => t.outputDefined());
          }
        }
        const bn = { "to-boolean": kt, "to-color": rr, "to-number": qe, "to-string": Lt };
        class wn {
          constructor(t, i) {
            this.type = t, this.args = i;
          }
          static parse(t, i) {
            if (t.length < 2) return i.error("Expected at least one argument.");
            const s = t[0];
            if (!bn[s]) throw new Error(`Can't parse ${s} as it is not part of the known types`);
            if ((s === "to-boolean" || s === "to-string") && t.length !== 2) return i.error("Expected one argument.");
            const l = bn[s], p = [];
            for (let f = 1; f < t.length; f++) {
              const _ = i.parse(t[f], f, Mt);
              if (!_) return null;
              p.push(_);
            }
            return new wn(l, p);
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let i, s;
                for (const l of this.args) {
                  if (i = l.evaluate(t), s = null, i instanceof Bt) return i;
                  if (typeof i == "string") {
                    const p = t.parseColor(i);
                    if (p) return p;
                  } else if (Array.isArray(i) && (s = i.length < 3 || i.length > 4 ? `Invalid rgba value ${JSON.stringify(i)}: expected an array containing either three or four numeric values.` : hi(i[0], i[1], i[2], i[3]), !s)) return new Bt(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
                }
                throw new oi(s || `Could not parse color from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
              }
              case "padding": {
                let i;
                for (const s of this.args) {
                  i = s.evaluate(t);
                  const l = qi.parse(i);
                  if (l) return l;
                }
                throw new oi(`Could not parse padding from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
              }
              case "numberArray": {
                let i;
                for (const s of this.args) {
                  i = s.evaluate(t);
                  const l = vr.parse(i);
                  if (l) return l;
                }
                throw new oi(`Could not parse numberArray from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
              }
              case "colorArray": {
                let i;
                for (const s of this.args) {
                  i = s.evaluate(t);
                  const l = Di.parse(i);
                  if (l) return l;
                }
                throw new oi(`Could not parse colorArray from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let i;
                for (const s of this.args) {
                  i = s.evaluate(t);
                  const l = xr.parse(i);
                  if (l) return l;
                }
                throw new oi(`Could not parse variableAnchorOffsetCollection from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
              }
              case "number": {
                let i = null;
                for (const s of this.args) {
                  if (i = s.evaluate(t), i === null) return 0;
                  const l = Number(i);
                  if (!isNaN(l)) return l;
                }
                throw new oi(`Could not convert ${JSON.stringify(i)} to number.`);
              }
              case "formatted":
                return yr.fromString(Tt(this.args[0].evaluate(t)));
              case "resolvedImage":
                return Lr.fromString(Tt(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return Tt(this.args[0].evaluate(t));
            }
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every((t) => t.outputDefined());
          }
        }
        const Sa = ["Unknown", "Point", "LineString", "Polygon"];
        class Vl {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Sa[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t) {
            let i = this._parseColorCache.get(t);
            return i || (i = Bt.parse(t), this._parseColorCache.set(t, i)), i;
          }
        }
        class Ws {
          constructor(t, i, s = [], l, p = new $n(), f = []) {
            this.registry = t, this.path = s, this.key = s.map((_) => `[${_}]`).join(""), this.scope = p, this.errors = f, this.expectedType = l, this._isConstant = i;
          }
          parse(t, i, s, l, p = {}) {
            return i ? this.concat(i, s, l)._parse(t, p) : this._parse(t, p);
          }
          _parse(t, i) {
            function s(l, p, f) {
              return f === "assert" ? new Fr(p, [l]) : f === "coerce" ? new wn(p, [l]) : l;
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const l = t[0];
              if (typeof l != "string") return this.error(`Expression name must be a string, but found ${typeof l} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const p = this.registry[l];
              if (p) {
                let f = p.parse(t, this);
                if (!f) return null;
                if (this.expectedType) {
                  const _ = this.expectedType, y = f.type;
                  if (_.kind !== "string" && _.kind !== "number" && _.kind !== "boolean" && _.kind !== "object" && _.kind !== "array" || y.kind !== "value") {
                    if (_.kind === "projectionDefinition" && ["string", "array"].includes(y.kind) || ["color", "formatted", "resolvedImage"].includes(_.kind) && ["value", "string"].includes(y.kind) || ["padding", "numberArray"].includes(_.kind) && ["value", "number", "array"].includes(y.kind) || _.kind === "colorArray" && ["value", "string", "array"].includes(y.kind) || _.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(y.kind)) f = s(f, _, i.typeAnnotation || "coerce");
                    else if (this.checkSubtype(_, y)) return null;
                  } else f = s(f, _, i.typeAnnotation || "assert");
                }
                if (!(f instanceof En) && f.type.kind !== "resolvedImage" && this._isConstant(f)) {
                  const _ = new Vl();
                  try {
                    f = new En(f.type, f.evaluate(_));
                  } catch (y) {
                    return this.error(y.message), null;
                  }
                }
                return f;
              }
              return this.error(`Unknown expression "${l}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
          }
          concat(t, i, s) {
            const l = typeof t == "number" ? this.path.concat(t) : this.path, p = s ? this.scope.concat(s) : this.scope;
            return new Ws(this.registry, this._isConstant, l, i || null, p, this.errors);
          }
          error(t, ...i) {
            const s = `${this.key}${i.map((l) => `[${l}]`).join("")}`;
            this.errors.push(new vi(s, t));
          }
          checkSubtype(t, i) {
            const s = Co(t, i);
            return s && this.error(s), s;
          }
        }
        class Eo {
          constructor(t, i) {
            this.type = i.type, this.bindings = [].concat(t), this.result = i;
          }
          evaluate(t) {
            return this.result.evaluate(t);
          }
          eachChild(t) {
            for (const i of this.bindings) t(i[1]);
            t(this.result);
          }
          static parse(t, i) {
            if (t.length < 4) return i.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
            const s = [];
            for (let p = 1; p < t.length - 1; p += 2) {
              const f = t[p];
              if (typeof f != "string") return i.error(`Expected string, but found ${typeof f} instead.`, p);
              if (/[^a-zA-Z0-9_]/.test(f)) return i.error("Variable names must contain only alphanumeric characters or '_'.", p);
              const _ = i.parse(t[p + 1], p + 1);
              if (!_) return null;
              s.push([f, _]);
            }
            const l = i.parse(t[t.length - 1], t.length - 1, i.expectedType, s);
            return l ? new Eo(s, l) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Pa {
          constructor(t, i) {
            this.type = i.type, this.name = t, this.boundExpression = i;
          }
          static parse(t, i) {
            if (t.length !== 2 || typeof t[1] != "string") return i.error("'var' expression requires exactly one string literal argument.");
            const s = t[1];
            return i.scope.has(s) ? new Pa(s, i.scope.get(s)) : i.error(`Unknown variable "${s}". Make sure "${s}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        class Ma {
          constructor(t, i, s) {
            this.type = t, this.index = i, this.input = s;
          }
          static parse(t, i) {
            if (t.length !== 3) return i.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const s = i.parse(t[1], 1, qe), l = i.parse(t[2], 2, Cr(i.expectedType || Mt));
            return s && l ? new Ma(l.type.itemType, s, l) : null;
          }
          evaluate(t) {
            const i = this.index.evaluate(t), s = this.input.evaluate(t);
            if (i < 0) throw new oi(`Array index out of bounds: ${i} < 0.`);
            if (i >= s.length) throw new oi(`Array index out of bounds: ${i} > ${s.length - 1}.`);
            if (i !== Math.floor(i)) throw new oi(`Array index must be an integer, but found ${i} instead.`);
            return s[i];
          }
          eachChild(t) {
            t(this.index), t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class Ca {
          constructor(t, i) {
            this.type = kt, this.needle = t, this.haystack = i;
          }
          static parse(t, i) {
            if (t.length !== 3) return i.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const s = i.parse(t[1], 1, Mt), l = i.parse(t[2], 2, Mt);
            return s && l ? Rl(s.type, [kt, Lt, qe, $s, Mt]) ? new Ca(s, l) : i.error(`Expected first argument to be of type boolean, string, number or null, but found ${si(s.type)} instead`) : null;
          }
          evaluate(t) {
            const i = this.needle.evaluate(t), s = this.haystack.evaluate(t);
            if (!s) return !1;
            if (!Gn(i, ["boolean", "string", "number", "null"])) throw new oi(`Expected first argument to be of type boolean, string, number or null, but found ${si(ft(i))} instead.`);
            if (!Gn(s, ["string", "array"])) throw new oi(`Expected second argument to be of type array or string, but found ${si(ft(s))} instead.`);
            return s.indexOf(i) >= 0;
          }
          eachChild(t) {
            t(this.needle), t(this.haystack);
          }
          outputDefined() {
            return !0;
          }
        }
        class tn {
          constructor(t, i, s) {
            this.type = qe, this.needle = t, this.haystack = i, this.fromIndex = s;
          }
          static parse(t, i) {
            if (t.length <= 2 || t.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
            const s = i.parse(t[1], 1, Mt), l = i.parse(t[2], 2, Mt);
            if (!s || !l) return null;
            if (!Rl(s.type, [kt, Lt, qe, $s, Mt])) return i.error(`Expected first argument to be of type boolean, string, number or null, but found ${si(s.type)} instead`);
            if (t.length === 4) {
              const p = i.parse(t[3], 3, qe);
              return p ? new tn(s, l, p) : null;
            }
            return new tn(s, l);
          }
          evaluate(t) {
            const i = this.needle.evaluate(t), s = this.haystack.evaluate(t);
            if (!Gn(i, ["boolean", "string", "number", "null"])) throw new oi(`Expected first argument to be of type boolean, string, number or null, but found ${si(ft(i))} instead.`);
            let l;
            if (this.fromIndex && (l = this.fromIndex.evaluate(t)), Gn(s, ["string"])) {
              const p = s.indexOf(i, l);
              return p === -1 ? -1 : [...s.slice(0, p)].length;
            }
            if (Gn(s, ["array"])) return s.indexOf(i, l);
            throw new oi(`Expected second argument to be of type array or string, but found ${si(ft(s))} instead.`);
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        class Hi {
          constructor(t, i, s, l, p, f) {
            this.inputType = t, this.type = i, this.input = s, this.cases = l, this.outputs = p, this.otherwise = f;
          }
          static parse(t, i) {
            if (t.length < 5) return i.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 1) return i.error("Expected an even number of arguments.");
            let s, l;
            i.expectedType && i.expectedType.kind !== "value" && (l = i.expectedType);
            const p = {}, f = [];
            for (let w = 2; w < t.length - 1; w += 2) {
              let P = t[w];
              const I = t[w + 1];
              Array.isArray(P) || (P = [P]);
              const z = i.concat(w);
              if (P.length === 0) return z.error("Expected at least one branch label.");
              for (const F of P) {
                if (typeof F != "number" && typeof F != "string") return z.error("Branch labels must be numbers or strings.");
                if (typeof F == "number" && Math.abs(F) > Number.MAX_SAFE_INTEGER) return z.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof F == "number" && Math.floor(F) !== F) return z.error("Numeric branch labels must be integer values.");
                if (s) {
                  if (z.checkSubtype(s, ft(F))) return null;
                } else s = ft(F);
                if (p[String(F)] !== void 0) return z.error("Branch labels must be unique.");
                p[String(F)] = f.length;
              }
              const L = i.parse(I, w, l);
              if (!L) return null;
              l = l || L.type, f.push(L);
            }
            const _ = i.parse(t[1], 1, Mt);
            if (!_) return null;
            const y = i.parse(t[t.length - 1], t.length - 1, l);
            return y ? _.type.kind !== "value" && i.concat(1).checkSubtype(s, _.type) ? null : new Hi(s, l, _, p, f, y) : null;
          }
          evaluate(t) {
            const i = this.input.evaluate(t);
            return (ft(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(t);
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t) => t.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class Xs {
          constructor(t, i, s) {
            this.type = t, this.branches = i, this.otherwise = s;
          }
          static parse(t, i) {
            if (t.length < 4) return i.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 0) return i.error("Expected an odd number of arguments.");
            let s;
            i.expectedType && i.expectedType.kind !== "value" && (s = i.expectedType);
            const l = [];
            for (let f = 1; f < t.length - 1; f += 2) {
              const _ = i.parse(t[f], f, kt);
              if (!_) return null;
              const y = i.parse(t[f + 1], f + 1, s);
              if (!y) return null;
              l.push([_, y]), s = s || y.type;
            }
            const p = i.parse(t[t.length - 1], t.length - 1, s);
            if (!p) return null;
            if (!s) throw new Error("Can't infer output type");
            return new Xs(s, l, p);
          }
          evaluate(t) {
            for (const [i, s] of this.branches) if (i.evaluate(t)) return s.evaluate(t);
            return this.otherwise.evaluate(t);
          }
          eachChild(t) {
            for (const [i, s] of this.branches) t(i), t(s);
            t(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t, i]) => i.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class Ao {
          constructor(t, i, s, l) {
            this.type = t, this.input = i, this.beginIndex = s, this.endIndex = l;
          }
          static parse(t, i) {
            if (t.length <= 2 || t.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
            const s = i.parse(t[1], 1, Mt), l = i.parse(t[2], 2, qe);
            if (!s || !l) return null;
            if (!Rl(s.type, [Cr(Mt), Lt, Mt])) return i.error(`Expected first argument to be of type array or string, but found ${si(s.type)} instead`);
            if (t.length === 4) {
              const p = i.parse(t[3], 3, qe);
              return p ? new Ao(s.type, s, l, p) : null;
            }
            return new Ao(s.type, s, l);
          }
          evaluate(t) {
            const i = this.input.evaluate(t), s = this.beginIndex.evaluate(t);
            let l;
            if (this.endIndex && (l = this.endIndex.evaluate(t)), Gn(i, ["string"])) return [...i].slice(s, l).join("");
            if (Gn(i, ["array"])) return i.slice(s, l);
            throw new oi(`Expected first argument to be of type array or string, but found ${si(ft(i))} instead.`);
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        function _s(r, t) {
          const i = r.length - 1;
          let s, l, p = 0, f = i, _ = 0;
          for (; p <= f; ) if (_ = Math.floor((p + f) / 2), s = r[_], l = r[_ + 1], s <= t) {
            if (_ === i || t < l) return _;
            p = _ + 1;
          } else {
            if (!(s > t)) throw new oi("Input is not a number.");
            f = _ - 1;
          }
          return 0;
        }
        class Si {
          constructor(t, i, s) {
            this.type = t, this.input = i, this.labels = [], this.outputs = [];
            for (const [l, p] of s) this.labels.push(l), this.outputs.push(p);
          }
          static parse(t, i) {
            if (t.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
            const s = i.parse(t[1], 1, qe);
            if (!s) return null;
            const l = [];
            let p = null;
            i.expectedType && i.expectedType.kind !== "value" && (p = i.expectedType);
            for (let f = 1; f < t.length; f += 2) {
              const _ = f === 1 ? -1 / 0 : t[f], y = t[f + 1], w = f, P = f + 1;
              if (typeof _ != "number") return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', w);
              if (l.length && l[l.length - 1][0] >= _) return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', w);
              const I = i.parse(y, P, p);
              if (!I) return null;
              p = p || I.type, l.push([_, I]);
            }
            return new Si(p, s, l);
          }
          evaluate(t) {
            const i = this.labels, s = this.outputs;
            if (i.length === 1) return s[0].evaluate(t);
            const l = this.input.evaluate(t);
            if (l <= i[0]) return s[0].evaluate(t);
            const p = i.length;
            return l >= i[p - 1] ? s[p - 1].evaluate(t) : s[_s(i, l)].evaluate(t);
          }
          eachChild(t) {
            t(this.input);
            for (const i of this.outputs) t(i);
          }
          outputDefined() {
            return this.outputs.every((t) => t.outputDefined());
          }
        }
        function pu(r) {
          return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
        }
        var ko, Nl, od = function() {
          if (Nl) return ko;
          function r(t, i, s, l) {
            this.cx = 3 * t, this.bx = 3 * (s - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (l - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = i, this.p2x = s, this.p2y = l;
          }
          return Nl = 1, ko = r, r.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, i) {
            if (i === void 0 && (i = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var s = t, l = 0; l < 8; l++) {
              var p = this.sampleCurveX(s) - t;
              if (Math.abs(p) < i) return s;
              var f = this.sampleCurveDerivativeX(s);
              if (Math.abs(f) < 1e-6) break;
              s -= p / f;
            }
            var _ = 0, y = 1;
            for (s = t, l = 0; l < 20 && (p = this.sampleCurveX(s), !(Math.abs(p - t) < i)); l++) t > p ? _ = s : y = s, s = 0.5 * (y - _) + _;
            return s;
          }, solve: function(t, i) {
            return this.sampleCurveY(this.solveCurveX(t, i));
          } }, ko;
        }(), Ks = pu(od);
        class nr {
          constructor(t, i, s, l, p) {
            this.type = t, this.operator = i, this.interpolation = s, this.input = l, this.labels = [], this.outputs = [];
            for (const [f, _] of p) this.labels.push(f), this.outputs.push(_);
          }
          static interpolationFactor(t, i, s, l) {
            let p = 0;
            if (t.name === "exponential") p = zo(i, t.base, s, l);
            else if (t.name === "linear") p = zo(i, 1, s, l);
            else if (t.name === "cubic-bezier") {
              const f = t.controlPoints;
              p = new Ks(f[0], f[1], f[2], f[3]).solve(zo(i, 1, s, l));
            }
            return p;
          }
          static parse(t, i) {
            let [s, l, p, ...f] = t;
            if (!Array.isArray(l) || l.length === 0) return i.error("Expected an interpolation type expression.", 1);
            if (l[0] === "linear") l = { name: "linear" };
            else if (l[0] === "exponential") {
              const w = l[1];
              if (typeof w != "number") return i.error("Exponential interpolation requires a numeric base.", 1, 1);
              l = { name: "exponential", base: w };
            } else {
              if (l[0] !== "cubic-bezier") return i.error(`Unknown interpolation type ${String(l[0])}`, 1, 0);
              {
                const w = l.slice(1);
                if (w.length !== 4 || w.some((P) => typeof P != "number" || P < 0 || P > 1)) return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                l = { name: "cubic-bezier", controlPoints: w };
              }
            }
            if (t.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
            if (p = i.parse(p, 2, qe), !p) return null;
            const _ = [];
            let y = null;
            s !== "interpolate-hcl" && s !== "interpolate-lab" || i.expectedType == xn ? i.expectedType && i.expectedType.kind !== "value" && (y = i.expectedType) : y = rr;
            for (let w = 0; w < f.length; w += 2) {
              const P = f[w], I = f[w + 1], z = w + 3, L = w + 4;
              if (typeof P != "number") return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', z);
              if (_.length && _[_.length - 1][0] >= P) return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', z);
              const F = i.parse(I, L, y);
              if (!F) return null;
              y = y || F.type, _.push([P, F]);
            }
            return qn(y, qe) || qn(y, ds) || qn(y, rr) || qn(y, xa) || qn(y, Us) || qn(y, xn) || qn(y, ba) || qn(y, Cr(qe)) ? new nr(y, s, l, p, _) : i.error(`Type ${si(y)} is not interpolatable.`);
          }
          evaluate(t) {
            const i = this.labels, s = this.outputs;
            if (i.length === 1) return s[0].evaluate(t);
            const l = this.input.evaluate(t);
            if (l <= i[0]) return s[0].evaluate(t);
            const p = i.length;
            if (l >= i[p - 1]) return s[p - 1].evaluate(t);
            const f = _s(i, l), _ = nr.interpolationFactor(this.interpolation, l, i[f], i[f + 1]), y = s[f].evaluate(t), w = s[f + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return In(y, w, _);
                  case "color":
                    return Bt.interpolate(y, w, _);
                  case "padding":
                    return qi.interpolate(y, w, _);
                  case "colorArray":
                    return Di.interpolate(y, w, _);
                  case "numberArray":
                    return vr.interpolate(y, w, _);
                  case "variableAnchorOffsetCollection":
                    return xr.interpolate(y, w, _);
                  case "array":
                    return fs(y, w, _);
                  case "projectionDefinition":
                    return dr.interpolate(y, w, _);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return Bt.interpolate(y, w, _, "hcl");
                  case "colorArray":
                    return Di.interpolate(y, w, _, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return Bt.interpolate(y, w, _, "lab");
                  case "colorArray":
                    return Di.interpolate(y, w, _, "lab");
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const i of this.outputs) t(i);
          }
          outputDefined() {
            return this.outputs.every((t) => t.outputDefined());
          }
        }
        function zo(r, t, i, s) {
          const l = s - i, p = r - i;
          return l === 0 ? 0 : t === 1 ? p / l : (Math.pow(t, p) - 1) / (Math.pow(t, l) - 1);
        }
        const Tn = { color: Bt.interpolate, number: In, padding: qi.interpolate, numberArray: vr.interpolate, colorArray: Di.interpolate, variableAnchorOffsetCollection: xr.interpolate, array: fs };
        class Ro {
          constructor(t, i) {
            this.type = t, this.args = i;
          }
          static parse(t, i) {
            if (t.length < 2) return i.error("Expected at least one argument.");
            let s = null;
            const l = i.expectedType;
            l && l.kind !== "value" && (s = l);
            const p = [];
            for (const _ of t.slice(1)) {
              const y = i.parse(_, 1 + p.length, s, void 0, { typeAnnotation: "omit" });
              if (!y) return null;
              s = s || y.type, p.push(y);
            }
            if (!s) throw new Error("No output type");
            const f = l && p.some((_) => Co(l, _.type));
            return new Ro(f ? Mt : s, p);
          }
          evaluate(t) {
            let i, s = null, l = 0;
            for (const p of this.args) if (l++, s = p.evaluate(t), s && s instanceof Lr && !s.available && (i || (i = s.name), s = null, l === this.args.length && (s = i)), s !== null) break;
            return s;
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every((t) => t.outputDefined());
          }
        }
        function Do(r, t) {
          return r === "==" || r === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
        }
        function Lo(r, t, i, s) {
          return s.compare(t, i) === 0;
        }
        function pr(r, t, i) {
          const s = r !== "==" && r !== "!=";
          return class q_ {
            constructor(p, f, _) {
              this.type = kt, this.lhs = p, this.rhs = f, this.collator = _, this.hasUntypedArgument = p.type.kind === "value" || f.type.kind === "value";
            }
            static parse(p, f) {
              if (p.length !== 3 && p.length !== 4) return f.error("Expected two or three arguments.");
              const _ = p[0];
              let y = f.parse(p[1], 1, Mt);
              if (!y) return null;
              if (!Do(_, y.type)) return f.concat(1).error(`"${_}" comparisons are not supported for type '${si(y.type)}'.`);
              let w = f.parse(p[2], 2, Mt);
              if (!w) return null;
              if (!Do(_, w.type)) return f.concat(2).error(`"${_}" comparisons are not supported for type '${si(w.type)}'.`);
              if (y.type.kind !== w.type.kind && y.type.kind !== "value" && w.type.kind !== "value") return f.error(`Cannot compare types '${si(y.type)}' and '${si(w.type)}'.`);
              s && (y.type.kind === "value" && w.type.kind !== "value" ? y = new Fr(w.type, [y]) : y.type.kind !== "value" && w.type.kind === "value" && (w = new Fr(y.type, [w])));
              let P = null;
              if (p.length === 4) {
                if (y.type.kind !== "string" && w.type.kind !== "string" && y.type.kind !== "value" && w.type.kind !== "value") return f.error("Cannot use collator to compare non-string types.");
                if (P = f.parse(p[3], 3, va), !P) return null;
              }
              return new q_(y, w, P);
            }
            evaluate(p) {
              const f = this.lhs.evaluate(p), _ = this.rhs.evaluate(p);
              if (s && this.hasUntypedArgument) {
                const y = ft(f), w = ft(_);
                if (y.kind !== w.kind || y.kind !== "string" && y.kind !== "number") throw new oi(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${y.kind}, ${w.kind}) instead.`);
              }
              if (this.collator && !s && this.hasUntypedArgument) {
                const y = ft(f), w = ft(_);
                if (y.kind !== "string" || w.kind !== "string") return t(p, f, _);
              }
              return this.collator ? i(p, f, _, this.collator.evaluate(p)) : t(p, f, _);
            }
            eachChild(p) {
              p(this.lhs), p(this.rhs), this.collator && p(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        const fu = pr("==", function(r, t, i) {
          return t === i;
        }, Lo), Ia = pr("!=", function(r, t, i) {
          return t !== i;
        }, function(r, t, i, s) {
          return !Lo(0, t, i, s);
        }), ad = pr("<", function(r, t, i) {
          return t < i;
        }, function(r, t, i, s) {
          return s.compare(t, i) < 0;
        }), $l = pr(">", function(r, t, i) {
          return t > i;
        }, function(r, t, i, s) {
          return s.compare(t, i) > 0;
        }), ld = pr("<=", function(r, t, i) {
          return t <= i;
        }, function(r, t, i, s) {
          return s.compare(t, i) <= 0;
        }), cd = pr(">=", function(r, t, i) {
          return t >= i;
        }, function(r, t, i, s) {
          return s.compare(t, i) >= 0;
        });
        class Ea {
          constructor(t, i, s) {
            this.type = va, this.locale = s, this.caseSensitive = t, this.diacriticSensitive = i;
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error("Expected one argument.");
            const s = t[1];
            if (typeof s != "object" || Array.isArray(s)) return i.error("Collator options argument must be an object.");
            const l = i.parse(s["case-sensitive"] !== void 0 && s["case-sensitive"], 1, kt);
            if (!l) return null;
            const p = i.parse(s["diacritic-sensitive"] !== void 0 && s["diacritic-sensitive"], 1, kt);
            if (!p) return null;
            let f = null;
            return s.locale && (f = i.parse(s.locale, 1, Lt), !f) ? null : new Ea(l, p, f);
          }
          evaluate(t) {
            return new ms(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        class Ul {
          constructor(t, i, s, l, p) {
            this.type = Lt, this.number = t, this.locale = i, this.currency = s, this.minFractionDigits = l, this.maxFractionDigits = p;
          }
          static parse(t, i) {
            if (t.length !== 3) return i.error("Expected two arguments.");
            const s = i.parse(t[1], 1, qe);
            if (!s) return null;
            const l = t[2];
            if (typeof l != "object" || Array.isArray(l)) return i.error("NumberFormat options argument must be an object.");
            let p = null;
            if (l.locale && (p = i.parse(l.locale, 1, Lt), !p)) return null;
            let f = null;
            if (l.currency && (f = i.parse(l.currency, 1, Lt), !f)) return null;
            let _ = null;
            if (l["min-fraction-digits"] && (_ = i.parse(l["min-fraction-digits"], 1, qe), !_)) return null;
            let y = null;
            return l["max-fraction-digits"] && (y = i.parse(l["max-fraction-digits"], 1, qe), !y) ? null : new Ul(s, p, f, _, y);
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
        }
        class ys {
          constructor(t) {
            this.type = Zn, this.sections = t;
          }
          static parse(t, i) {
            if (t.length < 2) return i.error("Expected at least one argument.");
            const s = t[1];
            if (!Array.isArray(s) && typeof s == "object") return i.error("First argument must be an image or text section.");
            const l = [];
            let p = !1;
            for (let f = 1; f <= t.length - 1; ++f) {
              const _ = t[f];
              if (p && typeof _ == "object" && !Array.isArray(_)) {
                p = !1;
                let y = null;
                if (_["font-scale"] && (y = i.parse(_["font-scale"], 1, qe), !y)) return null;
                let w = null;
                if (_["text-font"] && (w = i.parse(_["text-font"], 1, Cr(Lt)), !w)) return null;
                let P = null;
                if (_["text-color"] && (P = i.parse(_["text-color"], 1, rr), !P)) return null;
                let I = null;
                if (_["vertical-align"]) {
                  if (typeof _["vertical-align"] == "string" && !wa.includes(_["vertical-align"])) return i.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${_["vertical-align"]}' instead.`);
                  if (I = i.parse(_["vertical-align"], 1, Lt), !I) return null;
                }
                const z = l[l.length - 1];
                z.scale = y, z.font = w, z.textColor = P, z.verticalAlign = I;
              } else {
                const y = i.parse(t[f], 1, Mt);
                if (!y) return null;
                const w = y.type.kind;
                if (w !== "string" && w !== "value" && w !== "null" && w !== "resolvedImage") return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                p = !0, l.push({ content: y, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new ys(l);
          }
          evaluate(t) {
            return new yr(this.sections.map((i) => {
              const s = i.content.evaluate(t);
              return ft(s) === Ti ? new Ta("", s, null, null, null, i.verticalAlign ? i.verticalAlign.evaluate(t) : null) : new Ta(Tt(s), null, i.scale ? i.scale.evaluate(t) : null, i.font ? i.font.evaluate(t).join(",") : null, i.textColor ? i.textColor.evaluate(t) : null, i.verticalAlign ? i.verticalAlign.evaluate(t) : null);
            }));
          }
          eachChild(t) {
            for (const i of this.sections) t(i.content), i.scale && t(i.scale), i.font && t(i.font), i.textColor && t(i.textColor), i.verticalAlign && t(i.verticalAlign);
          }
          outputDefined() {
            return !1;
          }
        }
        class Zl {
          constructor(t) {
            this.type = Ti, this.input = t;
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error("Expected two arguments.");
            const s = i.parse(t[1], 1, Lt);
            return s ? new Zl(s) : i.error("No image name provided.");
          }
          evaluate(t) {
            const i = this.input.evaluate(t), s = Lr.fromString(i);
            return s && t.availableImages && (s.available = t.availableImages.indexOf(i) > -1), s;
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class Aa {
          constructor(t) {
            this.type = qe, this.input = t;
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const s = i.parse(t[1], 1);
            return s ? s.type.kind !== "array" && s.type.kind !== "string" && s.type.kind !== "value" ? i.error(`Expected argument of type string or array, but found ${si(s.type)} instead.`) : new Aa(s) : null;
          }
          evaluate(t) {
            const i = this.input.evaluate(t);
            if (typeof i == "string") return [...i].length;
            if (Array.isArray(i)) return i.length;
            throw new oi(`Expected value to be of type string or array, but found ${si(ft(i))} instead.`);
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        const rn = 8192;
        function ud(r, t) {
          const i = (180 + r[0]) / 360, s = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r[1] * Math.PI / 360))) / 360, l = Math.pow(2, t.z);
          return [Math.round(i * l * rn), Math.round(s * l * rn)];
        }
        function ka(r, t) {
          const i = Math.pow(2, t.z);
          return [(l = (r[0] / rn + t.x) / i, 360 * l - 180), (s = (r[1] / rn + t.y) / i, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * s) * Math.PI / 180)) - 90)];
          var s, l;
        }
        function Fo(r, t) {
          r[0] = Math.min(r[0], t[0]), r[1] = Math.min(r[1], t[1]), r[2] = Math.max(r[2], t[0]), r[3] = Math.max(r[3], t[1]);
        }
        function Bo(r, t) {
          return !(r[0] <= t[0] || r[2] >= t[2] || r[1] <= t[1] || r[3] >= t[3]);
        }
        function hd(r, t, i) {
          const s = r[0] - t[0], l = r[1] - t[1], p = r[0] - i[0], f = r[1] - i[1];
          return s * f - p * l == 0 && s * p <= 0 && l * f <= 0;
        }
        function za(r, t, i, s) {
          return (l = [s[0] - i[0], s[1] - i[1]])[0] * (p = [t[0] - r[0], t[1] - r[1]])[1] - l[1] * p[0] != 0 && !(!gu(r, t, i, s) || !gu(i, s, r, t));
          var l, p;
        }
        function dd(r, t, i) {
          for (const s of i) for (let l = 0; l < s.length - 1; ++l) if (za(r, t, s[l], s[l + 1])) return !0;
          return !1;
        }
        function vs(r, t, i = !1) {
          let s = !1;
          for (const _ of t) for (let y = 0; y < _.length - 1; y++) {
            if (hd(r, _[y], _[y + 1])) return i;
            (p = _[y])[1] > (l = r)[1] != (f = _[y + 1])[1] > l[1] && l[0] < (f[0] - p[0]) * (l[1] - p[1]) / (f[1] - p[1]) + p[0] && (s = !s);
          }
          var l, p, f;
          return s;
        }
        function mu(r, t) {
          for (const i of t) if (vs(r, i)) return !0;
          return !1;
        }
        function Gl(r, t) {
          for (const i of r) if (!vs(i, t)) return !1;
          for (let i = 0; i < r.length - 1; ++i) if (dd(r[i], r[i + 1], t)) return !1;
          return !0;
        }
        function pd(r, t) {
          for (const i of t) if (Gl(r, i)) return !0;
          return !1;
        }
        function gu(r, t, i, s) {
          const l = s[0] - i[0], p = s[1] - i[1], f = (r[0] - i[0]) * p - l * (r[1] - i[1]), _ = (t[0] - i[0]) * p - l * (t[1] - i[1]);
          return f > 0 && _ < 0 || f < 0 && _ > 0;
        }
        function ql(r, t, i) {
          const s = [];
          for (let l = 0; l < r.length; l++) {
            const p = [];
            for (let f = 0; f < r[l].length; f++) {
              const _ = ud(r[l][f], i);
              Fo(t, _), p.push(_);
            }
            s.push(p);
          }
          return s;
        }
        function _u(r, t, i) {
          const s = [];
          for (let l = 0; l < r.length; l++) {
            const p = ql(r[l], t, i);
            s.push(p);
          }
          return s;
        }
        function Ra(r, t, i, s) {
          if (r[0] < i[0] || r[0] > i[2]) {
            const l = 0.5 * s;
            let p = r[0] - i[0] > l ? -s : i[0] - r[0] > l ? s : 0;
            p === 0 && (p = r[0] - i[2] > l ? -s : i[2] - r[0] > l ? s : 0), r[0] += p;
          }
          Fo(t, r);
        }
        function yu(r, t, i, s) {
          const l = Math.pow(2, s.z) * rn, p = [s.x * rn, s.y * rn], f = [];
          for (const _ of r) for (const y of _) {
            const w = [y.x + p[0], y.y + p[1]];
            Ra(w, t, i, l), f.push(w);
          }
          return f;
        }
        function vu(r, t, i, s) {
          const l = Math.pow(2, s.z) * rn, p = [s.x * rn, s.y * rn], f = [];
          for (const y of r) {
            const w = [];
            for (const P of y) {
              const I = [P.x + p[0], P.y + p[1]];
              Fo(t, I), w.push(I);
            }
            f.push(w);
          }
          if (t[2] - t[0] <= l / 2) {
            (_ = t)[0] = _[1] = 1 / 0, _[2] = _[3] = -1 / 0;
            for (const y of f) for (const w of y) Ra(w, t, i, l);
          }
          var _;
          return f;
        }
        class xs {
          constructor(t, i) {
            this.type = kt, this.geojson = t, this.geometries = i;
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (gs(t[1])) {
              const s = t[1];
              if (s.type === "FeatureCollection") {
                const l = [];
                for (const p of s.features) {
                  const { type: f, coordinates: _ } = p.geometry;
                  f === "Polygon" && l.push(_), f === "MultiPolygon" && l.push(..._);
                }
                if (l.length) return new xs(s, { type: "MultiPolygon", coordinates: l });
              } else if (s.type === "Feature") {
                const l = s.geometry.type;
                if (l === "Polygon" || l === "MultiPolygon") return new xs(s, s.geometry);
              } else if (s.type === "Polygon" || s.type === "MultiPolygon") return new xs(s, s);
            }
            return i.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return function(i, s) {
                const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = i.canonicalID();
                if (s.type === "Polygon") {
                  const _ = ql(s.coordinates, p, f), y = yu(i.geometry(), l, p, f);
                  if (!Bo(l, p)) return !1;
                  for (const w of y) if (!vs(w, _)) return !1;
                }
                if (s.type === "MultiPolygon") {
                  const _ = _u(s.coordinates, p, f), y = yu(i.geometry(), l, p, f);
                  if (!Bo(l, p)) return !1;
                  for (const w of y) if (!mu(w, _)) return !1;
                }
                return !0;
              }(t, this.geometries);
              if (t.geometryType() === "LineString") return function(i, s) {
                const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = i.canonicalID();
                if (s.type === "Polygon") {
                  const _ = ql(s.coordinates, p, f), y = vu(i.geometry(), l, p, f);
                  if (!Bo(l, p)) return !1;
                  for (const w of y) if (!Gl(w, _)) return !1;
                }
                if (s.type === "MultiPolygon") {
                  const _ = _u(s.coordinates, p, f), y = vu(i.geometry(), l, p, f);
                  if (!Bo(l, p)) return !1;
                  for (const w of y) if (!pd(w, _)) return !1;
                }
                return !0;
              }(t, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        let Hl = class {
          constructor(r = [], t = (i, s) => i < s ? -1 : i > s ? 1 : 0) {
            if (this.data = r, this.length = this.data.length, this.compare = t, this.length > 0) for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
          }
          push(r) {
            this.data.push(r), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const r = this.data[0], t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), r;
          }
          peek() {
            return this.data[0];
          }
          _up(r) {
            const { data: t, compare: i } = this, s = t[r];
            for (; r > 0; ) {
              const l = r - 1 >> 1, p = t[l];
              if (i(s, p) >= 0) break;
              t[r] = p, r = l;
            }
            t[r] = s;
          }
          _down(r) {
            const { data: t, compare: i } = this, s = this.length >> 1, l = t[r];
            for (; r < s; ) {
              let p = 1 + (r << 1);
              const f = p + 1;
              if (f < this.length && i(t[f], t[p]) < 0 && (p = f), i(t[p], l) >= 0) break;
              t[r] = t[p], r = p;
            }
            t[r] = l;
          }
        };
        function Wl(r, t, i = 0, s = r.length - 1, l = fd) {
          for (; s > i; ) {
            if (s - i > 600) {
              const y = s - i + 1, w = t - i + 1, P = Math.log(y), I = 0.5 * Math.exp(2 * P / 3), z = 0.5 * Math.sqrt(P * I * (y - I) / y) * (w - y / 2 < 0 ? -1 : 1);
              Wl(r, t, Math.max(i, Math.floor(t - w * I / y + z)), Math.min(s, Math.floor(t + (y - w) * I / y + z)), l);
            }
            const p = r[t];
            let f = i, _ = s;
            for (Oo(r, i, t), l(r[s], p) > 0 && Oo(r, i, s); f < _; ) {
              for (Oo(r, f, _), f++, _--; l(r[f], p) < 0; ) f++;
              for (; l(r[_], p) > 0; ) _--;
            }
            l(r[i], p) === 0 ? Oo(r, i, _) : (_++, Oo(r, _, s)), _ <= t && (i = _ + 1), t <= _ && (s = _ - 1);
          }
        }
        function Oo(r, t, i) {
          const s = r[t];
          r[t] = r[i], r[i] = s;
        }
        function fd(r, t) {
          return r < t ? -1 : r > t ? 1 : 0;
        }
        function jo(r, t) {
          if (r.length <= 1) return [r];
          const i = [];
          let s, l;
          for (const p of r) {
            const f = md(p);
            f !== 0 && (p.area = Math.abs(f), l === void 0 && (l = f < 0), l === f < 0 ? (s && i.push(s), s = [p]) : s.push(p));
          }
          if (s && i.push(s), t > 1) for (let p = 0; p < i.length; p++) i[p].length <= t || (Wl(i[p], t, 1, i[p].length - 1, xu), i[p] = i[p].slice(0, t));
          return i;
        }
        function xu(r, t) {
          return t.area - r.area;
        }
        function md(r) {
          let t = 0;
          for (let i, s, l = 0, p = r.length, f = p - 1; l < p; f = l++) i = r[l], s = r[f], t += (s.x - i.x) * (i.y + s.y);
          return t;
        }
        const bu = 1 / 298.257223563, wu = bu * (2 - bu), Xl = Math.PI / 180;
        class Kl {
          constructor(t) {
            const i = 6378.137 * Xl * 1e3, s = Math.cos(t * Xl), l = 1 / (1 - wu * (1 - s * s)), p = Math.sqrt(l);
            this.kx = i * p * s, this.ky = i * p * l * (1 - wu);
          }
          distance(t, i) {
            const s = this.wrap(t[0] - i[0]) * this.kx, l = (t[1] - i[1]) * this.ky;
            return Math.sqrt(s * s + l * l);
          }
          pointOnLine(t, i) {
            let s, l, p, f, _ = 1 / 0;
            for (let y = 0; y < t.length - 1; y++) {
              let w = t[y][0], P = t[y][1], I = this.wrap(t[y + 1][0] - w) * this.kx, z = (t[y + 1][1] - P) * this.ky, L = 0;
              I === 0 && z === 0 || (L = (this.wrap(i[0] - w) * this.kx * I + (i[1] - P) * this.ky * z) / (I * I + z * z), L > 1 ? (w = t[y + 1][0], P = t[y + 1][1]) : L > 0 && (w += I / this.kx * L, P += z / this.ky * L)), I = this.wrap(i[0] - w) * this.kx, z = (i[1] - P) * this.ky;
              const F = I * I + z * z;
              F < _ && (_ = F, s = w, l = P, p = y, f = L);
            }
            return { point: [s, l], index: p, t: Math.max(0, Math.min(1, f)) };
          }
          wrap(t) {
            for (; t < -180; ) t += 360;
            for (; t > 180; ) t -= 360;
            return t;
          }
        }
        function Tu(r, t) {
          return t[0] - r[0];
        }
        function Da(r) {
          return r[1] - r[0] + 1;
        }
        function An(r, t) {
          return r[1] >= r[0] && r[1] < t;
        }
        function Xt(r, t) {
          if (r[0] > r[1]) return [null, null];
          const i = Da(r);
          if (t) {
            if (i === 2) return [r, null];
            const l = Math.floor(i / 2);
            return [[r[0], r[0] + l], [r[0] + l, r[1]]];
          }
          if (i === 1) return [r, null];
          const s = Math.floor(i / 2) - 1;
          return [[r[0], r[0] + s], [r[0] + s + 1, r[1]]];
        }
        function Yl(r, t) {
          if (!An(t, r.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let s = t[0]; s <= t[1]; ++s) Fo(i, r[s]);
          return i;
        }
        function Jl(r) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const i of r) for (const s of i) Fo(t, s);
          return t;
        }
        function Su(r) {
          return r[0] !== -1 / 0 && r[1] !== -1 / 0 && r[2] !== 1 / 0 && r[3] !== 1 / 0;
        }
        function Ql(r, t, i) {
          if (!Su(r) || !Su(t)) return NaN;
          let s = 0, l = 0;
          return r[2] < t[0] && (s = t[0] - r[2]), r[0] > t[2] && (s = r[0] - t[2]), r[1] > t[3] && (l = r[1] - t[3]), r[3] < t[1] && (l = t[1] - r[3]), i.distance([0, 0], [s, l]);
        }
        function bs(r, t, i) {
          const s = i.pointOnLine(t, r);
          return i.distance(r, s.point);
        }
        function ec(r, t, i, s, l) {
          const p = Math.min(bs(r, [i, s], l), bs(t, [i, s], l)), f = Math.min(bs(i, [r, t], l), bs(s, [r, t], l));
          return Math.min(p, f);
        }
        function gd(r, t, i, s, l) {
          if (!An(t, r.length) || !An(s, i.length)) return 1 / 0;
          let p = 1 / 0;
          for (let f = t[0]; f < t[1]; ++f) {
            const _ = r[f], y = r[f + 1];
            for (let w = s[0]; w < s[1]; ++w) {
              const P = i[w], I = i[w + 1];
              if (za(_, y, P, I)) return 0;
              p = Math.min(p, ec(_, y, P, I, l));
            }
          }
          return p;
        }
        function _d(r, t, i, s, l) {
          if (!An(t, r.length) || !An(s, i.length)) return NaN;
          let p = 1 / 0;
          for (let f = t[0]; f <= t[1]; ++f) for (let _ = s[0]; _ <= s[1]; ++_) if (p = Math.min(p, l.distance(r[f], i[_])), p === 0) return p;
          return p;
        }
        function yd(r, t, i) {
          if (vs(r, t, !0)) return 0;
          let s = 1 / 0;
          for (const l of t) {
            const p = l[0], f = l[l.length - 1];
            if (p !== f && (s = Math.min(s, bs(r, [f, p], i)), s === 0)) return s;
            const _ = i.pointOnLine(l, r);
            if (s = Math.min(s, i.distance(r, _.point)), s === 0) return s;
          }
          return s;
        }
        function vd(r, t, i, s) {
          if (!An(t, r.length)) return NaN;
          for (let p = t[0]; p <= t[1]; ++p) if (vs(r[p], i, !0)) return 0;
          let l = 1 / 0;
          for (let p = t[0]; p < t[1]; ++p) {
            const f = r[p], _ = r[p + 1];
            for (const y of i) for (let w = 0, P = y.length, I = P - 1; w < P; I = w++) {
              const z = y[I], L = y[w];
              if (za(f, _, z, L)) return 0;
              l = Math.min(l, ec(f, _, z, L, s));
            }
          }
          return l;
        }
        function Pu(r, t) {
          for (const i of r) for (const s of i) if (vs(s, t, !0)) return !0;
          return !1;
        }
        function xd(r, t, i, s = 1 / 0) {
          const l = Jl(r), p = Jl(t);
          if (s !== 1 / 0 && Ql(l, p, i) >= s) return s;
          if (Bo(l, p)) {
            if (Pu(r, t)) return 0;
          } else if (Pu(t, r)) return 0;
          let f = 1 / 0;
          for (const _ of r) for (let y = 0, w = _.length, P = w - 1; y < w; P = y++) {
            const I = _[P], z = _[y];
            for (const L of t) for (let F = 0, V = L.length, $ = V - 1; F < V; $ = F++) {
              const H = L[$], he = L[F];
              if (za(I, z, H, he)) return 0;
              f = Math.min(f, ec(I, z, H, he, i));
            }
          }
          return f;
        }
        function Mu(r, t, i, s, l, p) {
          if (!p) return;
          const f = Ql(Yl(s, p), l, i);
          f < t && r.push([f, p, [0, 0]]);
        }
        function La(r, t, i, s, l, p, f) {
          if (!p || !f) return;
          const _ = Ql(Yl(s, p), Yl(l, f), i);
          _ < t && r.push([_, p, f]);
        }
        function Fa(r, t, i, s, l = 1 / 0) {
          let p = Math.min(s.distance(r[0], i[0][0]), l);
          if (p === 0) return p;
          const f = new Hl([[0, [0, r.length - 1], [0, 0]]], Tu), _ = Jl(i);
          for (; f.length > 0; ) {
            const y = f.pop();
            if (y[0] >= p) continue;
            const w = y[1], P = t ? 50 : 100;
            if (Da(w) <= P) {
              if (!An(w, r.length)) return NaN;
              if (t) {
                const I = vd(r, w, i, s);
                if (isNaN(I) || I === 0) return I;
                p = Math.min(p, I);
              } else for (let I = w[0]; I <= w[1]; ++I) {
                const z = yd(r[I], i, s);
                if (p = Math.min(p, z), p === 0) return 0;
              }
            } else {
              const I = Xt(w, t);
              Mu(f, p, s, r, _, I[0]), Mu(f, p, s, r, _, I[1]);
            }
          }
          return p;
        }
        function Ba(r, t, i, s, l, p = 1 / 0) {
          let f = Math.min(p, l.distance(r[0], i[0]));
          if (f === 0) return f;
          const _ = new Hl([[0, [0, r.length - 1], [0, i.length - 1]]], Tu);
          for (; _.length > 0; ) {
            const y = _.pop();
            if (y[0] >= f) continue;
            const w = y[1], P = y[2], I = t ? 50 : 100, z = s ? 50 : 100;
            if (Da(w) <= I && Da(P) <= z) {
              if (!An(w, r.length) && An(P, i.length)) return NaN;
              let L;
              if (t && s) L = gd(r, w, i, P, l), f = Math.min(f, L);
              else if (t && !s) {
                const F = r.slice(w[0], w[1] + 1);
                for (let V = P[0]; V <= P[1]; ++V) if (L = bs(i[V], F, l), f = Math.min(f, L), f === 0) return f;
              } else if (!t && s) {
                const F = i.slice(P[0], P[1] + 1);
                for (let V = w[0]; V <= w[1]; ++V) if (L = bs(r[V], F, l), f = Math.min(f, L), f === 0) return f;
              } else L = _d(r, w, i, P, l), f = Math.min(f, L);
            } else {
              const L = Xt(w, t), F = Xt(P, s);
              La(_, f, l, r, i, L[0], F[0]), La(_, f, l, r, i, L[0], F[1]), La(_, f, l, r, i, L[1], F[0]), La(_, f, l, r, i, L[1], F[1]);
            }
          }
          return f;
        }
        function tc(r) {
          return r.type === "MultiPolygon" ? r.coordinates.map((t) => ({ type: "Polygon", coordinates: t })) : r.type === "MultiLineString" ? r.coordinates.map((t) => ({ type: "LineString", coordinates: t })) : r.type === "MultiPoint" ? r.coordinates.map((t) => ({ type: "Point", coordinates: t })) : [r];
        }
        class ws {
          constructor(t, i) {
            this.type = qe, this.geojson = t, this.geometries = i;
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (gs(t[1])) {
              const s = t[1];
              if (s.type === "FeatureCollection") return new ws(s, s.features.map((l) => tc(l.geometry)).flat());
              if (s.type === "Feature") return new ws(s, tc(s.geometry));
              if ("type" in s && "coordinates" in s) return new ws(s, tc(s));
            }
            return i.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return function(i, s) {
                const l = i.geometry(), p = l.flat().map((y) => ka([y.x, y.y], i.canonical));
                if (l.length === 0) return NaN;
                const f = new Kl(p[0][1]);
                let _ = 1 / 0;
                for (const y of s) {
                  switch (y.type) {
                    case "Point":
                      _ = Math.min(_, Ba(p, !1, [y.coordinates], !1, f, _));
                      break;
                    case "LineString":
                      _ = Math.min(_, Ba(p, !1, y.coordinates, !0, f, _));
                      break;
                    case "Polygon":
                      _ = Math.min(_, Fa(p, !1, y.coordinates, f, _));
                  }
                  if (_ === 0) return _;
                }
                return _;
              }(t, this.geometries);
              if (t.geometryType() === "LineString") return function(i, s) {
                const l = i.geometry(), p = l.flat().map((y) => ka([y.x, y.y], i.canonical));
                if (l.length === 0) return NaN;
                const f = new Kl(p[0][1]);
                let _ = 1 / 0;
                for (const y of s) {
                  switch (y.type) {
                    case "Point":
                      _ = Math.min(_, Ba(p, !0, [y.coordinates], !1, f, _));
                      break;
                    case "LineString":
                      _ = Math.min(_, Ba(p, !0, y.coordinates, !0, f, _));
                      break;
                    case "Polygon":
                      _ = Math.min(_, Fa(p, !0, y.coordinates, f, _));
                  }
                  if (_ === 0) return _;
                }
                return _;
              }(t, this.geometries);
              if (t.geometryType() === "Polygon") return function(i, s) {
                const l = i.geometry();
                if (l.length === 0 || l[0].length === 0) return NaN;
                const p = jo(l, 0).map((y) => y.map((w) => w.map((P) => ka([P.x, P.y], i.canonical)))), f = new Kl(p[0][0][0][1]);
                let _ = 1 / 0;
                for (const y of s) for (const w of p) {
                  switch (y.type) {
                    case "Point":
                      _ = Math.min(_, Fa([y.coordinates], !1, w, f, _));
                      break;
                    case "LineString":
                      _ = Math.min(_, Fa(y.coordinates, !0, w, f, _));
                      break;
                    case "Polygon":
                      _ = Math.min(_, xd(w, y.coordinates, f, _));
                  }
                  if (_ === 0) return _;
                }
                return _;
              }(t, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        class Vo {
          constructor(t) {
            this.type = Mt, this.key = t;
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const s = t[1];
            return s == null ? i.error("Global state property must be defined.") : typeof s != "string" ? i.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Vo(s);
          }
          evaluate(t) {
            var i;
            const s = (i = t.globals) === null || i === void 0 ? void 0 : i.globalState;
            return s && Object.keys(s).length !== 0 ? Hs(s, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        const Ys = { "==": fu, "!=": Ia, ">": $l, "<": ad, ">=": cd, "<=": ld, array: Fr, at: Ma, boolean: Fr, case: Xs, coalesce: Ro, collator: Ea, format: ys, image: Zl, in: Ca, "index-of": tn, interpolate: nr, "interpolate-hcl": nr, "interpolate-lab": nr, length: Aa, let: Eo, literal: En, match: Hi, number: Fr, "number-format": Ul, object: Fr, slice: Ao, step: Si, string: Fr, "to-boolean": wn, "to-color": wn, "to-number": wn, "to-string": wn, var: Pa, within: xs, distance: ws, "global-state": Vo };
        class Wr {
          constructor(t, i, s, l) {
            this.name = t, this.type = i, this._evaluate = s, this.args = l;
          }
          evaluate(t) {
            return this._evaluate(t, this.args);
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return !1;
          }
          static parse(t, i) {
            const s = t[0], l = Wr.definitions[s];
            if (!l) return i.error(`Unknown expression "${s}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const p = Array.isArray(l) ? l[0] : l.type, f = Array.isArray(l) ? [[l[1], l[2]]] : l.overloads, _ = f.filter(([w]) => !Array.isArray(w) || w.length === t.length - 1);
            let y = null;
            for (const [w, P] of _) {
              y = new Ws(i.registry, Oa, i.path, null, i.scope);
              const I = [];
              let z = !1;
              for (let L = 1; L < t.length; L++) {
                const F = t[L], V = Array.isArray(w) ? w[L - 1] : w.type, $ = y.parse(F, 1 + I.length, V);
                if (!$) {
                  z = !0;
                  break;
                }
                I.push($);
              }
              if (!z) if (Array.isArray(w) && w.length !== I.length) y.error(`Expected ${w.length} arguments, but found ${I.length} instead.`);
              else {
                for (let L = 0; L < I.length; L++) {
                  const F = Array.isArray(w) ? w[L] : w.type, V = I[L];
                  y.concat(L + 1).checkSubtype(F, V.type);
                }
                if (y.errors.length === 0) return new Wr(s, p, P, I);
              }
            }
            if (_.length === 1) i.errors.push(...y.errors);
            else {
              const w = (_.length ? _ : f).map(([I]) => {
                return z = I, Array.isArray(z) ? `(${z.map(si).join(", ")})` : `(${si(z.type)}...)`;
                var z;
              }).join(" | "), P = [];
              for (let I = 1; I < t.length; I++) {
                const z = i.parse(t[I], 1 + P.length);
                if (!z) return null;
                P.push(si(z.type));
              }
              i.error(`Expected arguments of type ${w}, but found (${P.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t, i) {
            Wr.definitions = i;
            for (const s in i) t[s] = Wr;
          }
        }
        function Cu(r, [t, i, s, l]) {
          t = t.evaluate(r), i = i.evaluate(r), s = s.evaluate(r);
          const p = l ? l.evaluate(r) : 1, f = hi(t, i, s, p);
          if (f) throw new oi(f);
          return new Bt(t / 255, i / 255, s / 255, p, !1);
        }
        function Iu(r, t) {
          return r in t;
        }
        function ic(r, t) {
          const i = t[r];
          return i === void 0 ? null : i;
        }
        function Ts(r) {
          return { type: r };
        }
        function Oa(r) {
          if (r instanceof Pa) return Oa(r.boundExpression);
          if (r instanceof Wr && r.name === "error" || r instanceof Ea || r instanceof xs || r instanceof ws || r instanceof Vo) return !1;
          const t = r instanceof wn || r instanceof Fr;
          let i = !0;
          return r.eachChild((s) => {
            i = t ? i && Oa(s) : i && s instanceof En;
          }), !!i && ja(r) && Va(r, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function ja(r) {
          if (r instanceof Wr && (r.name === "get" && r.args.length === 1 || r.name === "feature-state" || r.name === "has" && r.args.length === 1 || r.name === "properties" || r.name === "geometry-type" || r.name === "id" || /^filter-/.test(r.name)) || r instanceof xs || r instanceof ws) return !1;
          let t = !0;
          return r.eachChild((i) => {
            t && !ja(i) && (t = !1);
          }), t;
        }
        function No(r) {
          if (r instanceof Wr && r.name === "feature-state") return !1;
          let t = !0;
          return r.eachChild((i) => {
            t && !No(i) && (t = !1);
          }), t;
        }
        function Va(r, t) {
          if (r instanceof Wr && t.indexOf(r.name) >= 0) return !1;
          let i = !0;
          return r.eachChild((s) => {
            i && !Va(s, t) && (i = !1);
          }), i;
        }
        function Eu(r) {
          return { result: "success", value: r };
        }
        function Js(r) {
          return { result: "error", value: r };
        }
        function Wn(r) {
          return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven";
        }
        function Au(r) {
          return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
        }
        function rc(r) {
          return !!r.expression && r.expression.interpolated;
        }
        function jt(r) {
          return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
        }
        function $o(r) {
          return typeof r == "object" && r !== null && !Array.isArray(r) && ft(r) === Un;
        }
        function bd(r) {
          return r;
        }
        function ku(r, t) {
          const i = r.stops && typeof r.stops[0][0] == "object", s = i || !(i || r.property !== void 0), l = r.type || (rc(t) ? "exponential" : "interval"), p = function(P) {
            switch (P.type) {
              case "color":
                return Bt.parse;
              case "padding":
                return qi.parse;
              case "numberArray":
                return vr.parse;
              case "colorArray":
                return Di.parse;
              default:
                return null;
            }
          }(t);
          if (p && ((r = hr({}, r)).stops && (r.stops = r.stops.map((P) => [P[0], p(P[1])])), r.default = p(r.default ? r.default : t.default)), r.colorSpace && (f = r.colorSpace) !== "rgb" && f !== "hcl" && f !== "lab") throw new Error(`Unknown color space: "${r.colorSpace}"`);
          var f;
          const _ = function(P) {
            switch (P) {
              case "exponential":
                return Ru;
              case "interval":
                return wd;
              case "categorical":
                return zu;
              case "identity":
                return Td;
              default:
                throw new Error(`Unknown function type "${P}"`);
            }
          }(l);
          let y, w;
          if (l === "categorical") {
            y = /* @__PURE__ */ Object.create(null);
            for (const P of r.stops) y[P[0]] = P[1];
            w = typeof r.stops[0][0];
          }
          if (i) {
            const P = {}, I = [];
            for (let F = 0; F < r.stops.length; F++) {
              const V = r.stops[F], $ = V[0].zoom;
              P[$] === void 0 && (P[$] = { zoom: $, type: r.type, property: r.property, default: r.default, stops: [] }, I.push($)), P[$].stops.push([V[0].value, V[1]]);
            }
            const z = [];
            for (const F of I) z.push([P[F].zoom, ku(P[F], t)]);
            const L = { name: "linear" };
            return { kind: "composite", interpolationType: L, interpolationFactor: nr.interpolationFactor.bind(void 0, L), zoomStops: z.map((F) => F[0]), evaluate: ({ zoom: F }, V) => Ru({ stops: z, base: r.base }, t, F).evaluate(F, V) };
          }
          if (s) {
            const P = l === "exponential" ? { name: "exponential", base: r.base !== void 0 ? r.base : 1 } : null;
            return { kind: "camera", interpolationType: P, interpolationFactor: nr.interpolationFactor.bind(void 0, P), zoomStops: r.stops.map((I) => I[0]), evaluate: ({ zoom: I }) => _(r, t, I, y, w) };
          }
          return { kind: "source", evaluate(P, I) {
            const z = I && I.properties ? I.properties[r.property] : void 0;
            return z === void 0 ? Xn(r.default, t.default) : _(r, t, z, y, w);
          } };
        }
        function Xn(r, t, i) {
          return r !== void 0 ? r : t !== void 0 ? t : i !== void 0 ? i : void 0;
        }
        function zu(r, t, i, s, l) {
          return Xn(typeof i === l ? s[i] : void 0, r.default, t.default);
        }
        function wd(r, t, i) {
          if (jt(i) !== "number") return Xn(r.default, t.default);
          const s = r.stops.length;
          if (s === 1 || i <= r.stops[0][0]) return r.stops[0][1];
          if (i >= r.stops[s - 1][0]) return r.stops[s - 1][1];
          const l = _s(r.stops.map((p) => p[0]), i);
          return r.stops[l][1];
        }
        function Ru(r, t, i) {
          const s = r.base !== void 0 ? r.base : 1;
          if (jt(i) !== "number") return Xn(r.default, t.default);
          const l = r.stops.length;
          if (l === 1 || i <= r.stops[0][0]) return r.stops[0][1];
          if (i >= r.stops[l - 1][0]) return r.stops[l - 1][1];
          const p = _s(r.stops.map((P) => P[0]), i), f = function(P, I, z, L) {
            const F = L - z, V = P - z;
            return F === 0 ? 0 : I === 1 ? V / F : (Math.pow(I, V) - 1) / (Math.pow(I, F) - 1);
          }(i, s, r.stops[p][0], r.stops[p + 1][0]), _ = r.stops[p][1], y = r.stops[p + 1][1], w = Tn[t.type] || bd;
          return typeof _.evaluate == "function" ? { evaluate(...P) {
            const I = _.evaluate.apply(void 0, P), z = y.evaluate.apply(void 0, P);
            if (I !== void 0 && z !== void 0) return w(I, z, f, r.colorSpace);
          } } : w(_, y, f, r.colorSpace);
        }
        function Td(r, t, i) {
          switch (t.type) {
            case "color":
              i = Bt.parse(i);
              break;
            case "formatted":
              i = yr.fromString(i.toString());
              break;
            case "resolvedImage":
              i = Lr.fromString(i.toString());
              break;
            case "padding":
              i = qi.parse(i);
              break;
            case "colorArray":
              i = Di.parse(i);
              break;
            case "numberArray":
              i = vr.parse(i);
              break;
            default:
              jt(i) === t.type || t.type === "enum" && t.values[i] || (i = void 0);
          }
          return Xn(i, r.default, t.default);
        }
        Wr.register(Ys, { error: [{ kind: "error" }, [Lt], (r, [t]) => {
          throw new oi(t.evaluate(r));
        }], typeof: [Lt, [Mt], (r, [t]) => si(ft(t.evaluate(r)))], "to-rgba": [Cr(qe, 4), [rr], (r, [t]) => {
          const [i, s, l, p] = t.evaluate(r).rgb;
          return [255 * i, 255 * s, 255 * l, p];
        }], rgb: [rr, [qe, qe, qe], Cu], rgba: [rr, [qe, qe, qe, qe], Cu], has: { type: kt, overloads: [[[Lt], (r, [t]) => Iu(t.evaluate(r), r.properties())], [[Lt, Un], (r, [t, i]) => Iu(t.evaluate(r), i.evaluate(r))]] }, get: { type: Mt, overloads: [[[Lt], (r, [t]) => ic(t.evaluate(r), r.properties())], [[Lt, Un], (r, [t, i]) => ic(t.evaluate(r), i.evaluate(r))]] }, "feature-state": [Mt, [Lt], (r, [t]) => ic(t.evaluate(r), r.featureState || {})], properties: [Un, [], (r) => r.properties()], "geometry-type": [Lt, [], (r) => r.geometryType()], id: [Mt, [], (r) => r.id()], zoom: [qe, [], (r) => r.globals.zoom], "heatmap-density": [qe, [], (r) => r.globals.heatmapDensity || 0], elevation: [qe, [], (r) => r.globals.elevation || 0], "line-progress": [qe, [], (r) => r.globals.lineProgress || 0], accumulated: [Mt, [], (r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated], "+": [qe, Ts(qe), (r, t) => {
          let i = 0;
          for (const s of t) i += s.evaluate(r);
          return i;
        }], "*": [qe, Ts(qe), (r, t) => {
          let i = 1;
          for (const s of t) i *= s.evaluate(r);
          return i;
        }], "-": { type: qe, overloads: [[[qe, qe], (r, [t, i]) => t.evaluate(r) - i.evaluate(r)], [[qe], (r, [t]) => -t.evaluate(r)]] }, "/": [qe, [qe, qe], (r, [t, i]) => t.evaluate(r) / i.evaluate(r)], "%": [qe, [qe, qe], (r, [t, i]) => t.evaluate(r) % i.evaluate(r)], ln2: [qe, [], () => Math.LN2], pi: [qe, [], () => Math.PI], e: [qe, [], () => Math.E], "^": [qe, [qe, qe], (r, [t, i]) => Math.pow(t.evaluate(r), i.evaluate(r))], sqrt: [qe, [qe], (r, [t]) => Math.sqrt(t.evaluate(r))], log10: [qe, [qe], (r, [t]) => Math.log(t.evaluate(r)) / Math.LN10], ln: [qe, [qe], (r, [t]) => Math.log(t.evaluate(r))], log2: [qe, [qe], (r, [t]) => Math.log(t.evaluate(r)) / Math.LN2], sin: [qe, [qe], (r, [t]) => Math.sin(t.evaluate(r))], cos: [qe, [qe], (r, [t]) => Math.cos(t.evaluate(r))], tan: [qe, [qe], (r, [t]) => Math.tan(t.evaluate(r))], asin: [qe, [qe], (r, [t]) => Math.asin(t.evaluate(r))], acos: [qe, [qe], (r, [t]) => Math.acos(t.evaluate(r))], atan: [qe, [qe], (r, [t]) => Math.atan(t.evaluate(r))], min: [qe, Ts(qe), (r, t) => Math.min(...t.map((i) => i.evaluate(r)))], max: [qe, Ts(qe), (r, t) => Math.max(...t.map((i) => i.evaluate(r)))], abs: [qe, [qe], (r, [t]) => Math.abs(t.evaluate(r))], round: [qe, [qe], (r, [t]) => {
          const i = t.evaluate(r);
          return i < 0 ? -Math.round(-i) : Math.round(i);
        }], floor: [qe, [qe], (r, [t]) => Math.floor(t.evaluate(r))], ceil: [qe, [qe], (r, [t]) => Math.ceil(t.evaluate(r))], "filter-==": [kt, [Lt, Mt], (r, [t, i]) => r.properties()[t.value] === i.value], "filter-id-==": [kt, [Mt], (r, [t]) => r.id() === t.value], "filter-type-==": [kt, [Lt], (r, [t]) => r.geometryType() === t.value], "filter-<": [kt, [Lt, Mt], (r, [t, i]) => {
          const s = r.properties()[t.value], l = i.value;
          return typeof s == typeof l && s < l;
        }], "filter-id-<": [kt, [Mt], (r, [t]) => {
          const i = r.id(), s = t.value;
          return typeof i == typeof s && i < s;
        }], "filter->": [kt, [Lt, Mt], (r, [t, i]) => {
          const s = r.properties()[t.value], l = i.value;
          return typeof s == typeof l && s > l;
        }], "filter-id->": [kt, [Mt], (r, [t]) => {
          const i = r.id(), s = t.value;
          return typeof i == typeof s && i > s;
        }], "filter-<=": [kt, [Lt, Mt], (r, [t, i]) => {
          const s = r.properties()[t.value], l = i.value;
          return typeof s == typeof l && s <= l;
        }], "filter-id-<=": [kt, [Mt], (r, [t]) => {
          const i = r.id(), s = t.value;
          return typeof i == typeof s && i <= s;
        }], "filter->=": [kt, [Lt, Mt], (r, [t, i]) => {
          const s = r.properties()[t.value], l = i.value;
          return typeof s == typeof l && s >= l;
        }], "filter-id->=": [kt, [Mt], (r, [t]) => {
          const i = r.id(), s = t.value;
          return typeof i == typeof s && i >= s;
        }], "filter-has": [kt, [Mt], (r, [t]) => t.value in r.properties()], "filter-has-id": [kt, [], (r) => r.id() !== null && r.id() !== void 0], "filter-type-in": [kt, [Cr(Lt)], (r, [t]) => t.value.indexOf(r.geometryType()) >= 0], "filter-id-in": [kt, [Cr(Mt)], (r, [t]) => t.value.indexOf(r.id()) >= 0], "filter-in-small": [kt, [Lt, Cr(Mt)], (r, [t, i]) => i.value.indexOf(r.properties()[t.value]) >= 0], "filter-in-large": [kt, [Lt, Cr(Mt)], (r, [t, i]) => function(s, l, p, f) {
          for (; p <= f; ) {
            const _ = p + f >> 1;
            if (l[_] === s) return !0;
            l[_] > s ? f = _ - 1 : p = _ + 1;
          }
          return !1;
        }(r.properties()[t.value], i.value, 0, i.value.length - 1)], all: { type: kt, overloads: [[[kt, kt], (r, [t, i]) => t.evaluate(r) && i.evaluate(r)], [Ts(kt), (r, t) => {
          for (const i of t) if (!i.evaluate(r)) return !1;
          return !0;
        }]] }, any: { type: kt, overloads: [[[kt, kt], (r, [t, i]) => t.evaluate(r) || i.evaluate(r)], [Ts(kt), (r, t) => {
          for (const i of t) if (i.evaluate(r)) return !0;
          return !1;
        }]] }, "!": [kt, [kt], (r, [t]) => !t.evaluate(r)], "is-supported-script": [kt, [Lt], (r, [t]) => {
          const i = r.globals && r.globals.isSupportedScript;
          return !i || i(t.evaluate(r));
        }], upcase: [Lt, [Lt], (r, [t]) => t.evaluate(r).toUpperCase()], downcase: [Lt, [Lt], (r, [t]) => t.evaluate(r).toLowerCase()], concat: [Lt, Ts(Mt), (r, t) => t.map((i) => Tt(i.evaluate(r))).join("")], "resolved-locale": [Lt, [va], (r, [t]) => t.evaluate(r).resolvedLocale()] });
        class nc {
          constructor(t, i) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new Vl(), this._defaultValue = i ? function(s) {
              if (s.type === "color" && $o(s.default)) return new Bt(0, 0, 0, 0);
              switch (s.type) {
                case "color":
                  return Bt.parse(s.default) || null;
                case "padding":
                  return qi.parse(s.default) || null;
                case "numberArray":
                  return vr.parse(s.default) || null;
                case "colorArray":
                  return Di.parse(s.default) || null;
                case "variableAnchorOffsetCollection":
                  return xr.parse(s.default) || null;
                case "projectionDefinition":
                  return dr.parse(s.default) || null;
                default:
                  return s.default === void 0 ? null : s.default;
              }
            }(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null;
          }
          evaluateWithoutErrorHandling(t, i, s, l, p, f) {
            return this._evaluator.globals = t, this._evaluator.feature = i, this._evaluator.featureState = s, this._evaluator.canonical = l, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f, this.expression.evaluate(this._evaluator);
          }
          evaluate(t, i, s, l, p, f) {
            this._evaluator.globals = t, this._evaluator.feature = i || null, this._evaluator.featureState = s || null, this._evaluator.canonical = l, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f || null;
            try {
              const _ = this.expression.evaluate(this._evaluator);
              if (_ == null || typeof _ == "number" && _ != _) return this._defaultValue;
              if (this._enumValues && !(_ in this._enumValues)) throw new oi(`Expected value to be one of ${Object.keys(this._enumValues).map((y) => JSON.stringify(y)).join(", ")}, but found ${JSON.stringify(_)} instead.`);
              return _;
            } catch (_) {
              return this._warningHistory[_.message] || (this._warningHistory[_.message] = !0, typeof console < "u" && console.warn(_.message)), this._defaultValue;
            }
          }
        }
        function Na(r) {
          return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in Ys;
        }
        function Uo(r, t) {
          const i = new Ws(Ys, Oa, [], t ? function(l) {
            const p = { color: rr, string: Lt, number: qe, enum: Lt, boolean: kt, formatted: Zn, padding: xa, numberArray: Us, colorArray: xn, projectionDefinition: ds, resolvedImage: Ti, variableAnchorOffsetCollection: ba };
            return l.type === "array" ? Cr(p[l.value] || Mt, l.length) : p[l.type];
          }(t) : void 0), s = i.parse(r, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return s ? Eu(new nc(s, t)) : Js(i.errors);
        }
        class Zo {
          constructor(t, i) {
            this.kind = t, this._styleExpression = i, this.isStateDependent = t !== "constant" && !No(i.expression), this.globalStateRefs = Ho(i.expression);
          }
          evaluateWithoutErrorHandling(t, i, s, l, p, f) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, i, s, l, p, f);
          }
          evaluate(t, i, s, l, p, f) {
            return this._styleExpression.evaluate(t, i, s, l, p, f);
          }
        }
        class sc {
          constructor(t, i, s, l) {
            this.kind = t, this.zoomStops = s, this._styleExpression = i, this.isStateDependent = t !== "camera" && !No(i.expression), this.globalStateRefs = Ho(i.expression), this.interpolationType = l;
          }
          evaluateWithoutErrorHandling(t, i, s, l, p, f) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, i, s, l, p, f);
          }
          evaluate(t, i, s, l, p, f) {
            return this._styleExpression.evaluate(t, i, s, l, p, f);
          }
          interpolationFactor(t, i, s) {
            return this.interpolationType ? nr.interpolationFactor(this.interpolationType, t, i, s) : 0;
          }
        }
        function Du(r, t) {
          const i = Uo(r, t);
          if (i.result === "error") return i;
          const s = i.value.expression, l = ja(s);
          if (!l && !Wn(t)) return Js([new vi("", "data expressions not supported")]);
          const p = Va(s, ["zoom"]);
          if (!p && !Au(t)) return Js([new vi("", "zoom expressions not supported")]);
          const f = qo(s);
          return f || p ? f instanceof vi ? Js([f]) : f instanceof nr && !rc(t) ? Js([new vi("", '"interpolate" expressions cannot be used with this property')]) : Eu(f ? new sc(l ? "camera" : "composite", i.value, f.labels, f instanceof nr ? f.interpolation : void 0) : new Zo(l ? "constant" : "source", i.value)) : Js([new vi("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Go {
          constructor(t, i) {
            this._parameters = t, this._specification = i, hr(this, ku(this._parameters, this._specification));
          }
          static deserialize(t) {
            return new Go(t._parameters, t._specification);
          }
          static serialize(t) {
            return { _parameters: t._parameters, _specification: t._specification };
          }
        }
        function qo(r) {
          let t = null;
          if (r instanceof Eo) t = qo(r.result);
          else if (r instanceof Ro) {
            for (const i of r.args) if (t = qo(i), t) break;
          } else (r instanceof Si || r instanceof nr) && r.input instanceof Wr && r.input.name === "zoom" && (t = r);
          return t instanceof vi || r.eachChild((i) => {
            const s = qo(i);
            s instanceof vi ? t = s : !t && s ? t = new vi("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && s && t !== s && (t = new vi("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), t;
        }
        function Ho(r, t = /* @__PURE__ */ new Set()) {
          return r instanceof Vo && t.add(r.key), r.eachChild((i) => {
            Ho(i, t);
          }), t;
        }
        function $a(r) {
          if (r === !0 || r === !1) return !0;
          if (!Array.isArray(r) || r.length === 0) return !1;
          switch (r[0]) {
            case "has":
              return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
            case "in":
              return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
            case "any":
            case "all":
              for (const t of r.slice(1)) if (!$a(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        const oc = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
        function Ss(r) {
          if (r == null) return { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          $a(r) || (r = Ps(r));
          const t = Uo(r, oc);
          if (t.result === "error") throw new Error(t.value.map((i) => `${i.key}: ${i.message}`).join(", "));
          return { filter: (i, s, l) => t.value.evaluate(i, s, {}, l), needGeometry: Ua(r), getGlobalStateRefs: () => Ho(t.value.expression) };
        }
        function ac(r, t) {
          return r < t ? -1 : r > t ? 1 : 0;
        }
        function Ua(r) {
          if (!Array.isArray(r)) return !1;
          if (r[0] === "within" || r[0] === "distance") return !0;
          for (let t = 1; t < r.length; t++) if (Ua(r[t])) return !0;
          return !1;
        }
        function Ps(r) {
          if (!r) return !0;
          const t = r[0];
          return r.length <= 1 ? t !== "any" : t === "==" ? lc(r[1], r[2], "==") : t === "!=" ? Za(lc(r[1], r[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? lc(r[1], r[2], t) : t === "any" ? (i = r.slice(1), ["any"].concat(i.map(Ps))) : t === "all" ? ["all"].concat(r.slice(1).map(Ps)) : t === "none" ? ["all"].concat(r.slice(1).map(Ps).map(Za)) : t === "in" ? Lu(r[1], r.slice(2)) : t === "!in" ? Za(Lu(r[1], r.slice(2))) : t === "has" ? Fu(r[1]) : t !== "!has" || Za(Fu(r[1]));
          var i;
        }
        function lc(r, t, i) {
          switch (r) {
            case "$type":
              return [`filter-type-${i}`, t];
            case "$id":
              return [`filter-id-${i}`, t];
            default:
              return [`filter-${i}`, r, t];
          }
        }
        function Lu(r, t) {
          if (t.length === 0) return !1;
          switch (r) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((i) => typeof i != typeof t[0]) ? ["filter-in-large", r, ["literal", t.sort(ac)]] : ["filter-in-small", r, ["literal", t]];
          }
        }
        function Fu(r) {
          switch (r) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", r];
          }
        }
        function Za(r) {
          return ["!", r];
        }
        function cc(r) {
          const t = typeof r;
          if (t === "number" || t === "boolean" || t === "string" || r == null) return JSON.stringify(r);
          if (Array.isArray(r)) {
            let l = "[";
            for (const p of r) l += `${cc(p)},`;
            return `${l}]`;
          }
          const i = Object.keys(r).sort();
          let s = "{";
          for (let l = 0; l < i.length; l++) s += `${JSON.stringify(i[l])}:${cc(r[i[l]])},`;
          return `${s}}`;
        }
        function Sd(r) {
          let t = "";
          for (const i of bt) t += `/${cc(r[i])}`;
          return t;
        }
        function uc(r) {
          const t = r.value;
          return t ? [new Fe(r.key, t, "constants have been deprecated as of v8")] : [];
        }
        function xi(r) {
          return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
        }
        function Sn(r) {
          if (Array.isArray(r)) return r.map(Sn);
          if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
            const t = {};
            for (const i in r) t[i] = Sn(r[i]);
            return t;
          }
          return xi(r);
        }
        function Xr(r) {
          const t = r.key, i = r.value, s = r.valueSpec || {}, l = r.objectElementValidators || {}, p = r.style, f = r.styleSpec, _ = r.validateSpec;
          let y = [];
          const w = jt(i);
          if (w !== "object") return [new Fe(t, i, `object expected, ${w} found`)];
          for (const P in i) {
            const I = P.split(".")[0], z = Hs(s, I) || s["*"];
            let L;
            if (Hs(l, I)) L = l[I];
            else if (Hs(s, I)) L = _;
            else if (l["*"]) L = l["*"];
            else {
              if (!s["*"]) {
                y.push(new Fe(t, i[P], `unknown property "${P}"`));
                continue;
              }
              L = _;
            }
            y = y.concat(L({ key: (t && `${t}.`) + P, value: i[P], valueSpec: z, style: p, styleSpec: f, object: i, objectKey: P, validateSpec: _ }, i));
          }
          for (const P in s) l[P] || s[P].required && s[P].default === void 0 && i[P] === void 0 && y.push(new Fe(t, i, `missing required property "${P}"`));
          return y;
        }
        function Ga(r) {
          const t = r.value, i = r.valueSpec, s = r.style, l = r.styleSpec, p = r.key, f = r.arrayElementValidator || r.validateSpec;
          if (jt(t) !== "array") return [new Fe(p, t, `array expected, ${jt(t)} found`)];
          if (i.length && t.length !== i.length) return [new Fe(p, t, `array length ${i.length} expected, length ${t.length} found`)];
          if (i["min-length"] && t.length < i["min-length"]) return [new Fe(p, t, `array length at least ${i["min-length"]} expected, length ${t.length} found`)];
          let _ = { type: i.value, values: i.values };
          l.$version < 7 && (_.function = i.function), jt(i.value) === "object" && (_ = i.value);
          let y = [];
          for (let w = 0; w < t.length; w++) y = y.concat(f({ array: t, arrayIndex: w, value: t[w], valueSpec: _, validateSpec: r.validateSpec, style: s, styleSpec: l, key: `${p}[${w}]` }));
          return y;
        }
        function Wo(r) {
          const t = r.key, i = r.value, s = r.valueSpec;
          let l = jt(i);
          return l === "number" && i != i && (l = "NaN"), l !== "number" ? [new Fe(t, i, `number expected, ${l} found`)] : "minimum" in s && i < s.minimum ? [new Fe(t, i, `${i} is less than the minimum value ${s.minimum}`)] : "maximum" in s && i > s.maximum ? [new Fe(t, i, `${i} is greater than the maximum value ${s.maximum}`)] : [];
        }
        function Bu(r) {
          const t = r.valueSpec, i = xi(r.value.type);
          let s, l, p, f = {};
          const _ = i !== "categorical" && r.value.property === void 0, y = !_, w = jt(r.value.stops) === "array" && jt(r.value.stops[0]) === "array" && jt(r.value.stops[0][0]) === "object", P = Xr({ key: r.key, value: r.value, valueSpec: r.styleSpec.function, validateSpec: r.validateSpec, style: r.style, styleSpec: r.styleSpec, objectElementValidators: { stops: function(L) {
            if (i === "identity") return [new Fe(L.key, L.value, 'identity function may not have a "stops" property')];
            let F = [];
            const V = L.value;
            return F = F.concat(Ga({ key: L.key, value: V, valueSpec: L.valueSpec, validateSpec: L.validateSpec, style: L.style, styleSpec: L.styleSpec, arrayElementValidator: I })), jt(V) === "array" && V.length === 0 && F.push(new Fe(L.key, V, "array must have at least one stop")), F;
          }, default: function(L) {
            return L.validateSpec({ key: L.key, value: L.value, valueSpec: t, validateSpec: L.validateSpec, style: L.style, styleSpec: L.styleSpec });
          } } });
          return i === "identity" && _ && P.push(new Fe(r.key, r.value, 'missing required property "property"')), i === "identity" || r.value.stops || P.push(new Fe(r.key, r.value, 'missing required property "stops"')), i === "exponential" && r.valueSpec.expression && !rc(r.valueSpec) && P.push(new Fe(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (y && !Wn(r.valueSpec) ? P.push(new Fe(r.key, r.value, "property functions not supported")) : _ && !Au(r.valueSpec) && P.push(new Fe(r.key, r.value, "zoom functions not supported"))), i !== "categorical" && !w || r.value.property !== void 0 || P.push(new Fe(r.key, r.value, '"property" property is required')), P;
          function I(L) {
            let F = [];
            const V = L.value, $ = L.key;
            if (jt(V) !== "array") return [new Fe($, V, `array expected, ${jt(V)} found`)];
            if (V.length !== 2) return [new Fe($, V, `array length 2 expected, length ${V.length} found`)];
            if (w) {
              if (jt(V[0]) !== "object") return [new Fe($, V, `object expected, ${jt(V[0])} found`)];
              if (V[0].zoom === void 0) return [new Fe($, V, "object stop key must have zoom")];
              if (V[0].value === void 0) return [new Fe($, V, "object stop key must have value")];
              if (p && p > xi(V[0].zoom)) return [new Fe($, V[0].zoom, "stop zoom values must appear in ascending order")];
              xi(V[0].zoom) !== p && (p = xi(V[0].zoom), l = void 0, f = {}), F = F.concat(Xr({ key: `${$}[0]`, value: V[0], valueSpec: { zoom: {} }, validateSpec: L.validateSpec, style: L.style, styleSpec: L.styleSpec, objectElementValidators: { zoom: Wo, value: z } }));
            } else F = F.concat(z({ key: `${$}[0]`, value: V[0], validateSpec: L.validateSpec, style: L.style, styleSpec: L.styleSpec }, V));
            return Na(Sn(V[1])) ? F.concat([new Fe(`${$}[1]`, V[1], "expressions are not allowed in function stops.")]) : F.concat(L.validateSpec({ key: `${$}[1]`, value: V[1], valueSpec: t, validateSpec: L.validateSpec, style: L.style, styleSpec: L.styleSpec }));
          }
          function z(L, F) {
            const V = jt(L.value), $ = xi(L.value), H = L.value !== null ? L.value : F;
            if (s) {
              if (V !== s) return [new Fe(L.key, H, `${V} stop domain type must match previous stop domain type ${s}`)];
            } else s = V;
            if (V !== "number" && V !== "string" && V !== "boolean") return [new Fe(L.key, H, "stop domain value must be a number, string, or boolean")];
            if (V !== "number" && i !== "categorical") {
              let he = `number expected, ${V} found`;
              return Wn(t) && i === void 0 && (he += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Fe(L.key, H, he)];
            }
            return i !== "categorical" || V !== "number" || isFinite($) && Math.floor($) === $ ? i !== "categorical" && V === "number" && l !== void 0 && $ < l ? [new Fe(L.key, H, "stop domain values must appear in ascending order")] : (l = $, i === "categorical" && $ in f ? [new Fe(L.key, H, "stop domain values must be unique")] : (f[$] = !0, [])) : [new Fe(L.key, H, `integer expected, found ${$}`)];
          }
        }
        function Ms(r) {
          const t = (r.expressionContext === "property" ? Du : Uo)(Sn(r.value), r.valueSpec);
          if (t.result === "error") return t.value.map((s) => new Fe(`${r.key}${s.key}`, r.value, s.message));
          const i = t.value.expression || t.value._styleExpression.expression;
          if (r.expressionContext === "property" && r.propertyKey === "text-font" && !i.outputDefined()) return [new Fe(r.key, r.value, `Invalid data expression for "${r.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (r.expressionContext === "property" && r.propertyType === "layout" && !No(i)) return [new Fe(r.key, r.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (r.expressionContext === "filter" && !No(i)) return [new Fe(r.key, r.value, '"feature-state" data expressions are not supported with filters.')];
          if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
            if (!Va(i, ["zoom", "feature-state"])) return [new Fe(r.key, r.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (r.expressionContext === "cluster-initial" && !ja(i)) return [new Fe(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function qa(r) {
          const t = r.key, i = r.value, s = jt(i);
          return s !== "string" ? [new Fe(t, i, `color expected, ${s} found`)] : Bt.parse(String(i)) ? [] : [new Fe(t, i, `color expected, "${i}" found`)];
        }
        function kn(r) {
          const t = r.key, i = r.value, s = r.valueSpec, l = [];
          return Array.isArray(s.values) ? s.values.indexOf(xi(i)) === -1 && l.push(new Fe(t, i, `expected one of [${s.values.join(", ")}], ${JSON.stringify(i)} found`)) : Object.keys(s.values).indexOf(xi(i)) === -1 && l.push(new Fe(t, i, `expected one of [${Object.keys(s.values).join(", ")}], ${JSON.stringify(i)} found`)), l;
        }
        function hc(r) {
          return $a(Sn(r.value)) ? Ms(hr({}, r, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Ou(r);
        }
        function Ou(r) {
          const t = r.value, i = r.key;
          if (jt(t) !== "array") return [new Fe(i, t, `array expected, ${jt(t)} found`)];
          const s = r.styleSpec;
          let l, p = [];
          if (t.length < 1) return [new Fe(i, t, "filter array must have at least 1 element")];
          switch (p = p.concat(kn({ key: `${i}[0]`, value: t[0], valueSpec: s.filter_operator, style: r.style, styleSpec: r.styleSpec })), xi(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && xi(t[1]) === "$type" && p.push(new Fe(i, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && p.push(new Fe(i, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (l = jt(t[1]), l !== "string" && p.push(new Fe(`${i}[1]`, t[1], `string expected, ${l} found`)));
              for (let f = 2; f < t.length; f++) l = jt(t[f]), xi(t[1]) === "$type" ? p = p.concat(kn({ key: `${i}[${f}]`, value: t[f], valueSpec: s.geometry_type, style: r.style, styleSpec: r.styleSpec })) : l !== "string" && l !== "number" && l !== "boolean" && p.push(new Fe(`${i}[${f}]`, t[f], `string, number, or boolean expected, ${l} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let f = 1; f < t.length; f++) p = p.concat(Ou({ key: `${i}[${f}]`, value: t[f], style: r.style, styleSpec: r.styleSpec }));
              break;
            case "has":
            case "!has":
              l = jt(t[1]), t.length !== 2 ? p.push(new Fe(i, t, `filter array for "${t[0]}" operator must have 2 elements`)) : l !== "string" && p.push(new Fe(`${i}[1]`, t[1], `string expected, ${l} found`));
          }
          return p;
        }
        function ju(r, t) {
          const i = r.key, s = r.validateSpec, l = r.style, p = r.styleSpec, f = r.value, _ = r.objectKey, y = p[`${t}_${r.layerType}`];
          if (!y) return [];
          const w = _.match(/^(.*)-transition$/);
          if (t === "paint" && w && y[w[1]] && y[w[1]].transition) return s({ key: i, value: f, valueSpec: p.transition, style: l, styleSpec: p });
          const P = r.valueSpec || y[_];
          if (!P) return [new Fe(i, f, `unknown property "${_}"`)];
          let I;
          if (jt(f) === "string" && Wn(P) && !P.tokens && (I = /^{([^}]+)}$/.exec(f))) return [new Fe(i, f, `"${_}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(I[1])} }\`.`)];
          const z = [];
          return r.layerType === "symbol" && (_ === "text-field" && l && !l.glyphs && z.push(new Fe(i, f, 'use of "text-field" requires a style "glyphs" property')), _ === "text-font" && $o(Sn(f)) && xi(f.type) === "identity" && z.push(new Fe(i, f, '"text-font" does not support identity functions'))), z.concat(s({ key: r.key, value: f, valueSpec: P, style: l, styleSpec: p, expressionContext: "property", propertyType: t, propertyKey: _ }));
        }
        function Vu(r) {
          return ju(r, "paint");
        }
        function Nu(r) {
          return ju(r, "layout");
        }
        function $u(r) {
          let t = [];
          const i = r.value, s = r.key, l = r.style, p = r.styleSpec;
          if (jt(i) !== "object") return [new Fe(s, i, `object expected, ${jt(i)} found`)];
          i.type || i.ref || t.push(new Fe(s, i, 'either "type" or "ref" is required'));
          let f = xi(i.type);
          const _ = xi(i.ref);
          if (i.id) {
            const y = xi(i.id);
            for (let w = 0; w < r.arrayIndex; w++) {
              const P = l.layers[w];
              xi(P.id) === y && t.push(new Fe(s, i.id, `duplicate layer id "${i.id}", previously used at line ${P.id.__line__}`));
            }
          }
          if ("ref" in i) {
            let y;
            ["type", "source", "source-layer", "filter", "layout"].forEach((w) => {
              w in i && t.push(new Fe(s, i[w], `"${w}" is prohibited for ref layers`));
            }), l.layers.forEach((w) => {
              xi(w.id) === _ && (y = w);
            }), y ? y.ref ? t.push(new Fe(s, i.ref, "ref cannot reference another ref layer")) : f = xi(y.type) : t.push(new Fe(s, i.ref, `ref layer "${_}" not found`));
          } else if (f !== "background") if (i.source) {
            const y = l.sources && l.sources[i.source], w = y && xi(y.type);
            y ? w === "vector" && f === "raster" ? t.push(new Fe(s, i.source, `layer "${i.id}" requires a raster source`)) : w !== "raster-dem" && f === "hillshade" || w !== "raster-dem" && f === "color-relief" ? t.push(new Fe(s, i.source, `layer "${i.id}" requires a raster-dem source`)) : w === "raster" && f !== "raster" ? t.push(new Fe(s, i.source, `layer "${i.id}" requires a vector source`)) : w !== "vector" || i["source-layer"] ? w === "raster-dem" && f !== "hillshade" && f !== "color-relief" ? t.push(new Fe(s, i.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : f !== "line" || !i.paint || !i.paint["line-gradient"] || w === "geojson" && y.lineMetrics || t.push(new Fe(s, i, `layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new Fe(s, i, `layer "${i.id}" must specify a "source-layer"`)) : t.push(new Fe(s, i.source, `source "${i.source}" not found`));
          } else t.push(new Fe(s, i, 'missing required property "source"'));
          return t = t.concat(Xr({ key: s, value: i, valueSpec: p.layer, style: r.style, styleSpec: r.styleSpec, validateSpec: r.validateSpec, objectElementValidators: { "*": () => [], type: () => r.validateSpec({ key: `${s}.type`, value: i.type, valueSpec: p.layer.type, style: r.style, styleSpec: r.styleSpec, validateSpec: r.validateSpec, object: i, objectKey: "type" }), filter: hc, layout: (y) => Xr({ layer: i, key: y.key, value: y.value, style: y.style, styleSpec: y.styleSpec, validateSpec: y.validateSpec, objectElementValidators: { "*": (w) => Nu(hr({ layerType: f }, w)) } }), paint: (y) => Xr({ layer: i, key: y.key, value: y.value, style: y.style, styleSpec: y.styleSpec, validateSpec: y.validateSpec, objectElementValidators: { "*": (w) => Vu(hr({ layerType: f }, w)) } }) } })), t;
        }
        function nn(r) {
          const t = r.value, i = r.key, s = jt(t);
          return s !== "string" ? [new Fe(i, t, `string expected, ${s} found`)] : [];
        }
        const Qs = { promoteId: function({ key: r, value: t }) {
          if (jt(t) === "string") return nn({ key: r, value: t });
          {
            const i = [];
            for (const s in t) i.push(...nn({ key: `${r}.${s}`, value: t[s] }));
            return i;
          }
        } };
        function Ir(r) {
          const t = r.value, i = r.key, s = r.styleSpec, l = r.style, p = r.validateSpec;
          if (!t.type) return [new Fe(i, t, '"type" is required')];
          const f = xi(t.type);
          let _;
          switch (f) {
            case "vector":
            case "raster":
              return _ = Xr({ key: i, value: t, valueSpec: s[`source_${f.replace("-", "_")}`], style: r.style, styleSpec: s, objectElementValidators: Qs, validateSpec: p }), _;
            case "raster-dem":
              return _ = function(y) {
                var w;
                const P = (w = y.sourceName) !== null && w !== void 0 ? w : "", I = y.value, z = y.styleSpec, L = z.source_raster_dem, F = y.style;
                let V = [];
                const $ = jt(I);
                if (I === void 0) return V;
                if ($ !== "object") return V.push(new Fe("source_raster_dem", I, `object expected, ${$} found`)), V;
                const H = xi(I.encoding) === "custom", he = ["redFactor", "greenFactor", "blueFactor", "baseShift"], ee = y.value.encoding ? `"${y.value.encoding}"` : "Default";
                for (const re in I) !H && he.includes(re) ? V.push(new Fe(re, I[re], `In "${P}": "${re}" is only valid when "encoding" is set to "custom". ${ee} encoding found`)) : L[re] ? V = V.concat(y.validateSpec({ key: re, value: I[re], valueSpec: L[re], validateSpec: y.validateSpec, style: F, styleSpec: z })) : V.push(new Fe(re, I[re], `unknown property "${re}"`));
                return V;
              }({ sourceName: i, value: t, style: r.style, styleSpec: s, validateSpec: p }), _;
            case "geojson":
              if (_ = Xr({ key: i, value: t, valueSpec: s.source_geojson, style: l, styleSpec: s, validateSpec: p, objectElementValidators: Qs }), t.cluster) for (const y in t.clusterProperties) {
                const [w, P] = t.clusterProperties[y], I = typeof w == "string" ? [w, ["accumulated"], ["get", y]] : w;
                _.push(...Ms({ key: `${i}.${y}.map`, value: P, expressionContext: "cluster-map" })), _.push(...Ms({ key: `${i}.${y}.reduce`, value: I, expressionContext: "cluster-reduce" }));
              }
              return _;
            case "video":
              return Xr({ key: i, value: t, valueSpec: s.source_video, style: l, validateSpec: p, styleSpec: s });
            case "image":
              return Xr({ key: i, value: t, valueSpec: s.source_image, style: l, validateSpec: p, styleSpec: s });
            case "canvas":
              return [new Fe(i, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return kn({ key: `${i}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function eo(r) {
          const t = r.value, i = r.styleSpec, s = i.light, l = r.style;
          let p = [];
          const f = jt(t);
          if (t === void 0) return p;
          if (f !== "object") return p = p.concat([new Fe("light", t, `object expected, ${f} found`)]), p;
          for (const _ in t) {
            const y = _.match(/^(.*)-transition$/);
            p = p.concat(y && s[y[1]] && s[y[1]].transition ? r.validateSpec({ key: _, value: t[_], valueSpec: i.transition, validateSpec: r.validateSpec, style: l, styleSpec: i }) : s[_] ? r.validateSpec({ key: _, value: t[_], valueSpec: s[_], validateSpec: r.validateSpec, style: l, styleSpec: i }) : [new Fe(_, t[_], `unknown property "${_}"`)]);
          }
          return p;
        }
        function dc(r) {
          const t = r.value, i = r.styleSpec, s = i.sky, l = r.style, p = jt(t);
          if (t === void 0) return [];
          if (p !== "object") return [new Fe("sky", t, `object expected, ${p} found`)];
          let f = [];
          for (const _ in t) f = f.concat(s[_] ? r.validateSpec({ key: _, value: t[_], valueSpec: s[_], style: l, styleSpec: i }) : [new Fe(_, t[_], `unknown property "${_}"`)]);
          return f;
        }
        function Uu(r) {
          const t = r.value, i = r.styleSpec, s = i.terrain, l = r.style;
          let p = [];
          const f = jt(t);
          if (t === void 0) return p;
          if (f !== "object") return p = p.concat([new Fe("terrain", t, `object expected, ${f} found`)]), p;
          for (const _ in t) p = p.concat(s[_] ? r.validateSpec({ key: _, value: t[_], valueSpec: s[_], validateSpec: r.validateSpec, style: l, styleSpec: i }) : [new Fe(_, t[_], `unknown property "${_}"`)]);
          return p;
        }
        function Zu(r) {
          let t = [];
          const i = r.value, s = r.key;
          if (Array.isArray(i)) {
            const l = [], p = [];
            for (const f in i) i[f].id && l.includes(i[f].id) && t.push(new Fe(s, i, `all the sprites' ids must be unique, but ${i[f].id} is duplicated`)), l.push(i[f].id), i[f].url && p.includes(i[f].url) && t.push(new Fe(s, i, `all the sprites' URLs must be unique, but ${i[f].url} is duplicated`)), p.push(i[f].url), t = t.concat(Xr({ key: `${s}[${f}]`, value: i[f], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: r.validateSpec }));
            return t;
          }
          return nn({ key: s, value: i });
        }
        function to(r) {
          return t = r.value, t && t.constructor === Object ? [] : [new Fe(r.key, r.value, `object expected, ${jt(r.value)} found`)];
          var t;
        }
        const pc = { "*": () => [], array: Ga, boolean: function(r) {
          const t = r.value, i = r.key, s = jt(t);
          return s !== "boolean" ? [new Fe(i, t, `boolean expected, ${s} found`)] : [];
        }, number: Wo, color: qa, constants: uc, enum: kn, filter: hc, function: Bu, layer: $u, object: Xr, source: Ir, light: eo, sky: dc, terrain: Uu, projection: function(r) {
          const t = r.value, i = r.styleSpec, s = i.projection, l = r.style, p = jt(t);
          if (t === void 0) return [];
          if (p !== "object") return [new Fe("projection", t, `object expected, ${p} found`)];
          let f = [];
          for (const _ in t) f = f.concat(s[_] ? r.validateSpec({ key: _, value: t[_], valueSpec: s[_], style: l, styleSpec: i }) : [new Fe(_, t[_], `unknown property "${_}"`)]);
          return f;
        }, projectionDefinition: function(r) {
          const t = r.key;
          let i = r.value;
          i = i instanceof String ? i.valueOf() : i;
          const s = jt(i);
          return s !== "array" || function(l) {
            return Array.isArray(l) && l.length === 3 && typeof l[0] == "string" && typeof l[1] == "string" && typeof l[2] == "number";
          }(i) || function(l) {
            return !!["interpolate", "step", "literal"].includes(l[0]);
          }(i) ? ["array", "string"].includes(s) ? [] : [new Fe(t, i, `projection expected, invalid type "${s}" found`)] : [new Fe(t, i, `projection expected, invalid array ${JSON.stringify(i)} found`)];
        }, string: nn, formatted: function(r) {
          return nn(r).length === 0 ? [] : Ms(r);
        }, resolvedImage: function(r) {
          return nn(r).length === 0 ? [] : Ms(r);
        }, padding: function(r) {
          const t = r.key, i = r.value;
          if (jt(i) === "array") {
            if (i.length < 1 || i.length > 4) return [new Fe(t, i, `padding requires 1 to 4 values; ${i.length} values found`)];
            const s = { type: "number" };
            let l = [];
            for (let p = 0; p < i.length; p++) l = l.concat(r.validateSpec({ key: `${t}[${p}]`, value: i[p], validateSpec: r.validateSpec, valueSpec: s }));
            return l;
          }
          return Wo({ key: t, value: i, valueSpec: {} });
        }, numberArray: function(r) {
          const t = r.key, i = r.value;
          if (jt(i) === "array") {
            const s = { type: "number" };
            if (i.length < 1) return [new Fe(t, i, "array length at least 1 expected, length 0 found")];
            let l = [];
            for (let p = 0; p < i.length; p++) l = l.concat(r.validateSpec({ key: `${t}[${p}]`, value: i[p], validateSpec: r.validateSpec, valueSpec: s }));
            return l;
          }
          return Wo({ key: t, value: i, valueSpec: {} });
        }, colorArray: function(r) {
          const t = r.key, i = r.value;
          if (jt(i) === "array") {
            if (i.length < 1) return [new Fe(t, i, "array length at least 1 expected, length 0 found")];
            let s = [];
            for (let l = 0; l < i.length; l++) s = s.concat(qa({ key: `${t}[${l}]`, value: i[l] }));
            return s;
          }
          return qa({ key: t, value: i });
        }, variableAnchorOffsetCollection: function(r) {
          const t = r.key, i = r.value, s = jt(i), l = r.styleSpec;
          if (s !== "array" || i.length < 1 || i.length % 2 != 0) return [new Fe(t, i, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let p = [];
          for (let f = 0; f < i.length; f += 2) p = p.concat(kn({ key: `${t}[${f}]`, value: i[f], valueSpec: l.layout_symbol["text-anchor"] })), p = p.concat(Ga({ key: `${t}[${f + 1}]`, value: i[f + 1], valueSpec: { length: 2, value: "number" }, validateSpec: r.validateSpec, style: r.style, styleSpec: l }));
          return p;
        }, sprite: Zu, state: to };
        function io(r) {
          const t = r.value, i = r.valueSpec, s = r.styleSpec;
          return r.validateSpec = io, i.expression && $o(xi(t)) ? Bu(r) : i.expression && Na(Sn(t)) ? Ms(r) : i.type && pc[i.type] ? pc[i.type](r) : Xr(hr({}, r, { valueSpec: i.type ? s[i.type] : i }));
        }
        function Gu(r) {
          const t = r.value, i = r.key, s = nn(r);
          return s.length || (t.indexOf("{fontstack}") === -1 && s.push(new Fe(i, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && s.push(new Fe(i, t, '"glyphs" url must include a "{range}" token'))), s;
        }
        function Er(r, t = fe) {
          let i = [];
          return i = i.concat(io({ key: "", value: r, valueSpec: t.$root, styleSpec: t, style: r, validateSpec: io, objectElementValidators: { glyphs: Gu, "*": () => [] } })), r.constants && (i = i.concat(uc({ key: "constants", value: r.constants }))), ro(i);
        }
        function sn(r) {
          return function(t) {
            return r({ ...t, validateSpec: io });
          };
        }
        function ro(r) {
          return [].concat(r).sort((t, i) => t.line - i.line);
        }
        function on(r) {
          return function(...t) {
            return ro(r.apply(this, t));
          };
        }
        Er.source = on(sn(Ir)), Er.sprite = on(sn(Zu)), Er.glyphs = on(sn(Gu)), Er.light = on(sn(eo)), Er.sky = on(sn(dc)), Er.terrain = on(sn(Uu)), Er.state = on(sn(to)), Er.layer = on(sn($u)), Er.filter = on(sn(hc)), Er.paintProperty = on(sn(Vu)), Er.layoutProperty = on(sn(Nu));
        const no = Er, Pd = no.light, Xo = no.sky, Md = no.paintProperty, Cd = no.layoutProperty;
        function Ko(r, t) {
          let i = !1;
          if (t && t.length) for (const s of t) r.fire(new Ce(new Error(s.message))), i = !0;
          return i;
        }
        class Yo {
          constructor(t, i, s) {
            const l = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const f = new Int32Array(this.arrayBuffer);
              t = f[0], this.d = (i = f[1]) + 2 * (s = f[2]);
              for (let y = 0; y < this.d * this.d; y++) {
                const w = f[3 + y], P = f[3 + y + 1];
                l.push(w === P ? null : f.subarray(w, P));
              }
              const _ = f[3 + l.length + 1];
              this.keys = f.subarray(f[3 + l.length], _), this.bboxes = f.subarray(_), this.insert = this._insertReadonly;
            } else {
              this.d = i + 2 * s;
              for (let f = 0; f < this.d * this.d; f++) l.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = i, this.extent = t, this.padding = s, this.scale = i / t, this.uid = 0;
            const p = s / i * t;
            this.min = -p, this.max = t + p;
          }
          insert(t, i, s, l, p) {
            this._forEachCell(i, s, l, p, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(i), this.bboxes.push(s), this.bboxes.push(l), this.bboxes.push(p);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t, i, s, l, p, f) {
            this.cells[p].push(f);
          }
          query(t, i, s, l, p) {
            const f = this.min, _ = this.max;
            if (t <= f && i <= f && _ <= s && _ <= l && !p) return Array.prototype.slice.call(this.keys);
            {
              const y = [];
              return this._forEachCell(t, i, s, l, this._queryCell, y, {}, p), y;
            }
          }
          _queryCell(t, i, s, l, p, f, _, y) {
            const w = this.cells[p];
            if (w !== null) {
              const P = this.keys, I = this.bboxes;
              for (let z = 0; z < w.length; z++) {
                const L = w[z];
                if (_[L] === void 0) {
                  const F = 4 * L;
                  (y ? y(I[F + 0], I[F + 1], I[F + 2], I[F + 3]) : t <= I[F + 2] && i <= I[F + 3] && s >= I[F + 0] && l >= I[F + 1]) ? (_[L] = !0, f.push(P[L])) : _[L] = !1;
                }
              }
            }
          }
          _forEachCell(t, i, s, l, p, f, _, y) {
            const w = this._convertToCellCoord(t), P = this._convertToCellCoord(i), I = this._convertToCellCoord(s), z = this._convertToCellCoord(l);
            for (let L = w; L <= I; L++) for (let F = P; F <= z; F++) {
              const V = this.d * F + L;
              if ((!y || y(this._convertFromCellCoord(L), this._convertFromCellCoord(F), this._convertFromCellCoord(L + 1), this._convertFromCellCoord(F + 1))) && p.call(this, t, i, s, l, V, f, _, y)) return;
            }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale;
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells, i = 3 + this.cells.length + 1 + 1;
            let s = 0;
            for (let f = 0; f < this.cells.length; f++) s += this.cells[f].length;
            const l = new Int32Array(i + s + this.keys.length + this.bboxes.length);
            l[0] = this.extent, l[1] = this.n, l[2] = this.padding;
            let p = i;
            for (let f = 0; f < t.length; f++) {
              const _ = t[f];
              l[3 + f] = p, l.set(_, p), p += _.length;
            }
            return l[3 + t.length] = p, l.set(this.keys, p), p += this.keys.length, l[3 + t.length + 1] = p, l.set(this.bboxes, p), p += this.bboxes.length, l.buffer;
          }
          static serialize(t, i) {
            const s = t.toArrayBuffer();
            return i && i.push(s), { buffer: s };
          }
          static deserialize(t) {
            return new Yo(t.buffer);
          }
        }
        const an = {};
        function We(r, t, i = {}) {
          if (an[r]) throw new Error(`${r} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", { value: r, writeable: !1 }), an[r] = { klass: t, omit: i.omit || [], shallow: i.shallow || [] };
        }
        We("Object", Object), We("Set", Set), We("TransferableGridIndex", Yo), We("Color", Bt), We("Error", Error), We("AJAXError", X), We("ResolvedImage", Lr), We("StylePropertyFunction", Go), We("StyleExpression", nc, { omit: ["_evaluator"] }), We("ZoomDependentExpression", sc), We("ZoomConstantExpression", Zo), We("CompoundExpression", Wr, { omit: ["_evaluate"] });
        for (const r in Ys) Ys[r]._classRegistryKey || We(`Expression_${r}`, Ys[r]);
        function fc(r) {
          return r && typeof ArrayBuffer < "u" && (r instanceof ArrayBuffer || r.constructor && r.constructor.name === "ArrayBuffer");
        }
        function Ha(r) {
          return r.$name || r.constructor._classRegistryKey;
        }
        function mc(r) {
          return !function(t) {
            if (t === null || typeof t != "object") return !1;
            const i = Ha(t);
            return !(!i || i === "Object");
          }(r) && (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp || r instanceof Blob || r instanceof Error || fc(r) || He(r) || ArrayBuffer.isView(r) || r instanceof ImageData);
        }
        function so(r, t) {
          if (mc(r)) return (fc(r) || He(r)) && t && t.push(r), ArrayBuffer.isView(r) && t && t.push(r.buffer), r instanceof ImageData && t && t.push(r.data.buffer), r;
          if (Array.isArray(r)) {
            const p = [];
            for (const f of r) p.push(so(f, t));
            return p;
          }
          if (typeof r != "object") throw new Error("can't serialize object of type " + typeof r);
          const i = Ha(r);
          if (!i) throw new Error(`can't serialize object of unregistered class ${r.constructor.name}`);
          if (!an[i]) throw new Error(`${i} is not registered.`);
          const { klass: s } = an[i], l = s.serialize ? s.serialize(r, t) : {};
          if (s.serialize) {
            if (t && l === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const p in r) {
              if (!r.hasOwnProperty(p) || an[i].omit.indexOf(p) >= 0) continue;
              const f = r[p];
              l[p] = an[i].shallow.indexOf(p) >= 0 ? f : so(f, t);
            }
            r instanceof Error && (l.message = r.message);
          }
          if (l.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return i !== "Object" && (l.$name = i), l;
        }
        function Cs(r) {
          if (mc(r)) return r;
          if (Array.isArray(r)) return r.map(Cs);
          if (typeof r != "object") throw new Error("can't deserialize object of type " + typeof r);
          const t = Ha(r) || "Object";
          if (!an[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const { klass: i } = an[t];
          if (!i) throw new Error(`can't deserialize unregistered class ${t}`);
          if (i.deserialize) return i.deserialize(r);
          const s = Object.create(i.prototype);
          for (const l of Object.keys(r)) {
            if (l === "$name") continue;
            const p = r[l];
            s[l] = an[t].shallow.indexOf(l) >= 0 ? p : Cs(p);
          }
          return s;
        }
        class Wa {
          constructor() {
            this.first = !0;
          }
          update(t, i) {
            const s = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = s, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = s, !0) : (this.lastFloorZoom > s ? (this.lastIntegerZoom = s + 1, this.lastIntegerZoomTime = i) : this.lastFloorZoom < s && (this.lastIntegerZoom = s, this.lastIntegerZoomTime = i), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = s, !0));
          }
        }
        const Nt = { "Latin-1 Supplement": (r) => r >= 128 && r <= 255, "Hangul Jamo": (r) => r >= 4352 && r <= 4607, Khmer: (r) => r >= 6016 && r <= 6143, "General Punctuation": (r) => r >= 8192 && r <= 8303, "Letterlike Symbols": (r) => r >= 8448 && r <= 8527, "Number Forms": (r) => r >= 8528 && r <= 8591, "Miscellaneous Technical": (r) => r >= 8960 && r <= 9215, "Control Pictures": (r) => r >= 9216 && r <= 9279, "Optical Character Recognition": (r) => r >= 9280 && r <= 9311, "Enclosed Alphanumerics": (r) => r >= 9312 && r <= 9471, "Geometric Shapes": (r) => r >= 9632 && r <= 9727, "Miscellaneous Symbols": (r) => r >= 9728 && r <= 9983, "Miscellaneous Symbols and Arrows": (r) => r >= 11008 && r <= 11263, "Ideographic Description Characters": (r) => r >= 12272 && r <= 12287, "CJK Symbols and Punctuation": (r) => r >= 12288 && r <= 12351, Hiragana: (r) => r >= 12352 && r <= 12447, Katakana: (r) => r >= 12448 && r <= 12543, Kanbun: (r) => r >= 12688 && r <= 12703, "CJK Strokes": (r) => r >= 12736 && r <= 12783, "Enclosed CJK Letters and Months": (r) => r >= 12800 && r <= 13055, "CJK Compatibility": (r) => r >= 13056 && r <= 13311, "Yijing Hexagram Symbols": (r) => r >= 19904 && r <= 19967, "CJK Unified Ideographs": (r) => r >= 19968 && r <= 40959, "Hangul Syllables": (r) => r >= 44032 && r <= 55215, "Private Use Area": (r) => r >= 57344 && r <= 63743, "Vertical Forms": (r) => r >= 65040 && r <= 65055, "CJK Compatibility Forms": (r) => r >= 65072 && r <= 65103, "Small Form Variants": (r) => r >= 65104 && r <= 65135, "Halfwidth and Fullwidth Forms": (r) => r >= 65280 && r <= 65519 };
        function Xa(r) {
          for (const t of r) if (_c(t.charCodeAt(0))) return !0;
          return !1;
        }
        function Id(r) {
          for (const t of r) if (!qu(t.charCodeAt(0))) return !1;
          return !0;
        }
        function Ka(r) {
          const t = r.map((i) => {
            try {
              return new RegExp(`\\p{sc=${i}}`, "u").source;
            } catch {
              return null;
            }
          }).filter((i) => i);
          return new RegExp(t.join("|"), "u");
        }
        const Ed = Ka(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function qu(r) {
          return !Ed.test(String.fromCodePoint(r));
        }
        const gc = Ka(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function _c(r) {
          return !(r !== 746 && r !== 747 && (r < 4352 || !(Nt["CJK Compatibility Forms"](r) && !(r >= 65097 && r <= 65103) || Nt["CJK Compatibility"](r) || Nt["CJK Strokes"](r) || !(!Nt["CJK Symbols and Punctuation"](r) || r >= 12296 && r <= 12305 || r >= 12308 && r <= 12319 || r === 12336) || Nt["Enclosed CJK Letters and Months"](r) || Nt["Ideographic Description Characters"](r) || Nt.Kanbun(r) || Nt.Katakana(r) && r !== 12540 || !(!Nt["Halfwidth and Fullwidth Forms"](r) || r === 65288 || r === 65289 || r === 65293 || r >= 65306 && r <= 65310 || r === 65339 || r === 65341 || r === 65343 || r >= 65371 && r <= 65503 || r === 65507 || r >= 65512 && r <= 65519) || !(!Nt["Small Form Variants"](r) || r >= 65112 && r <= 65118 || r >= 65123 && r <= 65126) || Nt["Vertical Forms"](r) || Nt["Yijing Hexagram Symbols"](r) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(r)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(r)) || gc.test(String.fromCodePoint(r)))));
        }
        function Hu(r) {
          return !(_c(r) || function(t) {
            return !!(Nt["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || Nt["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || Nt["Letterlike Symbols"](t) || Nt["Number Forms"](t) || Nt["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Nt["Control Pictures"](t) && t !== 9251 || Nt["Optical Character Recognition"](t) || Nt["Enclosed Alphanumerics"](t) || Nt["Geometric Shapes"](t) || Nt["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Nt["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Nt["CJK Symbols and Punctuation"](t) || Nt.Katakana(t) || Nt["Private Use Area"](t) || Nt["CJK Compatibility Forms"](t) || Nt["Small Form Variants"](t) || Nt["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
          }(r));
        }
        const Wu = Ka(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function yc(r) {
          return Wu.test(String.fromCodePoint(r));
        }
        function Xu(r, t) {
          return !(!t && yc(r) || r >= 2304 && r <= 3583 || r >= 3840 && r <= 4255 || Nt.Khmer(r));
        }
        function Ku(r) {
          for (const t of r) if (yc(t.charCodeAt(0))) return !0;
          return !1;
        }
        const ln = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(r) {
            this.pluginStatus = r.pluginStatus, this.pluginURL = r.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(r) {
            if (ln.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = r.applyArabicShaping, this.processBidirectionalText = r.processBidirectionalText, this.processStyledBidirectionalText = r.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(r, t) {
            return a(this, void 0, void 0, function* () {
              if (this.isParsed()) return this.getState();
              if (r.pluginStatus !== "loading") return this.setState(r), r;
              const i = r.pluginURL, s = new Promise((p) => {
                this.loadScriptResolve = p;
              });
              t(i);
              const l = new Promise((p) => setTimeout(() => p(), this.TIMEOUT));
              if (yield Promise.race([s, l]), this.isParsed()) {
                const p = { pluginStatus: "loaded", pluginURL: i };
                return this.setState(p), p;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${i}`);
            });
          }
        }();
        class ai {
          constructor(t, i) {
            this.zoom = t, i ? (this.now = i.now || 0, this.fadeDuration = i.fadeDuration || 0, this.zoomHistory = i.zoomHistory || new Wa(), this.transition = i.transition || {}, this.globalState = i.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Wa(), this.transition = {}, this.globalState = {});
          }
          isSupportedScript(t) {
            return function(i, s) {
              for (const l of i) if (!Xu(l.charCodeAt(0), s)) return !1;
              return !0;
            }(t, ln.getRTLTextPluginStatus() === "loaded");
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t = this.zoom, i = t - Math.floor(t), s = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: i + (1 - i) * s } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - s) * i };
          }
        }
        class oo {
          constructor(t, i) {
            this.property = t, this.value = i, this.expression = function(s, l) {
              if ($o(s)) return new Go(s, l);
              if (Na(s)) {
                const p = Du(s, l);
                if (p.result === "error") throw new Error(p.value.map((f) => `${f.key}: ${f.message}`).join(", "));
                return p.value;
              }
              {
                let p = s;
                return l.type === "color" && typeof s == "string" ? p = Bt.parse(s) : l.type !== "padding" || typeof s != "number" && !Array.isArray(s) ? l.type !== "numberArray" || typeof s != "number" && !Array.isArray(s) ? l.type !== "colorArray" || typeof s != "string" && !Array.isArray(s) ? l.type === "variableAnchorOffsetCollection" && Array.isArray(s) ? p = xr.parse(s) : l.type === "projectionDefinition" && typeof s == "string" && (p = dr.parse(s)) : p = Di.parse(s) : p = vr.parse(s) : p = qi.parse(s), { globalStateRefs: /* @__PURE__ */ new Set(), kind: "constant", evaluate: () => p };
              }
            }(i === void 0 ? t.specification.default : i, t.specification), this._evaluate = this.expression.evaluate;
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(t, i, s) {
            return this.property.possiblyEvaluate(this, t, i, s);
          }
          setGlobalState(t) {
            this.expression.evaluate = (i, s, l, p, f, _) => (i.globalState = t, this._evaluate.call(this.expression, i, s, l, p, f, _));
          }
        }
        class vc {
          constructor(t) {
            this.property = t, this.value = new oo(t, void 0);
          }
          transitioned(t, i) {
            return new xc(this.property, this.value, i, ur({}, t.transition, this.transition), t.now);
          }
          untransitioned() {
            return new xc(this.property, this.value, null, {}, 0);
          }
        }
        class Yu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
          }
          getValue(t) {
            return ne(this._values[t].value.value);
          }
          setValue(t, i) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new vc(this._values[t].property)), this._values[t].value = new oo(this._values[t].property, i === null ? void 0 : ne(i));
          }
          getTransition(t) {
            return ne(this._values[t].transition);
          }
          setTransition(t, i) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new vc(this._values[t].property)), this._values[t].transition = ne(i) || void 0;
          }
          serialize() {
            const t = {};
            for (const i of Object.keys(this._values)) {
              const s = this.getValue(i);
              s !== void 0 && (t[i] = s);
              const l = this.getTransition(i);
              l !== void 0 && (t[`${i}-transition`] = l);
            }
            return t;
          }
          transitioned(t, i) {
            const s = new bc(this._properties);
            for (const l of Object.keys(this._values)) s._values[l] = this._values[l].transitioned(t, i._values[l]);
            return s;
          }
          untransitioned() {
            const t = new bc(this._properties);
            for (const i of Object.keys(this._values)) t._values[i] = this._values[i].untransitioned();
            return t;
          }
        }
        class xc {
          constructor(t, i, s, l, p) {
            this.property = t, this.value = i, this.begin = p + l.delay || 0, this.end = this.begin + l.duration || 0, t.specification.transition && (l.delay || l.duration) && (this.prior = s);
          }
          possiblyEvaluate(t, i, s) {
            const l = t.now || 0, p = this.value.possiblyEvaluate(t, i, s), f = this.prior;
            if (f) {
              if (l > this.end) return this.prior = null, p;
              if (this.value.isDataDriven()) return this.prior = null, p;
              if (l < this.begin) return f.possiblyEvaluate(t, i, s);
              {
                const _ = (l - this.begin) / (this.end - this.begin);
                return this.property.interpolate(f.possiblyEvaluate(t, i, s), p, Dr(_));
              }
            }
            return p;
          }
        }
        class bc {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t, i, s) {
            const l = new Ya(this._properties);
            for (const p of Object.keys(this._values)) l._values[p] = this._values[p].possiblyEvaluate(t, i, s);
            return l;
          }
          hasTransition() {
            for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;
            return !1;
          }
        }
        class Ju {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = {};
          }
          hasValue(t) {
            return this._values[t].value !== void 0;
          }
          getValue(t) {
            return ne(this._values[t].value);
          }
          setValue(t, i) {
            this._values[t] = new oo(this._values[t].property, i === null ? void 0 : ne(i)), this._values[t].setGlobalState(this._globalState);
          }
          serialize() {
            const t = {};
            for (const i of Object.keys(this._values)) {
              const s = this.getValue(i);
              s !== void 0 && (t[i] = s);
            }
            return t;
          }
          possiblyEvaluate(t, i, s) {
            const l = new Ya(this._properties);
            for (const p of Object.keys(this._values)) l._values[p] = this._values[p].possiblyEvaluate(t, i, s);
            return l;
          }
          setGlobalState(t) {
            this._globalState = t;
            for (const i of Object.values(this._values)) i.setGlobalState(t);
          }
        }
        class Pn {
          constructor(t, i, s) {
            this.property = t, this.value = i, this.parameters = s;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t;
          }
          evaluate(t, i, s, l) {
            return this.property.evaluate(this.value, this.parameters, t, i, s, l);
          }
        }
        class Ya {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
          }
          get(t) {
            return this._values[t];
          }
        }
        class nt {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, i) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(i);
          }
          interpolate(t, i, s) {
            const l = Tn[this.specification.type];
            return l ? l(t, i, s) : t;
          }
        }
        class dt {
          constructor(t, i) {
            this.specification = t, this.overrides = i;
          }
          possiblyEvaluate(t, i, s, l) {
            return new Pn(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(i, null, {}, s, l) } : t.expression, i);
          }
          interpolate(t, i, s) {
            if (t.value.kind !== "constant" || i.value.kind !== "constant") return t;
            if (t.value.value === void 0 || i.value.value === void 0) return new Pn(this, { kind: "constant", value: void 0 }, t.parameters);
            const l = Tn[this.specification.type];
            if (l) {
              const p = l(t.value.value, i.value.value, s);
              return new Pn(this, { kind: "constant", value: p }, t.parameters);
            }
            return t;
          }
          evaluate(t, i, s, l, p, f) {
            return t.kind === "constant" ? t.value : t.evaluate(i, s, l, p, f);
          }
        }
        class Ja extends dt {
          possiblyEvaluate(t, i, s, l) {
            if (t.value === void 0) return new Pn(this, { kind: "constant", value: void 0 }, i);
            if (t.expression.kind === "constant") {
              const p = t.expression.evaluate(i, null, {}, s, l), f = t.property.specification.type === "resolvedImage" && typeof p != "string" ? p.name : p, _ = this._calculate(f, f, f, i);
              return new Pn(this, { kind: "constant", value: _ }, i);
            }
            if (t.expression.kind === "camera") {
              const p = this._calculate(t.expression.evaluate({ zoom: i.zoom - 1 }), t.expression.evaluate({ zoom: i.zoom }), t.expression.evaluate({ zoom: i.zoom + 1 }), i);
              return new Pn(this, { kind: "constant", value: p }, i);
            }
            return new Pn(this, t.expression, i);
          }
          evaluate(t, i, s, l, p, f) {
            if (t.kind === "source") {
              const _ = t.evaluate(i, s, l, p, f);
              return this._calculate(_, _, _, i);
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(i.zoom) - 1 }, s, l), t.evaluate({ zoom: Math.floor(i.zoom) }, s, l), t.evaluate({ zoom: Math.floor(i.zoom) + 1 }, s, l), i) : t.value;
          }
          _calculate(t, i, s, l) {
            return l.zoom > l.zoomHistory.lastIntegerZoom ? { from: t, to: i } : { from: s, to: i };
          }
          interpolate(t) {
            return t;
          }
        }
        class Kn {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, i, s, l) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const p = t.expression.evaluate(i, null, {}, s, l);
                return this._calculate(p, p, p, i);
              }
              return this._calculate(t.expression.evaluate(new ai(Math.floor(i.zoom - 1), i)), t.expression.evaluate(new ai(Math.floor(i.zoom), i)), t.expression.evaluate(new ai(Math.floor(i.zoom + 1), i)), i);
            }
          }
          _calculate(t, i, s, l) {
            return l.zoom > l.zoomHistory.lastIntegerZoom ? { from: t, to: i } : { from: s, to: i };
          }
          interpolate(t) {
            return t;
          }
        }
        class Qa {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, i, s, l) {
            return !!t.expression.evaluate(i, null, {}, s, l);
          }
          interpolate() {
            return !1;
          }
        }
        class br {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const i in t) {
              const s = t[i];
              s.specification.overridable && this.overridableProperties.push(i);
              const l = this.defaultPropertyValues[i] = new oo(s, void 0), p = this.defaultTransitionablePropertyValues[i] = new vc(s);
              this.defaultTransitioningPropertyValues[i] = p.untransitioned(), this.defaultPossiblyEvaluatedValues[i] = l.possiblyEvaluate({});
            }
          }
        }
        We("DataDrivenProperty", dt), We("DataConstantProperty", nt), We("CrossFadedDataDrivenProperty", Ja), We("CrossFadedProperty", Kn), We("ColorRampProperty", Qa);
        const Qu = "-transition";
        class Kr extends rt {
          constructor(t, i) {
            if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, this._globalState = {}, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Ss(t.filter)), i.layout && (this._unevaluatedLayout = new Ju(i.layout)), i.paint)) {
              this._transitionablePaint = new Yu(i.paint);
              for (const s in t.paint) this.setPaintProperty(s, t.paint[s], { validate: !1 });
              for (const s in t.layout) this.setLayoutProperty(s, t.layout[s], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Ya(i.paint);
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Ss(t);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const i in this._unevaluatedLayout._values) {
              const s = this._unevaluatedLayout._values[i];
              for (const l of s.getGlobalStateRefs()) t.add(l);
            }
            for (const i of this._featureFilter.getGlobalStateRefs()) t.add(i);
            return t;
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const i = new globalThis.Map();
            if (this._transitionablePaint) for (const s in this._transitionablePaint._values) {
              const l = this._transitionablePaint._values[s].value;
              for (const p of l.getGlobalStateRefs()) {
                const f = (t = i.get(p)) !== null && t !== void 0 ? t : [];
                f.push({ name: s, value: l.value }), i.set(p, f);
              }
            }
            return i;
          }
          setLayoutProperty(t, i, s = {}) {
            i != null && this._validate(Cd, `layers.${this.id}.layout.${t}`, t, i, s) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, i) : this.visibility = i);
          }
          getPaintProperty(t) {
            return t.endsWith(Qu) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
          }
          setPaintProperty(t, i, s = {}) {
            if (i != null && this._validate(Md, `layers.${this.id}.paint.${t}`, t, i, s)) return !1;
            if (t.endsWith(Qu)) return this._transitionablePaint.setTransition(t.slice(0, -11), i || void 0), !1;
            {
              const l = this._transitionablePaint._values[t], p = l.property.specification["property-type"] === "cross-faded-data-driven", f = l.value.isDataDriven(), _ = l.value;
              this._transitionablePaint.setValue(t, i), this._handleSpecialPaintPropertyUpdate(t);
              const y = this._transitionablePaint._values[t].value;
              return y.isDataDriven() || f || p || this._handleOverridablePaintPropertyUpdate(t, _, y);
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {
          }
          _handleOverridablePaintPropertyUpdate(t, i, s) {
            return !1;
          }
          isHidden(t) {
            return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t, i) {
            t.globalState = this._globalState, t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, i)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, i);
          }
          setGlobalState(t) {
            this._globalState = t, this._unevaluatedLayout && this._unevaluatedLayout.setGlobalState(t);
          }
          serialize() {
            const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), hs(t, (i, s) => !(i === void 0 || s === "layout" && !Object.keys(i).length || s === "paint" && !Object.keys(i).length));
          }
          _validate(t, i, s, l, p = {}) {
            return (!p || p.validate !== !1) && Ko(this, t.call(no, { key: i, layerType: this.type, objectKey: s, value: l, styleSpec: fe, style: { glyphs: !0, sprite: !0 } }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {
          }
          isStateDependent() {
            for (const t in this.paint._values) {
              const i = this.paint.get(t);
              if (i instanceof Pn && Wn(i.property.specification) && (i.value.kind === "source" || i.value.kind === "composite") && i.value.isStateDependent) return !0;
            }
            return !1;
          }
        }
        const Ad = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Jo {
          constructor(t, i) {
            this._structArray = t, this._pos1 = i * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class ii {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(t, i) {
            return t._trim(), i && (t.isTransferred = !0, i.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
          }
          static deserialize(t) {
            const i = Object.create(this.prototype);
            return i.arrayBuffer = t.arrayBuffer, i.length = t.length, i.capacity = t.arrayBuffer.byteLength / i.bytesPerElement, i._refreshViews(), i;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t) {
            this.reserve(t), this.length = t;
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const i = this.uint8;
              this._refreshViews(), i && this.uint8.set(i);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Pi(r, t = 1) {
          let i = 0, s = 0;
          return { members: r.map((l) => {
            const p = Ad[l.type].BYTES_PER_ELEMENT, f = i = el(i, Math.max(t, p)), _ = l.components || 1;
            return s = Math.max(s, p), i += p * _, { name: l.name, type: l.type, components: _, offset: f };
          }), size: el(i, Math.max(s, t)), alignment: t };
        }
        function el(r, t) {
          return Math.ceil(r / t) * t;
        }
        class ao extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, i) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, t, i);
          }
          emplace(t, i, s) {
            const l = 2 * t;
            return this.int16[l + 0] = i, this.int16[l + 1] = s, t;
          }
        }
        ao.prototype.bytesPerElement = 4, We("StructArrayLayout2i4", ao);
        class lo extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, i, s);
          }
          emplace(t, i, s, l) {
            const p = 3 * t;
            return this.int16[p + 0] = i, this.int16[p + 1] = s, this.int16[p + 2] = l, t;
          }
        }
        lo.prototype.bytesPerElement = 6, We("StructArrayLayout3i6", lo);
        class wc extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, i, s, l);
          }
          emplace(t, i, s, l, p) {
            const f = 4 * t;
            return this.int16[f + 0] = i, this.int16[f + 1] = s, this.int16[f + 2] = l, this.int16[f + 3] = p, t;
          }
        }
        wc.prototype.bytesPerElement = 8, We("StructArrayLayout4i8", wc);
        class co extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, i, s, l, p, f);
          }
          emplace(t, i, s, l, p, f, _) {
            const y = 6 * t;
            return this.int16[y + 0] = i, this.int16[y + 1] = s, this.int16[y + 2] = l, this.int16[y + 3] = p, this.int16[y + 4] = f, this.int16[y + 5] = _, t;
          }
        }
        co.prototype.bytesPerElement = 12, We("StructArrayLayout2i4i12", co);
        class Is extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, i, s, l, p, f);
          }
          emplace(t, i, s, l, p, f, _) {
            const y = 4 * t, w = 8 * t;
            return this.int16[y + 0] = i, this.int16[y + 1] = s, this.uint8[w + 4] = l, this.uint8[w + 5] = p, this.uint8[w + 6] = f, this.uint8[w + 7] = _, t;
          }
        }
        Is.prototype.bytesPerElement = 8, We("StructArrayLayout2i4ub8", Is);
        class Qo extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, i) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, t, i);
          }
          emplace(t, i, s) {
            const l = 2 * t;
            return this.float32[l + 0] = i, this.float32[l + 1] = s, t;
          }
        }
        Qo.prototype.bytesPerElement = 8, We("StructArrayLayout2f8", Qo);
        class tl extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l, p, f, _, y, w, P) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, t, i, s, l, p, f, _, y, w, P);
          }
          emplace(t, i, s, l, p, f, _, y, w, P, I) {
            const z = 10 * t;
            return this.uint16[z + 0] = i, this.uint16[z + 1] = s, this.uint16[z + 2] = l, this.uint16[z + 3] = p, this.uint16[z + 4] = f, this.uint16[z + 5] = _, this.uint16[z + 6] = y, this.uint16[z + 7] = w, this.uint16[z + 8] = P, this.uint16[z + 9] = I, t;
          }
        }
        tl.prototype.bytesPerElement = 20, We("StructArrayLayout10ui20", tl);
        class Es extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l, p, f, _, y, w, P, I, z) {
            const L = this.length;
            return this.resize(L + 1), this.emplace(L, t, i, s, l, p, f, _, y, w, P, I, z);
          }
          emplace(t, i, s, l, p, f, _, y, w, P, I, z, L) {
            const F = 12 * t;
            return this.int16[F + 0] = i, this.int16[F + 1] = s, this.int16[F + 2] = l, this.int16[F + 3] = p, this.uint16[F + 4] = f, this.uint16[F + 5] = _, this.uint16[F + 6] = y, this.uint16[F + 7] = w, this.int16[F + 8] = P, this.int16[F + 9] = I, this.int16[F + 10] = z, this.int16[F + 11] = L, t;
          }
        }
        Es.prototype.bytesPerElement = 24, We("StructArrayLayout4i4ui4i24", Es);
        class Tc extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, i, s);
          }
          emplace(t, i, s, l) {
            const p = 3 * t;
            return this.float32[p + 0] = i, this.float32[p + 1] = s, this.float32[p + 2] = l, t;
          }
        }
        Tc.prototype.bytesPerElement = 12, We("StructArrayLayout3f12", Tc);
        class Sc extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, t);
          }
          emplace(t, i) {
            return this.uint32[1 * t + 0] = i, t;
          }
        }
        Sc.prototype.bytesPerElement = 4, We("StructArrayLayout1ul4", Sc);
        class il extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l, p, f, _, y, w) {
            const P = this.length;
            return this.resize(P + 1), this.emplace(P, t, i, s, l, p, f, _, y, w);
          }
          emplace(t, i, s, l, p, f, _, y, w, P) {
            const I = 10 * t, z = 5 * t;
            return this.int16[I + 0] = i, this.int16[I + 1] = s, this.int16[I + 2] = l, this.int16[I + 3] = p, this.int16[I + 4] = f, this.int16[I + 5] = _, this.uint32[z + 3] = y, this.uint16[I + 8] = w, this.uint16[I + 9] = P, t;
          }
        }
        il.prototype.bytesPerElement = 20, We("StructArrayLayout6i1ul2ui20", il);
        class Pc extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, i, s, l, p, f);
          }
          emplace(t, i, s, l, p, f, _) {
            const y = 6 * t;
            return this.int16[y + 0] = i, this.int16[y + 1] = s, this.int16[y + 2] = l, this.int16[y + 3] = p, this.int16[y + 4] = f, this.int16[y + 5] = _, t;
          }
        }
        Pc.prototype.bytesPerElement = 12, We("StructArrayLayout2i2i2i12", Pc);
        class h extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l, p) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, i, s, l, p);
          }
          emplace(t, i, s, l, p, f) {
            const _ = 4 * t, y = 8 * t;
            return this.float32[_ + 0] = i, this.float32[_ + 1] = s, this.float32[_ + 2] = l, this.int16[y + 6] = p, this.int16[y + 7] = f, t;
          }
        }
        h.prototype.bytesPerElement = 16, We("StructArrayLayout2f1f2i16", h);
        class e extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, i, s, l, p, f);
          }
          emplace(t, i, s, l, p, f, _) {
            const y = 16 * t, w = 4 * t, P = 8 * t;
            return this.uint8[y + 0] = i, this.uint8[y + 1] = s, this.float32[w + 1] = l, this.float32[w + 2] = p, this.int16[P + 6] = f, this.int16[P + 7] = _, t;
          }
        }
        e.prototype.bytesPerElement = 16, We("StructArrayLayout2ub2f2i16", e);
        class n extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, i, s);
          }
          emplace(t, i, s, l) {
            const p = 3 * t;
            return this.uint16[p + 0] = i, this.uint16[p + 1] = s, this.uint16[p + 2] = l, t;
          }
        }
        n.prototype.bytesPerElement = 6, We("StructArrayLayout3ui6", n);
        class o extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l, p, f, _, y, w, P, I, z, L, F, V, $, H) {
            const he = this.length;
            return this.resize(he + 1), this.emplace(he, t, i, s, l, p, f, _, y, w, P, I, z, L, F, V, $, H);
          }
          emplace(t, i, s, l, p, f, _, y, w, P, I, z, L, F, V, $, H, he) {
            const ee = 24 * t, re = 12 * t, ye = 48 * t;
            return this.int16[ee + 0] = i, this.int16[ee + 1] = s, this.uint16[ee + 2] = l, this.uint16[ee + 3] = p, this.uint32[re + 2] = f, this.uint32[re + 3] = _, this.uint32[re + 4] = y, this.uint16[ee + 10] = w, this.uint16[ee + 11] = P, this.uint16[ee + 12] = I, this.float32[re + 7] = z, this.float32[re + 8] = L, this.uint8[ye + 36] = F, this.uint8[ye + 37] = V, this.uint8[ye + 38] = $, this.uint32[re + 10] = H, this.int16[ee + 22] = he, t;
          }
        }
        o.prototype.bytesPerElement = 48, We("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", o);
        class c extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l, p, f, _, y, w, P, I, z, L, F, V, $, H, he, ee, re, ye, Te, Ee, $e, Be, Ve, st, je) {
            const Ne = this.length;
            return this.resize(Ne + 1), this.emplace(Ne, t, i, s, l, p, f, _, y, w, P, I, z, L, F, V, $, H, he, ee, re, ye, Te, Ee, $e, Be, Ve, st, je);
          }
          emplace(t, i, s, l, p, f, _, y, w, P, I, z, L, F, V, $, H, he, ee, re, ye, Te, Ee, $e, Be, Ve, st, je, Ne) {
            const Me = 32 * t, mt = 16 * t;
            return this.int16[Me + 0] = i, this.int16[Me + 1] = s, this.int16[Me + 2] = l, this.int16[Me + 3] = p, this.int16[Me + 4] = f, this.int16[Me + 5] = _, this.int16[Me + 6] = y, this.int16[Me + 7] = w, this.uint16[Me + 8] = P, this.uint16[Me + 9] = I, this.uint16[Me + 10] = z, this.uint16[Me + 11] = L, this.uint16[Me + 12] = F, this.uint16[Me + 13] = V, this.uint16[Me + 14] = $, this.uint16[Me + 15] = H, this.uint16[Me + 16] = he, this.uint16[Me + 17] = ee, this.uint16[Me + 18] = re, this.uint16[Me + 19] = ye, this.uint16[Me + 20] = Te, this.uint16[Me + 21] = Ee, this.uint16[Me + 22] = $e, this.uint32[mt + 12] = Be, this.float32[mt + 13] = Ve, this.float32[mt + 14] = st, this.uint16[Me + 30] = je, this.uint16[Me + 31] = Ne, t;
          }
        }
        c.prototype.bytesPerElement = 64, We("StructArrayLayout8i15ui1ul2f2ui64", c);
        class d extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, t);
          }
          emplace(t, i) {
            return this.float32[1 * t + 0] = i, t;
          }
        }
        d.prototype.bytesPerElement = 4, We("StructArrayLayout1f4", d);
        class g extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, i, s);
          }
          emplace(t, i, s, l) {
            const p = 3 * t;
            return this.uint16[6 * t + 0] = i, this.float32[p + 1] = s, this.float32[p + 2] = l, t;
          }
        }
        g.prototype.bytesPerElement = 12, We("StructArrayLayout1ui2f12", g);
        class v extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, i, s);
          }
          emplace(t, i, s, l) {
            const p = 4 * t;
            return this.uint32[2 * t + 0] = i, this.uint16[p + 2] = s, this.uint16[p + 3] = l, t;
          }
        }
        v.prototype.bytesPerElement = 8, We("StructArrayLayout1ul2ui8", v);
        class x extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, i) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, t, i);
          }
          emplace(t, i, s) {
            const l = 2 * t;
            return this.uint16[l + 0] = i, this.uint16[l + 1] = s, t;
          }
        }
        x.prototype.bytesPerElement = 4, We("StructArrayLayout2ui4", x);
        class M extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, t);
          }
          emplace(t, i) {
            return this.uint16[1 * t + 0] = i, t;
          }
        }
        M.prototype.bytesPerElement = 2, We("StructArrayLayout1ui2", M);
        class C extends ii {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, i, s, l) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, i, s, l);
          }
          emplace(t, i, s, l, p) {
            const f = 4 * t;
            return this.float32[f + 0] = i, this.float32[f + 1] = s, this.float32[f + 2] = l, this.float32[f + 3] = p, t;
          }
        }
        C.prototype.bytesPerElement = 16, We("StructArrayLayout4f16", C);
        class k extends Jo {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new U(this.anchorPointX, this.anchorPointY);
          }
        }
        k.prototype.size = 20;
        class A extends il {
          get(t) {
            return new k(this, t);
          }
        }
        We("CollisionBoxArray", A);
        class R extends Jo {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        R.prototype.size = 48;
        class O extends o {
          get(t) {
            return new R(this, t);
          }
        }
        We("PlacedSymbolArray", O);
        class G extends Jo {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        G.prototype.size = 64;
        class Z extends c {
          get(t) {
            return new G(this, t);
          }
        }
        We("SymbolInstanceArray", Z);
        class q extends d {
          getoffsetX(t) {
            return this.float32[1 * t + 0];
          }
        }
        We("GlyphOffsetArray", q);
        class W extends lo {
          getx(t) {
            return this.int16[3 * t + 0];
          }
          gety(t) {
            return this.int16[3 * t + 1];
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2];
          }
        }
        We("SymbolLineVertexArray", W);
        class J extends Jo {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        J.prototype.size = 12;
        class K extends g {
          get(t) {
            return new J(this, t);
          }
        }
        We("TextAnchorOffsetArray", K);
        class te extends Jo {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        te.prototype.size = 8;
        class se extends v {
          get(t) {
            return new te(this, t);
          }
        }
        We("FeatureIndexArray", se);
        class Y extends ao {
        }
        class pe extends ao {
        }
        class be extends ao {
        }
        class ge extends co {
        }
        class _e extends Is {
        }
        class xe extends Qo {
        }
        class Le extends tl {
        }
        class Oe extends Es {
        }
        class Ie extends Tc {
        }
        class et extends Sc {
        }
        class Ct extends Pc {
        }
        class Kt extends e {
        }
        class ri extends n {
        }
        class ei extends x {
        }
        const gi = Pi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: bi } = gi;
        class Pt {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t;
          }
          prepareSegment(t, i, s, l) {
            const p = this.segments[this.segments.length - 1];
            return t > Pt.MAX_VERTEX_ARRAY_LENGTH && Se(`Max vertices per segment is ${Pt.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Pt.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !p || p.vertexLength + t > Pt.MAX_VERTEX_ARRAY_LENGTH || p.sortKey !== l ? this.createNewSegment(i, s, l) : p;
          }
          createNewSegment(t, i, s) {
            const l = { vertexOffset: t.length, primitiveOffset: i.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return s !== void 0 && (l.sortKey = s), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(l), l;
          }
          getOrCreateLatestSegment(t, i, s) {
            return this.prepareSegment(0, t, i, s);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t of this.segments) for (const i in t.vaos) t.vaos[i].destroy();
          }
          static simpleSegment(t, i, s, l) {
            return new Pt([{ vertexOffset: t, primitiveOffset: i, vertexLength: s, primitiveLength: l, vaos: {}, sortKey: 0 }]);
          }
        }
        function ni(r, t) {
          return 256 * (r = zi(Math.floor(r), 0, 255)) + zi(Math.floor(t), 0, 255);
        }
        Pt.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, We("SegmentVector", Pt);
        const Li = Pi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var Ni, Wi, wr, cn = { exports: {} }, Yn = { exports: {} }, Jn = { exports: {} }, uo = function() {
          if (wr) return cn.exports;
          wr = 1;
          var r = (Ni || (Ni = 1, Yn.exports = function(i, s) {
            var l, p, f, _, y, w, P, I;
            for (p = i.length - (l = 3 & i.length), f = s, y = 3432918353, w = 461845907, I = 0; I < p; ) P = 255 & i.charCodeAt(I) | (255 & i.charCodeAt(++I)) << 8 | (255 & i.charCodeAt(++I)) << 16 | (255 & i.charCodeAt(++I)) << 24, ++I, f = 27492 + (65535 & (_ = 5 * (65535 & (f = (f ^= P = (65535 & (P = (P = (65535 & P) * y + (((P >>> 16) * y & 65535) << 16) & 4294967295) << 15 | P >>> 17)) * w + (((P >>> 16) * w & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (_ >>> 16) & 65535) << 16);
            switch (P = 0, l) {
              case 3:
                P ^= (255 & i.charCodeAt(I + 2)) << 16;
              case 2:
                P ^= (255 & i.charCodeAt(I + 1)) << 8;
              case 1:
                f ^= P = (65535 & (P = (P = (65535 & (P ^= 255 & i.charCodeAt(I))) * y + (((P >>> 16) * y & 65535) << 16) & 4294967295) << 15 | P >>> 17)) * w + (((P >>> 16) * w & 65535) << 16) & 4294967295;
            }
            return f ^= i.length, f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295, f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295, (f ^= f >>> 16) >>> 0;
          }), Yn.exports), t = (Wi || (Wi = 1, Jn.exports = function(i, s) {
            for (var l, p = i.length, f = s ^ p, _ = 0; p >= 4; ) l = 1540483477 * (65535 & (l = 255 & i.charCodeAt(_) | (255 & i.charCodeAt(++_)) << 8 | (255 & i.charCodeAt(++_)) << 16 | (255 & i.charCodeAt(++_)) << 24)) + ((1540483477 * (l >>> 16) & 65535) << 16), f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (l = 1540483477 * (65535 & (l ^= l >>> 24)) + ((1540483477 * (l >>> 16) & 65535) << 16)), p -= 4, ++_;
            switch (p) {
              case 3:
                f ^= (255 & i.charCodeAt(_ + 2)) << 16;
              case 2:
                f ^= (255 & i.charCodeAt(_ + 1)) << 8;
              case 1:
                f = 1540483477 * (65535 & (f ^= 255 & i.charCodeAt(_))) + ((1540483477 * (f >>> 16) & 65535) << 16);
            }
            return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16), (f ^= f >>> 15) >>> 0;
          }), Jn.exports);
          return cn.exports = r, cn.exports.murmur3 = r, cn.exports.murmur2 = t, cn.exports;
        }(), ho = ue(uo);
        class As {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(t, i, s, l) {
            this.ids.push(ks(t)), this.positions.push(i, s, l);
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const i = ks(t);
            let s = 0, l = this.ids.length - 1;
            for (; s < l; ) {
              const f = s + l >> 1;
              this.ids[f] >= i ? l = f : s = f + 1;
            }
            const p = [];
            for (; this.ids[s] === i; ) p.push({ index: this.positions[3 * s], start: this.positions[3 * s + 1], end: this.positions[3 * s + 2] }), s++;
            return p;
          }
          static serialize(t, i) {
            const s = new Float64Array(t.ids), l = new Uint32Array(t.positions);
            return Ar(s, l, 0, s.length - 1), i && i.push(s.buffer, l.buffer), { ids: s, positions: l };
          }
          static deserialize(t) {
            const i = new As();
            return i.ids = t.ids, i.positions = t.positions, i.indexed = !0, i;
          }
        }
        function ks(r) {
          const t = +r;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : ho(String(r));
        }
        function Ar(r, t, i, s) {
          for (; i < s; ) {
            const l = r[i + s >> 1];
            let p = i - 1, f = s + 1;
            for (; ; ) {
              do
                p++;
              while (r[p] < l);
              do
                f--;
              while (r[f] > l);
              if (p >= f) break;
              un(r, p, f), un(t, 3 * p, 3 * f), un(t, 3 * p + 1, 3 * f + 1), un(t, 3 * p + 2, 3 * f + 2);
            }
            f - i < s - f ? (Ar(r, t, i, f), i = f + 1) : (Ar(r, t, f + 1, s), s = f);
          }
        }
        function un(r, t, i) {
          const s = r[t];
          r[t] = r[i], r[i] = s;
        }
        We("FeaturePositionMap", As);
        class Tr {
          constructor(t, i) {
            this.gl = t.gl, this.location = i;
          }
        }
        class Qn extends Tr {
          constructor(t, i) {
            super(t, i), this.current = 0;
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
          }
        }
        class Fi extends Tr {
          constructor(t, i) {
            super(t, i), this.current = [0, 0, 0, 0];
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
          }
        }
        class $i extends Tr {
          constructor(t, i) {
            super(t, i), this.current = Bt.transparent;
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
          }
        }
        const Yr = new Float32Array(16);
        function Bi(r) {
          return [ni(255 * r.r, 255 * r.g), ni(255 * r.b, 255 * r.a)];
        }
        class ea {
          constructor(t, i, s) {
            this.value = t, this.uniformNames = i.map((l) => `u_${l}`), this.type = s;
          }
          setUniform(t, i, s) {
            t.set(s.constantOr(this.value));
          }
          getBinding(t, i, s) {
            return this.type === "color" ? new $i(t, i) : new Qn(t, i);
          }
        }
        class po {
          constructor(t, i) {
            this.uniformNames = i.map((s) => `u_${s}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t, i) {
            this.pixelRatioFrom = i.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = i.tlbr, this.patternTo = t.tlbr;
          }
          setUniform(t, i, s, l) {
            const p = l === "u_pattern_to" ? this.patternTo : l === "u_pattern_from" ? this.patternFrom : l === "u_pixel_ratio_to" ? this.pixelRatioTo : l === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            p && t.set(p);
          }
          getBinding(t, i, s) {
            return s.substr(0, 9) === "u_pattern" ? new Fi(t, i) : new Qn(t, i);
          }
        }
        class zn {
          constructor(t, i, s, l) {
            this.expression = t, this.type = s, this.maxValue = 0, this.paintVertexAttributes = i.map((p) => ({ name: `a_${p}`, type: "Float32", components: s === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new l();
          }
          populatePaintArray(t, i, s) {
            const l = this.paintVertexArray.length, p = this.expression.evaluate(new ai(0, s), i, {}, s.canonical, [], s.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(l, t, p);
          }
          updatePaintArray(t, i, s, l, p) {
            const f = this.expression.evaluate(new ai(0, p), s, l);
            this._setPaintValue(t, i, f);
          }
          _setPaintValue(t, i, s) {
            if (this.type === "color") {
              const l = Bi(s);
              for (let p = t; p < i; p++) this.paintVertexArray.emplace(p, l[0], l[1]);
            } else {
              for (let l = t; l < i; l++) this.paintVertexArray.emplace(l, s);
              this.maxValue = Math.max(this.maxValue, Math.abs(s));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class hn {
          constructor(t, i, s, l, p, f) {
            this.expression = t, this.uniformNames = i.map((_) => `u_${_}_t`), this.type = s, this.useIntegerZoom = l, this.zoom = p, this.maxValue = 0, this.paintVertexAttributes = i.map((_) => ({ name: `a_${_}`, type: "Float32", components: s === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new f();
          }
          populatePaintArray(t, i, s) {
            const l = this.expression.evaluate(new ai(this.zoom, s), i, {}, s.canonical, [], s.formattedSection), p = this.expression.evaluate(new ai(this.zoom + 1, s), i, {}, s.canonical, [], s.formattedSection), f = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(f, t, l, p);
          }
          updatePaintArray(t, i, s, l, p) {
            const f = this.expression.evaluate(new ai(this.zoom, p), s, l), _ = this.expression.evaluate(new ai(this.zoom + 1, p), s, l);
            this._setPaintValue(t, i, f, _);
          }
          _setPaintValue(t, i, s, l) {
            if (this.type === "color") {
              const p = Bi(s), f = Bi(l);
              for (let _ = t; _ < i; _++) this.paintVertexArray.emplace(_, p[0], p[1], f[0], f[1]);
            } else {
              for (let p = t; p < i; p++) this.paintVertexArray.emplace(p, s, l);
              this.maxValue = Math.max(this.maxValue, Math.abs(s), Math.abs(l));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t, i) {
            const s = this.useIntegerZoom ? Math.floor(i.zoom) : i.zoom, l = zi(this.expression.interpolationFactor(s, this.zoom, this.zoom + 1), 0, 1);
            t.set(l);
          }
          getBinding(t, i, s) {
            return new Qn(t, i);
          }
        }
        class es {
          constructor(t, i, s, l, p, f) {
            this.expression = t, this.type = i, this.useIntegerZoom = s, this.zoom = l, this.layerId = f, this.zoomInPaintVertexArray = new p(), this.zoomOutPaintVertexArray = new p();
          }
          populatePaintArray(t, i, s) {
            const l = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(l, t, i.patterns && i.patterns[this.layerId], s.imagePositions);
          }
          updatePaintArray(t, i, s, l, p) {
            this._setPaintValues(t, i, s.patterns && s.patterns[this.layerId], p.imagePositions);
          }
          _setPaintValues(t, i, s, l) {
            if (!l || !s) return;
            const { min: p, mid: f, max: _ } = s, y = l[p], w = l[f], P = l[_];
            if (y && w && P) for (let I = t; I < i; I++) this.zoomInPaintVertexArray.emplace(I, w.tl[0], w.tl[1], w.br[0], w.br[1], y.tl[0], y.tl[1], y.br[0], y.br[1], w.pixelRatio, y.pixelRatio), this.zoomOutPaintVertexArray.emplace(I, w.tl[0], w.tl[1], w.br[0], w.br[1], P.tl[0], P.tl[1], P.br[0], P.br[1], w.pixelRatio, P.pixelRatio);
          }
          upload(t) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, Li.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, Li.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class eh {
          constructor(t, i, s) {
            this.binders = {}, this._buffers = [];
            const l = [];
            for (const p in t.paint._values) {
              if (!s(p)) continue;
              const f = t.paint.get(p);
              if (!(f instanceof Pn && Wn(f.property.specification))) continue;
              const _ = th(p, t.type), y = f.value, w = f.property.specification.type, P = f.property.useIntegerZoom, I = f.property.specification["property-type"], z = I === "cross-faded" || I === "cross-faded-data-driven";
              if (y.kind === "constant") this.binders[p] = z ? new po(y.value, _) : new ea(y.value, _, w), l.push(`/u_${p}`);
              else if (y.kind === "source" || z) {
                const L = Mc(p, w, "source");
                this.binders[p] = z ? new es(y, w, P, i, L, t.id) : new zn(y, _, w, L), l.push(`/a_${p}`);
              } else {
                const L = Mc(p, w, "composite");
                this.binders[p] = new hn(y, _, w, P, i, L), l.push(`/z_${p}`);
              }
            }
            this.cacheKey = l.sort().join("");
          }
          getMaxValue(t) {
            const i = this.binders[t];
            return i instanceof zn || i instanceof hn ? i.maxValue : 0;
          }
          populatePaintArrays(t, i, s) {
            for (const l in this.binders) {
              const p = this.binders[l];
              (p instanceof zn || p instanceof hn || p instanceof es) && p.populatePaintArray(t, i, s);
            }
          }
          setConstantPatternPositions(t, i) {
            for (const s in this.binders) {
              const l = this.binders[s];
              l instanceof po && l.setConstantPatternPositions(t, i);
            }
          }
          updatePaintArrays(t, i, s, l, p) {
            let f = !1;
            for (const _ in t) {
              const y = i.getPositions(_);
              for (const w of y) {
                const P = s.feature(w.index);
                for (const I in this.binders) {
                  const z = this.binders[I];
                  if ((z instanceof zn || z instanceof hn || z instanceof es) && z.expression.isStateDependent === !0) {
                    const L = l.paint.get(I);
                    z.expression = L.value, z.updatePaintArray(w.start, w.end, P, t[_], p), f = !0;
                  }
                }
              }
            }
            return f;
          }
          defines() {
            const t = [];
            for (const i in this.binders) {
              const s = this.binders[i];
              (s instanceof ea || s instanceof po) && t.push(...s.uniformNames.map((l) => `#define HAS_UNIFORM_${l}`));
            }
            return t;
          }
          getBinderAttributes() {
            const t = [];
            for (const i in this.binders) {
              const s = this.binders[i];
              if (s instanceof zn || s instanceof hn) for (let l = 0; l < s.paintVertexAttributes.length; l++) t.push(s.paintVertexAttributes[l].name);
              else if (s instanceof es) for (let l = 0; l < Li.members.length; l++) t.push(Li.members[l].name);
            }
            return t;
          }
          getBinderUniforms() {
            const t = [];
            for (const i in this.binders) {
              const s = this.binders[i];
              if (s instanceof ea || s instanceof po || s instanceof hn) for (const l of s.uniformNames) t.push(l);
            }
            return t;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t, i) {
            const s = [];
            for (const l in this.binders) {
              const p = this.binders[l];
              if (p instanceof ea || p instanceof po || p instanceof hn) {
                for (const f of p.uniformNames) if (i[f]) {
                  const _ = p.getBinding(t, i[f], f);
                  s.push({ name: f, property: l, binding: _ });
                }
              }
            }
            return s;
          }
          setUniforms(t, i, s, l) {
            for (const { name: p, property: f, binding: _ } of i) this.binders[f].setUniform(_, l, s.get(f), p);
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const i in this.binders) {
              const s = this.binders[i];
              if (t && s instanceof es) {
                const l = t.fromScale === 2 ? s.zoomInPaintVertexBuffer : s.zoomOutPaintVertexBuffer;
                l && this._buffers.push(l);
              } else (s instanceof zn || s instanceof hn) && s.paintVertexBuffer && this._buffers.push(s.paintVertexBuffer);
            }
          }
          upload(t) {
            for (const i in this.binders) {
              const s = this.binders[i];
              (s instanceof zn || s instanceof hn || s instanceof es) && s.upload(t);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t in this.binders) {
              const i = this.binders[t];
              (i instanceof zn || i instanceof hn || i instanceof es) && i.destroy();
            }
          }
        }
        class Br {
          constructor(t, i, s = () => !0) {
            this.programConfigurations = {};
            for (const l of t) this.programConfigurations[l.id] = new eh(l, i, s);
            this.needsUpload = !1, this._featureMap = new As(), this._bufferOffset = 0;
          }
          populatePaintArrays(t, i, s, l) {
            for (const p in this.programConfigurations) this.programConfigurations[p].populatePaintArrays(t, i, l);
            i.id !== void 0 && this._featureMap.add(i.id, s, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
          }
          updatePaintArrays(t, i, s, l) {
            for (const p of s) this.needsUpload = this.programConfigurations[p.id].updatePaintArrays(t, this._featureMap, i, p, l) || this.needsUpload;
          }
          get(t) {
            return this.programConfigurations[t];
          }
          upload(t) {
            if (this.needsUpload) {
              for (const i in this.programConfigurations) this.programConfigurations[i].upload(t);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
          }
        }
        function th(r, t) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[r] || [r.replace(`${t}-`, "").replace(/-/g, "_")];
        }
        function Mc(r, t, i) {
          const s = { color: { source: Qo, composite: C }, number: { source: d, composite: Qo } }, l = function(p) {
            return { "line-pattern": { source: Le, composite: Le }, "fill-pattern": { source: Le, composite: Le }, "fill-extrusion-pattern": { source: Le, composite: Le } }[p];
          }(r);
          return l && l[i] || s[t][i];
        }
        We("ConstantBinder", ea), We("CrossFadedConstantBinder", po), We("SourceExpressionBinder", zn), We("CrossFadedCompositeBinder", es), We("CompositeExpressionBinder", hn), We("ProgramConfiguration", eh, { omit: ["_buffers"] }), We("ProgramConfigurationSet", Br);
        const rl = Math.pow(2, 14) - 1, nl = -rl - 1;
        function ts(r) {
          const t = Zt / r.extent, i = r.loadGeometry();
          for (let s = 0; s < i.length; s++) {
            const l = i[s];
            for (let p = 0; p < l.length; p++) {
              const f = l[p], _ = Math.round(f.x * t), y = Math.round(f.y * t);
              f.x = zi(_, nl, rl), f.y = zi(y, nl, rl), (_ < f.x || _ > f.x + 1 || y < f.y || y > f.y + 1) && Se("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return i;
        }
        function Rn(r, t) {
          return { type: r.type, id: r.id, properties: r.properties, geometry: t ? ts(r) : [] };
        }
        const uf = -32768;
        function X_(r, t, i, s, l) {
          r.emplaceBack(uf + 8 * t + s, uf + 8 * i + l);
        }
        class kd {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((i) => i.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new pe(), this.indexArray = new ri(), this.segments = new Pt(), this.programConfigurations = new Br(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id);
          }
          populate(t, i, s) {
            const l = this.layers[0], p = [];
            let f = null, _ = !1, y = l.type === "heatmap";
            if (l.type === "circle") {
              const P = l;
              f = P.layout.get("circle-sort-key"), _ = !f.isConstant(), y = y || P.paint.get("circle-pitch-alignment") === "map";
            }
            const w = y ? i.subdivisionGranularity.circle : 1;
            for (const { feature: P, id: I, index: z, sourceLayerIndex: L } of t) {
              const F = this.layers[0]._featureFilter.needGeometry, V = Rn(P, F);
              if (!this.layers[0]._featureFilter.filter(new ai(this.zoom, { globalState: this.globalState }), V, s)) continue;
              const $ = _ ? f.evaluate(V, {}, s) : void 0, H = { id: I, properties: P.properties, type: P.type, sourceLayerIndex: L, index: z, geometry: F ? V.geometry : ts(P), patterns: {}, sortKey: $ };
              p.push(H);
            }
            _ && p.sort((P, I) => P.sortKey - I.sortKey);
            for (const P of p) {
              const { geometry: I, index: z, sourceLayerIndex: L } = P, F = t[z].feature;
              this.addFeature(P, I, z, s, w), i.featureIndex.insert(F, I, z, L, this.index);
            }
          }
          update(t, i, s) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, { imagePositions: s, globalState: this.globalState });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, bi), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t, i, s, l, p = 1) {
            let f;
            switch (p) {
              case 1:
                f = [0, 7];
                break;
              case 3:
                f = [0, 2, 5, 7];
                break;
              case 5:
                f = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                f = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${p}; valid values are 1, 3, 5, 7.`);
            }
            const _ = f.length;
            for (const y of i) for (const w of y) {
              const P = w.x, I = w.y;
              if (P < 0 || P >= Zt || I < 0 || I >= Zt) continue;
              const z = this.segments.prepareSegment(_ * _, this.layoutVertexArray, this.indexArray, t.sortKey), L = z.vertexLength;
              for (let F = 0; F < _; F++) for (let V = 0; V < _; V++) X_(this.layoutVertexArray, P, I, f[V], f[F]);
              for (let F = 0; F < _ - 1; F++) for (let V = 0; V < _ - 1; V++) {
                const $ = L + F * _ + V, H = L + (F + 1) * _ + V;
                this.indexArray.emplaceBack($, H + 1, $ + 1), this.indexArray.emplaceBack($, H, H + 1);
              }
              z.vertexLength += _ * _, z.primitiveLength += (_ - 1) * (_ - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, { imagePositions: {}, canonical: l, globalState: this.globalState });
          }
        }
        function hf(r, t) {
          for (let i = 0; i < r.length; i++) if (sl(t, r[i])) return !0;
          for (let i = 0; i < t.length; i++) if (sl(r, t[i])) return !0;
          return !!zd(r, t);
        }
        function K_(r, t, i) {
          return !!sl(r, t) || !!Rd(t, r, i);
        }
        function df(r, t) {
          if (r.length === 1) return ff(t, r[0]);
          for (let i = 0; i < t.length; i++) {
            const s = t[i];
            for (let l = 0; l < s.length; l++) if (sl(r, s[l])) return !0;
          }
          for (let i = 0; i < r.length; i++) if (ff(t, r[i])) return !0;
          for (let i = 0; i < t.length; i++) if (zd(r, t[i])) return !0;
          return !1;
        }
        function Y_(r, t, i) {
          if (r.length > 1) {
            if (zd(r, t)) return !0;
            for (let s = 0; s < t.length; s++) if (Rd(t[s], r, i)) return !0;
          }
          for (let s = 0; s < r.length; s++) if (Rd(r[s], t, i)) return !0;
          return !1;
        }
        function zd(r, t) {
          if (r.length === 0 || t.length === 0) return !1;
          for (let i = 0; i < r.length - 1; i++) {
            const s = r[i], l = r[i + 1];
            for (let p = 0; p < t.length - 1; p++) if (J_(s, l, t[p], t[p + 1])) return !0;
          }
          return !1;
        }
        function J_(r, t, i, s) {
          return ze(r, i, s) !== ze(t, i, s) && ze(r, t, i) !== ze(r, t, s);
        }
        function Rd(r, t, i) {
          const s = i * i;
          if (t.length === 1) return r.distSqr(t[0]) < s;
          for (let l = 1; l < t.length; l++) if (pf(r, t[l - 1], t[l]) < s) return !0;
          return !1;
        }
        function pf(r, t, i) {
          const s = t.distSqr(i);
          if (s === 0) return r.distSqr(t);
          const l = ((r.x - t.x) * (i.x - t.x) + (r.y - t.y) * (i.y - t.y)) / s;
          return r.distSqr(l < 0 ? t : l > 1 ? i : i.sub(t)._mult(l)._add(t));
        }
        function ff(r, t) {
          let i, s, l, p = !1;
          for (let f = 0; f < r.length; f++) {
            i = r[f];
            for (let _ = 0, y = i.length - 1; _ < i.length; y = _++) s = i[_], l = i[y], s.y > t.y != l.y > t.y && t.x < (l.x - s.x) * (t.y - s.y) / (l.y - s.y) + s.x && (p = !p);
          }
          return p;
        }
        function sl(r, t) {
          let i = !1;
          for (let s = 0, l = r.length - 1; s < r.length; l = s++) {
            const p = r[s], f = r[l];
            p.y > t.y != f.y > t.y && t.x < (f.x - p.x) * (t.y - p.y) / (f.y - p.y) + p.x && (i = !i);
          }
          return i;
        }
        function Q_(r, t, i) {
          const s = i[0], l = i[2];
          if (r.x < s.x && t.x < s.x || r.x > l.x && t.x > l.x || r.y < s.y && t.y < s.y || r.y > l.y && t.y > l.y) return !1;
          const p = ze(r, t, i[0]);
          return p !== ze(r, t, i[1]) || p !== ze(r, t, i[2]) || p !== ze(r, t, i[3]);
        }
        function Cc(r, t, i) {
          const s = t.paint.get(r).value;
          return s.kind === "constant" ? s.value : i.programConfigurations.get(t.id).getMaxValue(r);
        }
        function ih(r) {
          return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
        }
        function rh(r, t, i, s, l) {
          if (!t[0] && !t[1]) return r;
          const p = U.convert(t)._mult(l);
          i === "viewport" && p._rotate(-s);
          const f = [];
          for (let _ = 0; _ < r.length; _++) f.push(r[_].sub(p));
          return f;
        }
        let mf, gf;
        We("CircleBucket", kd, { omit: ["layers"] });
        var ey = { get paint() {
          return gf = gf || new br({ "circle-radius": new dt(fe.paint_circle["circle-radius"]), "circle-color": new dt(fe.paint_circle["circle-color"]), "circle-blur": new dt(fe.paint_circle["circle-blur"]), "circle-opacity": new dt(fe.paint_circle["circle-opacity"]), "circle-translate": new nt(fe.paint_circle["circle-translate"]), "circle-translate-anchor": new nt(fe.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new nt(fe.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new nt(fe.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new dt(fe.paint_circle["circle-stroke-width"]), "circle-stroke-color": new dt(fe.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new dt(fe.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return mf = mf || new br({ "circle-sort-key": new dt(fe.layout_circle["circle-sort-key"]) });
        } };
        class ty extends Kr {
          constructor(t) {
            super(t, ey);
          }
          createBucket(t) {
            return new kd(t);
          }
          queryRadius(t) {
            const i = t;
            return Cc("circle-radius", this, i) + Cc("circle-stroke-width", this, i) + ih(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: i, featureState: s, geometry: l, transform: p, pixelsToTileUnits: f, unwrappedTileID: _, getElevation: y }) {
            const w = rh(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -p.bearingInRadians, f), P = this.paint.get("circle-radius").evaluate(i, s) + this.paint.get("circle-stroke-width").evaluate(i, s), I = this.paint.get("circle-pitch-alignment") === "map", z = I ? w : function(F, V, $, H) {
              return F.map((he) => _f(he, V, $, H));
            }(w, p, _, y), L = I ? P * f : P;
            for (const F of l) for (const V of F) {
              const $ = I ? V : _f(V, p, _, y);
              let H = L;
              const he = p.projectTileCoordinates(V.x, V.y, _, y).signedDistanceFromCamera;
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? H *= he / p.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (H *= p.cameraToCenterDistance / he), K_(z, $, H)) return !0;
            }
            return !1;
          }
        }
        function _f(r, t, i, s) {
          const l = t.projectTileCoordinates(r.x, r.y, i, s).point;
          return new U((0.5 * l.x + 0.5) * t.width, (0.5 * -l.y + 0.5) * t.height);
        }
        class yf extends kd {
        }
        let vf;
        We("HeatmapBucket", yf, { omit: ["layers"] });
        var iy = { get paint() {
          return vf = vf || new br({ "heatmap-radius": new dt(fe.paint_heatmap["heatmap-radius"]), "heatmap-weight": new dt(fe.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new nt(fe.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Qa(fe.paint_heatmap["heatmap-color"]), "heatmap-opacity": new nt(fe.paint_heatmap["heatmap-opacity"]) });
        } };
        function Dd(r, { width: t, height: i }, s, l) {
          if (l) {
            if (l instanceof Uint8ClampedArray) l = new Uint8Array(l.buffer);
            else if (l.length !== t * i * s) throw new RangeError(`mismatched image size. expected: ${l.length} but got: ${t * i * s}`);
          } else l = new Uint8Array(t * i * s);
          return r.width = t, r.height = i, r.data = l, r;
        }
        function xf(r, { width: t, height: i }, s) {
          if (t === r.width && i === r.height) return;
          const l = Dd({}, { width: t, height: i }, s);
          Ld(r, l, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r.width, t), height: Math.min(r.height, i) }, s), r.width = t, r.height = i, r.data = l.data;
        }
        function Ld(r, t, i, s, l, p) {
          if (l.width === 0 || l.height === 0) return t;
          if (l.width > r.width || l.height > r.height || i.x > r.width - l.width || i.y > r.height - l.height) throw new RangeError("out of range source coordinates for image copy");
          if (l.width > t.width || l.height > t.height || s.x > t.width - l.width || s.y > t.height - l.height) throw new RangeError("out of range destination coordinates for image copy");
          const f = r.data, _ = t.data;
          if (f === _) throw new Error("srcData equals dstData, so image is already copied");
          for (let y = 0; y < l.height; y++) {
            const w = ((i.y + y) * r.width + i.x) * p, P = ((s.y + y) * t.width + s.x) * p;
            for (let I = 0; I < l.width * p; I++) _[P + I] = f[w + I];
          }
          return t;
        }
        class Ic {
          constructor(t, i) {
            Dd(this, t, 1, i);
          }
          resize(t) {
            xf(this, t, 1);
          }
          clone() {
            return new Ic({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, i, s, l, p) {
            Ld(t, i, s, l, p, 1);
          }
        }
        class Or {
          constructor(t, i) {
            Dd(this, t, 4, i);
          }
          resize(t) {
            xf(this, t, 4);
          }
          replace(t, i) {
            i ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
          }
          clone() {
            return new Or({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, i, s, l, p) {
            Ld(t, i, s, l, p, 4);
          }
          setPixel(t, i, s) {
            const l = 4 * (t * this.width + i);
            this.data[l + 0] = Math.round(255 * s.r / s.a), this.data[l + 1] = Math.round(255 * s.g / s.a), this.data[l + 2] = Math.round(255 * s.b / s.a), this.data[l + 3] = Math.round(255 * s.a);
          }
        }
        function bf(r) {
          const t = {}, i = r.resolution || 256, s = r.clips ? r.clips.length : 1, l = r.image || new Or({ width: i, height: s });
          if (Math.log(i) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${i}`);
          const p = (f, _, y) => {
            t[r.evaluationKey] = y;
            const w = r.expression.evaluate(t);
            l.setPixel(f / 4 / i, _ / 4, w);
          };
          if (r.clips) for (let f = 0, _ = 0; f < s; ++f, _ += 4 * i) for (let y = 0, w = 0; y < i; y++, w += 4) {
            const P = y / (i - 1), { start: I, end: z } = r.clips[f];
            p(_, w, I * (1 - P) + z * P);
          }
          else for (let f = 0, _ = 0; f < i; f++, _ += 4) p(0, _, f / (i - 1));
          return l;
        }
        We("AlphaImage", Ic), We("RGBAImage", Or);
        const Fd = "big-fb";
        class ry extends Kr {
          createBucket(t) {
            return new yf(t);
          }
          constructor(t) {
            super(t, iy), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = bf({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(Fd) && this.heatmapFbos.delete(Fd);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return !1;
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let wf;
        var ny = { get paint() {
          return wf = wf || new br({ "hillshade-illumination-direction": new nt(fe.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new nt(fe.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new nt(fe.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new nt(fe.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new nt(fe.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new nt(fe.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new nt(fe.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new nt(fe.paint_hillshade["hillshade-method"]) });
        } };
        class sy extends Kr {
          constructor(t) {
            super(t, ny), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values, i = this.paint.get("hillshade-illumination-altitude").values, s = this.paint.get("hillshade-highlight-color").values, l = this.paint.get("hillshade-shadow-color").values;
            const p = Math.max(t.length, i.length, s.length, l.length);
            t = t.concat(Array(p - t.length).fill(t.at(-1))), i = i.concat(Array(p - i.length).fill(i.at(-1))), s = s.concat(Array(p - s.length).fill(s.at(-1))), l = l.concat(Array(p - l.length).fill(l.at(-1)));
            const f = i.map(ct);
            return { directionRadians: t.map(ct), altitudeRadians: f, shadowColor: l, highlightColor: s };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let Tf;
        var oy = { get paint() {
          return Tf = Tf || new br({ "color-relief-opacity": new nt(fe["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new Qa(fe["paint_color-relief"]["color-relief-color"]) });
        } };
        class Bd {
          constructor(t, i, s, l) {
            this.context = t, this.format = s, this.texture = t.gl.createTexture(), this.update(i, l);
          }
          update(t, i, s) {
            const { width: l, height: p } = t, f = !(this.size && this.size[0] === l && this.size[1] === p || s), { context: _ } = this, { gl: y } = _;
            if (this.useMipmap = !!(i && i.useMipmap), y.bindTexture(y.TEXTURE_2D, this.texture), _.pixelStoreUnpackFlipY.set(!1), _.pixelStoreUnpack.set(1), _.pixelStoreUnpackPremultiplyAlpha.set(this.format === y.RGBA && (!i || i.premultiply !== !1)), f) this.size = [l, p], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || He(t) ? y.texImage2D(y.TEXTURE_2D, 0, this.format, this.format, y.UNSIGNED_BYTE, t) : y.texImage2D(y.TEXTURE_2D, 0, this.format, l, p, 0, this.format, y.UNSIGNED_BYTE, t.data);
            else {
              const { x: w, y: P } = s || { x: 0, y: 0 };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || He(t) ? y.texSubImage2D(y.TEXTURE_2D, 0, w, P, y.RGBA, y.UNSIGNED_BYTE, t) : y.texSubImage2D(y.TEXTURE_2D, 0, w, P, l, p, y.RGBA, y.UNSIGNED_BYTE, t.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && y.generateMipmap(y.TEXTURE_2D), _.pixelStoreUnpackFlipY.setDefault(), _.pixelStoreUnpack.setDefault(), _.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(t, i, s) {
            const { context: l } = this, { gl: p } = l;
            p.bindTexture(p.TEXTURE_2D, this.texture), s !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (s = p.LINEAR), t !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, t), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, s || t), this.filter = t), i !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, i), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, i), this.wrap = i);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t } = this.context;
            t.deleteTexture(this.texture), this.texture = null;
          }
        }
        class Sf {
          constructor(t, i, s, l = 1, p = 1, f = 1, _ = 0) {
            if (this.uid = t, i.height !== i.width) throw new RangeError("DEM tiles must be square");
            if (s && !["mapbox", "terrarium", "custom"].includes(s)) return void Se(`"${s}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = i.height;
            const y = this.dim = i.height - 2;
            switch (this.data = new Uint32Array(i.data.buffer), s) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = l, this.greenFactor = p, this.blueFactor = f, this.baseShift = _;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let w = 0; w < y; w++) this.data[this._idx(-1, w)] = this.data[this._idx(0, w)], this.data[this._idx(y, w)] = this.data[this._idx(y - 1, w)], this.data[this._idx(w, -1)] = this.data[this._idx(w, 0)], this.data[this._idx(w, y)] = this.data[this._idx(w, y - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(y, -1)] = this.data[this._idx(y - 1, 0)], this.data[this._idx(-1, y)] = this.data[this._idx(0, y - 1)], this.data[this._idx(y, y)] = this.data[this._idx(y - 1, y - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let w = 0; w < y; w++) for (let P = 0; P < y; P++) {
              const I = this.get(w, P);
              I > this.max && (this.max = I), I < this.min && (this.min = I);
            }
          }
          get(t, i) {
            const s = new Uint8Array(this.data.buffer), l = 4 * this._idx(t, i);
            return this.unpack(s[l], s[l + 1], s[l + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t, i) {
            if (t < -1 || t >= this.dim + 1 || i < -1 || i >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (i + 1) * this.stride + (t + 1);
          }
          unpack(t, i, s) {
            return t * this.redFactor + i * this.greenFactor + s * this.blueFactor - this.baseShift;
          }
          pack(t) {
            return Pf(t, this.getUnpackVector());
          }
          getPixels() {
            return new Or({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t, i, s) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let l = i * this.dim, p = i * this.dim + this.dim, f = s * this.dim, _ = s * this.dim + this.dim;
            switch (i) {
              case -1:
                l = p - 1;
                break;
              case 1:
                p = l + 1;
            }
            switch (s) {
              case -1:
                f = _ - 1;
                break;
              case 1:
                _ = f + 1;
            }
            const y = -i * this.dim, w = -s * this.dim;
            for (let P = f; P < _; P++) for (let I = l; I < p; I++) this.data[this._idx(I, P)] = t.data[this._idx(I + y, P + w)];
          }
        }
        function Pf(r, t) {
          const i = t[0], s = t[1], l = t[2], p = t[3], f = Math.min(i, s, l), _ = Math.round((r + p) / f);
          return { r: Math.floor(_ * f / i) % 256, g: Math.floor(_ * f / s) % 256, b: Math.floor(_ * f / l) % 256 };
        }
        We("DEMData", Sf);
        class ay extends Kr {
          constructor(t) {
            super(t, oy);
          }
          _createColorRamp(t) {
            const i = { elevationStops: [], colorStops: [] }, s = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (s instanceof Zo && s._styleExpression.expression instanceof nr) {
              this.colorRampExpression = s;
              const f = s._styleExpression.expression;
              i.elevationStops = f.labels, i.colorStops = [];
              for (const _ of i.elevationStops) i.colorStops.push(f.evaluate({ globals: { elevation: _ } }));
            }
            if (i.elevationStops.length < 1 && (i.elevationStops = [0], i.colorStops = [Bt.transparent]), i.elevationStops.length < 2 && (i.elevationStops.push(i.elevationStops[0] + 1), i.colorStops.push(i.colorStops[0])), i.elevationStops.length <= t) return i;
            const l = { elevationStops: [], colorStops: [] }, p = (i.elevationStops.length - 1) / (t - 1);
            for (let f = 0; f < i.elevationStops.length - 0.5; f += p) l.elevationStops.push(i.elevationStops[Math.round(f)]), l.colorStops.push(i.colorStops[Math.round(f)]);
            return Se(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), l;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(t, i, s) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const l = this._createColorRamp(i), p = new Or({ width: l.colorStops.length, height: 1 }), f = new Or({ width: l.colorStops.length, height: 1 });
            for (let _ = 0; _ < l.elevationStops.length; _++) {
              const y = Pf(l.elevationStops[_], s);
              f.setPixel(0, _, new Bt(y.r / 255, y.g / 255, y.b / 255, 1)), p.setPixel(0, _, l.colorStops[_]);
            }
            return this.colorRampTextures = { elevationTexture: new Bd(t, f, t.gl.RGBA), colorTexture: new Bd(t, p, t.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const ly = Pi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: cy } = ly;
        function Od(r, t, i) {
          const s = i.patternDependencies;
          let l = !1;
          for (const p of t) {
            const f = p.paint.get(`${r}-pattern`);
            f.isConstant() || (l = !0);
            const _ = f.constantOr(null);
            _ && (l = !0, s[_.to] = !0, s[_.from] = !0);
          }
          return l;
        }
        function jd(r, t, i, s, l) {
          const { zoom: p, globalState: f } = s, _ = l.patternDependencies;
          for (const y of t) {
            const w = y.paint.get(`${r}-pattern`).value;
            if (w.kind !== "constant") {
              let P = w.evaluate({ zoom: p - 1, globalState: f }, i, {}, l.availableImages), I = w.evaluate({ zoom: p, globalState: f }, i, {}, l.availableImages), z = w.evaluate({ zoom: p + 1, globalState: f }, i, {}, l.availableImages);
              P = P && P.name ? P.name : P, I = I && I.name ? I.name : I, z = z && z.name ? z.name : z, _[P] = !0, _[I] = !0, _[z] = !0, i.patterns[y.id] = { min: P, mid: I, max: z };
            }
          }
          return i;
        }
        function Mf(r, t, i, s, l) {
          let p;
          if (l === function(f, _, y, w) {
            let P = 0;
            for (let I = _, z = y - w; I < y; I += w) P += (f[z] - f[I]) * (f[I + 1] + f[z + 1]), z = I;
            return P;
          }(r, t, i, s) > 0) for (let f = t; f < i; f += s) p = Af(f / s | 0, r[f], r[f + 1], p);
          else for (let f = i - s; f >= t; f -= s) p = Af(f / s | 0, r[f], r[f + 1], p);
          return p && ol(p, p.next) && (zc(p), p = p.next), p;
        }
        function ta(r, t) {
          if (!r) return r;
          t || (t = r);
          let i, s = r;
          do
            if (i = !1, s.steiner || !ol(s, s.next) && Ii(s.prev, s, s.next) !== 0) s = s.next;
            else {
              if (zc(s), s = t = s.prev, s === s.next) break;
              i = !0;
            }
          while (i || s !== t);
          return t;
        }
        function Ec(r, t, i, s, l, p, f) {
          if (!r) return;
          !f && p && function(y, w, P, I) {
            let z = y;
            do
              z.z === 0 && (z.z = Vd(z.x, z.y, w, P, I)), z.prevZ = z.prev, z.nextZ = z.next, z = z.next;
            while (z !== y);
            z.prevZ.nextZ = null, z.prevZ = null, function(L) {
              let F, V = 1;
              do {
                let $, H = L;
                L = null;
                let he = null;
                for (F = 0; H; ) {
                  F++;
                  let ee = H, re = 0;
                  for (let Te = 0; Te < V && (re++, ee = ee.nextZ, ee); Te++) ;
                  let ye = V;
                  for (; re > 0 || ye > 0 && ee; ) re !== 0 && (ye === 0 || !ee || H.z <= ee.z) ? ($ = H, H = H.nextZ, re--) : ($ = ee, ee = ee.nextZ, ye--), he ? he.nextZ = $ : L = $, $.prevZ = he, he = $;
                  H = ee;
                }
                he.nextZ = null, V *= 2;
              } while (F > 1);
            }(z);
          }(r, s, l, p);
          let _ = r;
          for (; r.prev !== r.next; ) {
            const y = r.prev, w = r.next;
            if (p ? hy(r, s, l, p) : uy(r)) t.push(y.i, r.i, w.i), zc(r), r = w.next, _ = w.next;
            else if ((r = w) === _) {
              f ? f === 1 ? Ec(r = dy(ta(r), t), t, i, s, l, p, 2) : f === 2 && py(r, t, i, s, l, p) : Ec(ta(r), t, i, s, l, p, 1);
              break;
            }
          }
        }
        function uy(r) {
          const t = r.prev, i = r, s = r.next;
          if (Ii(t, i, s) >= 0) return !1;
          const l = t.x, p = i.x, f = s.x, _ = t.y, y = i.y, w = s.y, P = Math.min(l, p, f), I = Math.min(_, y, w), z = Math.max(l, p, f), L = Math.max(_, y, w);
          let F = s.next;
          for (; F !== t; ) {
            if (F.x >= P && F.x <= z && F.y >= I && F.y <= L && Ac(l, _, p, y, f, w, F.x, F.y) && Ii(F.prev, F, F.next) >= 0) return !1;
            F = F.next;
          }
          return !0;
        }
        function hy(r, t, i, s) {
          const l = r.prev, p = r, f = r.next;
          if (Ii(l, p, f) >= 0) return !1;
          const _ = l.x, y = p.x, w = f.x, P = l.y, I = p.y, z = f.y, L = Math.min(_, y, w), F = Math.min(P, I, z), V = Math.max(_, y, w), $ = Math.max(P, I, z), H = Vd(L, F, t, i, s), he = Vd(V, $, t, i, s);
          let ee = r.prevZ, re = r.nextZ;
          for (; ee && ee.z >= H && re && re.z <= he; ) {
            if (ee.x >= L && ee.x <= V && ee.y >= F && ee.y <= $ && ee !== l && ee !== f && Ac(_, P, y, I, w, z, ee.x, ee.y) && Ii(ee.prev, ee, ee.next) >= 0 || (ee = ee.prevZ, re.x >= L && re.x <= V && re.y >= F && re.y <= $ && re !== l && re !== f && Ac(_, P, y, I, w, z, re.x, re.y) && Ii(re.prev, re, re.next) >= 0)) return !1;
            re = re.nextZ;
          }
          for (; ee && ee.z >= H; ) {
            if (ee.x >= L && ee.x <= V && ee.y >= F && ee.y <= $ && ee !== l && ee !== f && Ac(_, P, y, I, w, z, ee.x, ee.y) && Ii(ee.prev, ee, ee.next) >= 0) return !1;
            ee = ee.prevZ;
          }
          for (; re && re.z <= he; ) {
            if (re.x >= L && re.x <= V && re.y >= F && re.y <= $ && re !== l && re !== f && Ac(_, P, y, I, w, z, re.x, re.y) && Ii(re.prev, re, re.next) >= 0) return !1;
            re = re.nextZ;
          }
          return !0;
        }
        function dy(r, t) {
          let i = r;
          do {
            const s = i.prev, l = i.next.next;
            !ol(s, l) && If(s, i, i.next, l) && kc(s, l) && kc(l, s) && (t.push(s.i, i.i, l.i), zc(i), zc(i.next), i = r = l), i = i.next;
          } while (i !== r);
          return ta(i);
        }
        function py(r, t, i, s, l, p) {
          let f = r;
          do {
            let _ = f.next.next;
            for (; _ !== f.prev; ) {
              if (f.i !== _.i && yy(f, _)) {
                let y = Ef(f, _);
                return f = ta(f, f.next), y = ta(y, y.next), Ec(f, t, i, s, l, p, 0), void Ec(y, t, i, s, l, p, 0);
              }
              _ = _.next;
            }
            f = f.next;
          } while (f !== r);
        }
        function fy(r, t) {
          let i = r.x - t.x;
          return i === 0 && (i = r.y - t.y, i === 0) && (i = (r.next.y - r.y) / (r.next.x - r.x) - (t.next.y - t.y) / (t.next.x - t.x)), i;
        }
        function my(r, t) {
          const i = function(l, p) {
            let f = p;
            const _ = l.x, y = l.y;
            let w, P = -1 / 0;
            if (ol(l, f)) return f;
            do {
              if (ol(l, f.next)) return f.next;
              if (y <= f.y && y >= f.next.y && f.next.y !== f.y) {
                const V = f.x + (y - f.y) * (f.next.x - f.x) / (f.next.y - f.y);
                if (V <= _ && V > P && (P = V, w = f.x < f.next.x ? f : f.next, V === _)) return w;
              }
              f = f.next;
            } while (f !== p);
            if (!w) return null;
            const I = w, z = w.x, L = w.y;
            let F = 1 / 0;
            f = w;
            do {
              if (_ >= f.x && f.x >= z && _ !== f.x && Cf(y < L ? _ : P, y, z, L, y < L ? P : _, y, f.x, f.y)) {
                const V = Math.abs(y - f.y) / (_ - f.x);
                kc(f, l) && (V < F || V === F && (f.x > w.x || f.x === w.x && gy(w, f))) && (w = f, F = V);
              }
              f = f.next;
            } while (f !== I);
            return w;
          }(r, t);
          if (!i) return t;
          const s = Ef(i, r);
          return ta(s, s.next), ta(i, i.next);
        }
        function gy(r, t) {
          return Ii(r.prev, r, t.prev) < 0 && Ii(t.next, r, r.next) < 0;
        }
        function Vd(r, t, i, s, l) {
          return (r = 1431655765 & ((r = 858993459 & ((r = 252645135 & ((r = 16711935 & ((r = (r - i) * l | 0) | r << 8)) | r << 4)) | r << 2)) | r << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - s) * l | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
        }
        function _y(r) {
          let t = r, i = r;
          do
            (t.x < i.x || t.x === i.x && t.y < i.y) && (i = t), t = t.next;
          while (t !== r);
          return i;
        }
        function Cf(r, t, i, s, l, p, f, _) {
          return (l - f) * (t - _) >= (r - f) * (p - _) && (r - f) * (s - _) >= (i - f) * (t - _) && (i - f) * (p - _) >= (l - f) * (s - _);
        }
        function Ac(r, t, i, s, l, p, f, _) {
          return !(r === f && t === _) && Cf(r, t, i, s, l, p, f, _);
        }
        function yy(r, t) {
          return r.next.i !== t.i && r.prev.i !== t.i && !function(i, s) {
            let l = i;
            do {
              if (l.i !== i.i && l.next.i !== i.i && l.i !== s.i && l.next.i !== s.i && If(l, l.next, i, s)) return !0;
              l = l.next;
            } while (l !== i);
            return !1;
          }(r, t) && (kc(r, t) && kc(t, r) && function(i, s) {
            let l = i, p = !1;
            const f = (i.x + s.x) / 2, _ = (i.y + s.y) / 2;
            do
              l.y > _ != l.next.y > _ && l.next.y !== l.y && f < (l.next.x - l.x) * (_ - l.y) / (l.next.y - l.y) + l.x && (p = !p), l = l.next;
            while (l !== i);
            return p;
          }(r, t) && (Ii(r.prev, r, t.prev) || Ii(r, t.prev, t)) || ol(r, t) && Ii(r.prev, r, r.next) > 0 && Ii(t.prev, t, t.next) > 0);
        }
        function Ii(r, t, i) {
          return (t.y - r.y) * (i.x - t.x) - (t.x - r.x) * (i.y - t.y);
        }
        function ol(r, t) {
          return r.x === t.x && r.y === t.y;
        }
        function If(r, t, i, s) {
          const l = sh(Ii(r, t, i)), p = sh(Ii(r, t, s)), f = sh(Ii(i, s, r)), _ = sh(Ii(i, s, t));
          return l !== p && f !== _ || !(l !== 0 || !nh(r, i, t)) || !(p !== 0 || !nh(r, s, t)) || !(f !== 0 || !nh(i, r, s)) || !(_ !== 0 || !nh(i, t, s));
        }
        function nh(r, t, i) {
          return t.x <= Math.max(r.x, i.x) && t.x >= Math.min(r.x, i.x) && t.y <= Math.max(r.y, i.y) && t.y >= Math.min(r.y, i.y);
        }
        function sh(r) {
          return r > 0 ? 1 : r < 0 ? -1 : 0;
        }
        function kc(r, t) {
          return Ii(r.prev, r, r.next) < 0 ? Ii(r, t, r.next) >= 0 && Ii(r, r.prev, t) >= 0 : Ii(r, t, r.prev) < 0 || Ii(r, r.next, t) < 0;
        }
        function Ef(r, t) {
          const i = Nd(r.i, r.x, r.y), s = Nd(t.i, t.x, t.y), l = r.next, p = t.prev;
          return r.next = t, t.prev = r, i.next = l, l.prev = i, s.next = i, i.prev = s, p.next = s, s.prev = p, s;
        }
        function Af(r, t, i, s) {
          const l = Nd(r, t, i);
          return s ? (l.next = s.next, l.prev = s, s.next.prev = l, s.next = l) : (l.prev = l, l.next = l), l;
        }
        function zc(r) {
          r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
        }
        function Nd(r, t, i) {
          return { i: r, x: t, y: i, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        class al {
          constructor(t, i) {
            if (i > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = i;
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1);
          }
        }
        class oh {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle;
          }
        }
        oh.noSubdivision = new oh({ fill: new al(0, 0), line: new al(0, 0), tile: new al(0, 0), stencil: new al(0, 0), circle: 1 }), We("SubdivisionGranularityExpression", al), We("SubdivisionGranularitySetting", oh);
        const ll = -32768, Rc = 32767;
        class vy {
          constructor(t, i) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = t, this._granularityCellSize = Zt / t, this._canonical = i;
          }
          _getKey(t, i) {
            return (t += 32768) << 16 | i + 32768;
          }
          _vertexToIndex(t, i) {
            if (t < -32768 || i < -32768 || t > 32767 || i > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const s = 0 | Math.round(t), l = 0 | Math.round(i), p = this._getKey(s, l);
            if (this._vertexDictionary.has(p)) return this._vertexDictionary.get(p);
            const f = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(p, f), this._vertexBuffer.push(s, l), f;
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return function(l, p) {
              const f = [];
              for (let _ = 0; _ < p.length; _ += 3) {
                const y = p[_], w = p[_ + 1], P = p[_ + 2], I = l[2 * y], z = l[2 * y + 1];
                (l[2 * w] - I) * (l[2 * P + 1] - z) - (l[2 * w + 1] - z) * (l[2 * P] - I) > 0 ? (f.push(y), f.push(P), f.push(w)) : (f.push(y), f.push(w), f.push(P));
              }
              return f;
            }(this._vertexBuffer, t);
            const i = [], s = t.length;
            for (let l = 0; l < s; l += 3) {
              const p = [t[l + 0], t[l + 1], t[l + 2]], f = [this._vertexBuffer[2 * t[l + 0] + 0], this._vertexBuffer[2 * t[l + 0] + 1], this._vertexBuffer[2 * t[l + 1] + 0], this._vertexBuffer[2 * t[l + 1] + 1], this._vertexBuffer[2 * t[l + 2] + 0], this._vertexBuffer[2 * t[l + 2] + 1]];
              let _ = 1 / 0, y = 1 / 0, w = -1 / 0, P = -1 / 0;
              for (let V = 0; V < 3; V++) {
                const $ = f[2 * V], H = f[2 * V + 1];
                _ = Math.min(_, $), w = Math.max(w, $), y = Math.min(y, H), P = Math.max(P, H);
              }
              if (_ === w || y === P) continue;
              const I = Math.floor(_ / this._granularityCellSize), z = Math.ceil(w / this._granularityCellSize), L = Math.floor(y / this._granularityCellSize), F = Math.ceil(P / this._granularityCellSize);
              if (I !== z || L !== F) for (let V = L; V < F; V++) {
                const $ = this._scanlineGenerateVertexRingForCellRow(V, f, p);
                xy(this._vertexBuffer, $, i);
              }
              else i.push(...p);
            }
            return i;
          }
          _scanlineGenerateVertexRingForCellRow(t, i, s) {
            const l = t * this._granularityCellSize, p = l + this._granularityCellSize, f = [];
            for (let _ = 0; _ < 3; _++) {
              const y = i[2 * _], w = i[2 * _ + 1], P = i[2 * (_ + 1) % 6], I = i[(2 * (_ + 1) + 1) % 6], z = i[2 * (_ + 2) % 6], L = i[(2 * (_ + 2) + 1) % 6], F = P - y, V = I - w, $ = F === 0, H = V === 0, he = (l - w) / V, ee = (p - w) / V, re = Math.min(he, ee), ye = Math.max(he, ee);
              if (!H && (re >= 1 || ye <= 0) || H && (w < l || w > p)) {
                I >= l && I <= p && f.push(s[(_ + 1) % 3]);
                continue;
              }
              !H && re > 0 && f.push(this._vertexToIndex(y + F * re, w + V * re));
              const Te = y + F * Math.max(re, 0), Ee = y + F * Math.min(ye, 1);
              $ || this._generateIntraEdgeVertices(f, y, w, P, I, Te, Ee), !H && ye < 1 && f.push(this._vertexToIndex(y + F * ye, w + V * ye)), (H || I >= l && I <= p) && f.push(s[(_ + 1) % 3]), !H && (I <= l || I >= p) && this._generateInterEdgeVertices(f, y, w, P, I, z, L, Ee, l, p);
            }
            return f;
          }
          _generateIntraEdgeVertices(t, i, s, l, p, f, _) {
            const y = l - i, w = p - s, P = w === 0, I = P ? Math.min(i, l) : Math.min(f, _), z = P ? Math.max(i, l) : Math.max(f, _), L = Math.floor(I / this._granularityCellSize) + 1, F = Math.ceil(z / this._granularityCellSize) - 1;
            if (P ? i < l : f < _) for (let V = L; V <= F; V++) {
              const $ = V * this._granularityCellSize;
              t.push(this._vertexToIndex($, s + w * ($ - i) / y));
            }
            else for (let V = F; V >= L; V--) {
              const $ = V * this._granularityCellSize;
              t.push(this._vertexToIndex($, s + w * ($ - i) / y));
            }
          }
          _generateInterEdgeVertices(t, i, s, l, p, f, _, y, w, P) {
            const I = p - s, z = f - l, L = _ - p, F = (w - p) / L, V = (P - p) / L, $ = Math.min(F, V), H = Math.max(F, V), he = l + z * $;
            let ee = Math.floor(Math.min(he, y) / this._granularityCellSize) + 1, re = Math.ceil(Math.max(he, y) / this._granularityCellSize) - 1, ye = y < he;
            const Te = L === 0;
            if (Te && (_ === w || _ === P)) return;
            if (Te || $ >= 1 || H <= 0) {
              const $e = s - _, Be = f + (i - f) * Math.min((w - _) / $e, (P - _) / $e);
              ee = Math.floor(Math.min(Be, y) / this._granularityCellSize) + 1, re = Math.ceil(Math.max(Be, y) / this._granularityCellSize) - 1, ye = y < Be;
            }
            const Ee = I > 0 ? P : w;
            if (ye) for (let $e = ee; $e <= re; $e++) t.push(this._vertexToIndex($e * this._granularityCellSize, Ee));
            else for (let $e = re; $e >= ee; $e--) t.push(this._vertexToIndex($e * this._granularityCellSize, Ee));
          }
          _generateOutline(t) {
            const i = [];
            for (const s of t) {
              const l = ia(s, this._granularity, !0), p = this._pointArrayToIndices(l), f = [];
              for (let _ = 1; _ < p.length; _++) f.push(p[_ - 1]), f.push(p[_]);
              i.push(f);
            }
            return i;
          }
          _handlePoles(t) {
            let i = !1, s = !1;
            this._canonical && (this._canonical.y === 0 && (i = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (s = !0)), (i || s) && this._fillPoles(t, i, s);
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let i = 0; i < t.length; i += 2) {
              const s = t[i + 1];
              s === ll && (t[i + 1] = -32767), s === Rc && (t[i + 1] = 32766);
            }
          }
          _generatePoleQuad(t, i, s, l, p, f) {
            l > p != (f === ll) ? (t.push(i), t.push(s), t.push(this._vertexToIndex(l, f)), t.push(s), t.push(this._vertexToIndex(p, f)), t.push(this._vertexToIndex(l, f))) : (t.push(s), t.push(i), t.push(this._vertexToIndex(l, f)), t.push(this._vertexToIndex(p, f)), t.push(s), t.push(this._vertexToIndex(l, f)));
          }
          _fillPoles(t, i, s) {
            const l = this._vertexBuffer, p = Zt, f = t.length;
            for (let _ = 2; _ < f; _ += 3) {
              const y = t[_ - 2], w = t[_ - 1], P = t[_], I = l[2 * y], z = l[2 * y + 1], L = l[2 * w], F = l[2 * w + 1], V = l[2 * P], $ = l[2 * P + 1];
              i && (z === 0 && F === 0 && this._generatePoleQuad(t, y, w, I, L, ll), F === 0 && $ === 0 && this._generatePoleQuad(t, w, P, L, V, ll), $ === 0 && z === 0 && this._generatePoleQuad(t, P, y, V, I, ll)), s && (z === p && F === p && this._generatePoleQuad(t, y, w, I, L, Rc), F === p && $ === p && this._generatePoleQuad(t, w, P, L, V, Rc), $ === p && z === p && this._generatePoleQuad(t, P, y, V, I, Rc));
            }
          }
          _initializeVertices(t) {
            for (let i = 0; i < t.length; i += 2) this._vertexToIndex(t[i], t[i + 1]);
          }
          subdividePolygonInternal(t, i) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const { flattened: s, holeIndices: l } = function(_) {
              const y = [], w = [];
              for (const P of _) if (P.length !== 0) {
                P !== _[0] && y.push(w.length / 2);
                for (let I = 0; I < P.length; I++) w.push(P[I].x), w.push(P[I].y);
              }
              return { flattened: w, holeIndices: y };
            }(t);
            let p;
            this._initializeVertices(s);
            try {
              const _ = function(w, P, I = 2) {
                const z = P && P.length, L = z ? P[0] * I : w.length;
                let F = Mf(w, 0, L, I, !0);
                const V = [];
                if (!F || F.next === F.prev) return V;
                let $, H, he;
                if (z && (F = function(ee, re, ye, Te) {
                  const Ee = [];
                  for (let $e = 0, Be = re.length; $e < Be; $e++) {
                    const Ve = Mf(ee, re[$e] * Te, $e < Be - 1 ? re[$e + 1] * Te : ee.length, Te, !1);
                    Ve === Ve.next && (Ve.steiner = !0), Ee.push(_y(Ve));
                  }
                  Ee.sort(fy);
                  for (let $e = 0; $e < Ee.length; $e++) ye = my(Ee[$e], ye);
                  return ye;
                }(w, P, F, I)), w.length > 80 * I) {
                  $ = w[0], H = w[1];
                  let ee = $, re = H;
                  for (let ye = I; ye < L; ye += I) {
                    const Te = w[ye], Ee = w[ye + 1];
                    Te < $ && ($ = Te), Ee < H && (H = Ee), Te > ee && (ee = Te), Ee > re && (re = Ee);
                  }
                  he = Math.max(ee - $, re - H), he = he !== 0 ? 32767 / he : 0;
                }
                return Ec(F, V, I, $, H, he, 0), V;
              }(s, l), y = this._convertIndices(s, _);
              p = this._subdivideTrianglesScanline(y);
            } catch (_) {
              console.error(_);
            }
            let f = [];
            return i && (f = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(p), { verticesFlattened: this._vertexBuffer, indicesTriangles: p, indicesLineList: f };
          }
          _convertIndices(t, i) {
            const s = [];
            for (let l = 0; l < i.length; l++) s.push(this._vertexToIndex(t[2 * i[l]], t[2 * i[l] + 1]));
            return s;
          }
          _pointArrayToIndices(t) {
            const i = [];
            for (let s = 0; s < t.length; s++) {
              const l = t[s];
              i.push(this._vertexToIndex(l.x, l.y));
            }
            return i;
          }
        }
        function kf(r, t, i, s = !0) {
          return new vy(i, t).subdividePolygonInternal(r, s);
        }
        function ia(r, t, i = !1) {
          if (!r || r.length < 1) return [];
          if (r.length < 2) return [];
          const s = r[0], l = r[r.length - 1], p = i && (s.x !== l.x || s.y !== l.y);
          if (t < 2) return p ? [...r, r[0]] : [...r];
          const f = Math.floor(Zt / t), _ = [];
          _.push(new U(r[0].x, r[0].y));
          const y = r.length, w = p ? y : y - 1;
          for (let P = 0; P < w; P++) {
            const I = r[P], z = P < y - 1 ? r[P + 1] : r[0], L = I.x, F = I.y, V = z.x, $ = z.y, H = L !== V, he = F !== $;
            if (!H && !he) continue;
            const ee = V - L, re = $ - F, ye = Math.abs(ee), Te = Math.abs(re);
            let Ee = L, $e = F;
            for (; ; ) {
              const Ve = ee > 0 ? (Math.floor(Ee / f) + 1) * f : (Math.ceil(Ee / f) - 1) * f, st = re > 0 ? (Math.floor($e / f) + 1) * f : (Math.ceil($e / f) - 1) * f, je = Math.abs(Ee - Ve), Ne = Math.abs($e - st), Me = Math.abs(Ee - V), mt = Math.abs($e - $), xt = H ? je / ye : Number.POSITIVE_INFINITY, lt = he ? Ne / Te : Number.POSITIVE_INFINITY;
              if ((Me <= je || !H) && (mt <= Ne || !he)) break;
              if (xt < lt && H || !he) {
                Ee = Ve, $e += re * xt;
                const tt = new U(Ee, Math.round($e));
                _[_.length - 1].x === tt.x && _[_.length - 1].y === tt.y || _.push(tt);
              } else {
                Ee += ee * lt, $e = st;
                const tt = new U(Math.round(Ee), $e);
                _[_.length - 1].x === tt.x && _[_.length - 1].y === tt.y || _.push(tt);
              }
            }
            const Be = new U(V, $);
            _[_.length - 1].x === Be.x && _[_.length - 1].y === Be.y || _.push(Be);
          }
          return _;
        }
        function xy(r, t, i) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let s = 0, l = r[2 * t[0]];
          for (let y = 1; y < t.length; y++) {
            const w = r[2 * t[y]];
            w < l && (l = w, s = y);
          }
          const p = t.length;
          let f = s, _ = (f + 1) % p;
          for (; ; ) {
            const y = f - 1 >= 0 ? f - 1 : p - 1, w = (_ + 1) % p, P = r[2 * t[y]], I = r[2 * t[w]], z = r[2 * t[f]], L = r[2 * t[f] + 1], F = r[2 * t[_] + 1];
            let V = !1;
            if (P < I) V = !0;
            else if (P > I) V = !1;
            else {
              const $ = F - L, H = -(r[2 * t[_]] - z), he = L < F ? 1 : -1;
              ((P - z) * $ + (r[2 * t[y] + 1] - L) * H) * he > ((I - z) * $ + (r[2 * t[w] + 1] - L) * H) * he && (V = !0);
            }
            if (V) {
              const $ = t[y], H = t[f], he = t[_];
              $ !== H && $ !== he && H !== he && i.push(he, H, $), f--, f < 0 && (f = p - 1);
            } else {
              const $ = t[w], H = t[f], he = t[_];
              $ !== H && $ !== he && H !== he && i.push(he, H, $), _++, _ >= p && (_ = 0);
            }
            if (y === w) break;
          }
        }
        function zf(r, t, i, s, l, p, f, _, y) {
          const w = l.length / 2, P = f && _ && y;
          if (w < Pt.MAX_VERTEX_ARRAY_LENGTH) {
            const I = t.prepareSegment(w, i, s), z = I.vertexLength;
            for (let V = 0; V < p.length; V += 3) s.emplaceBack(z + p[V], z + p[V + 1], z + p[V + 2]);
            let L, F;
            I.vertexLength += w, I.primitiveLength += p.length / 3, P && (F = f.prepareSegment(w, i, _), L = F.vertexLength, F.vertexLength += w);
            for (let V = 0; V < l.length; V += 2) r(l[V], l[V + 1]);
            if (P) for (let V = 0; V < y.length; V++) {
              const $ = y[V];
              for (let H = 1; H < $.length; H += 2) _.emplaceBack(L + $[H - 1], L + $[H]);
              F.primitiveLength += $.length / 2;
            }
          } else (function(I, z, L, F, V, $) {
            const H = [];
            for (let Te = 0; Te < F.length / 2; Te++) H.push(-1);
            const he = { count: 0 };
            let ee = 0, re = I.getOrCreateLatestSegment(z, L), ye = re.vertexLength;
            for (let Te = 2; Te < V.length; Te += 3) {
              const Ee = V[Te - 2], $e = V[Te - 1], Be = V[Te];
              let Ve = H[Ee] < ee, st = H[$e] < ee, je = H[Be] < ee;
              re.vertexLength + ((Ve ? 1 : 0) + (st ? 1 : 0) + (je ? 1 : 0)) > Pt.MAX_VERTEX_ARRAY_LENGTH && (re = I.createNewSegment(z, L), ee = he.count, Ve = !0, st = !0, je = !0, ye = 0);
              const Ne = Dc(H, F, $, he, Ee, Ve, re), Me = Dc(H, F, $, he, $e, st, re), mt = Dc(H, F, $, he, Be, je, re);
              L.emplaceBack(ye + Ne - ee, ye + Me - ee, ye + mt - ee), re.primitiveLength++;
            }
          })(t, i, s, l, p, r), P && function(I, z, L, F, V, $) {
            const H = [];
            for (let Te = 0; Te < F.length / 2; Te++) H.push(-1);
            const he = { count: 0 };
            let ee = 0, re = I.getOrCreateLatestSegment(z, L), ye = re.vertexLength;
            for (let Te = 0; Te < V.length; Te++) {
              const Ee = V[Te];
              for (let $e = 1; $e < V[Te].length; $e += 2) {
                const Be = Ee[$e - 1], Ve = Ee[$e];
                let st = H[Be] < ee, je = H[Ve] < ee;
                re.vertexLength + ((st ? 1 : 0) + (je ? 1 : 0)) > Pt.MAX_VERTEX_ARRAY_LENGTH && (re = I.createNewSegment(z, L), ee = he.count, st = !0, je = !0, ye = 0);
                const Ne = Dc(H, F, $, he, Be, st, re), Me = Dc(H, F, $, he, Ve, je, re);
                L.emplaceBack(ye + Ne - ee, ye + Me - ee), re.primitiveLength++;
              }
            }
          }(f, i, _, l, y, r), t.forceNewSegmentOnNextPrepare(), f == null || f.forceNewSegmentOnNextPrepare();
        }
        function Dc(r, t, i, s, l, p, f) {
          if (p) {
            const _ = s.count;
            return i(t[2 * l], t[2 * l + 1]), r[l] = s.count, s.count++, f.vertexLength++, _;
          }
          return r[l];
        }
        class $d {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((i) => i.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new be(), this.indexArray = new ri(), this.indexArray2 = new ei(), this.programConfigurations = new Br(t.layers, t.zoom), this.segments = new Pt(), this.segments2 = new Pt(), this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id);
          }
          populate(t, i, s) {
            this.hasPattern = Od("fill", this.layers, i);
            const l = this.layers[0].layout.get("fill-sort-key"), p = !l.isConstant(), f = [];
            for (const { feature: _, id: y, index: w, sourceLayerIndex: P } of t) {
              const I = this.layers[0]._featureFilter.needGeometry, z = Rn(_, I);
              if (!this.layers[0]._featureFilter.filter(new ai(this.zoom, { globalState: this.globalState }), z, s)) continue;
              const L = p ? l.evaluate(z, {}, s, i.availableImages) : void 0, F = { id: y, properties: _.properties, type: _.type, sourceLayerIndex: P, index: w, geometry: I ? z.geometry : ts(_), patterns: {}, sortKey: L };
              f.push(F);
            }
            p && f.sort((_, y) => _.sortKey - y.sortKey);
            for (const _ of f) {
              const { geometry: y, index: w, sourceLayerIndex: P } = _;
              if (this.hasPattern) {
                const I = jd("fill", this.layers, _, { zoom: this.zoom, globalState: this.globalState }, i);
                this.patternFeatures.push(I);
              } else this.addFeature(_, y, w, s, {}, i.subdivisionGranularity);
              i.featureIndex.insert(t[w].feature, y, w, P, this.index);
            }
          }
          update(t, i, s) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, { imagePositions: s, globalState: this.globalState });
          }
          addFeatures(t, i, s) {
            for (const l of this.patternFeatures) this.addFeature(l, l.geometry, l.index, i, s, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, cy), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t, i, s, l, p, f) {
            for (const _ of jo(i, 500)) {
              const y = kf(_, l, f.fill.getGranularityForZoomLevel(l.z)), w = this.layoutVertexArray;
              zf((P, I) => {
                w.emplaceBack(P, I);
              }, this.segments, this.layoutVertexArray, this.indexArray, y.verticesFlattened, y.indicesTriangles, this.segments2, this.indexArray2, y.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, { imagePositions: p, canonical: l, globalState: this.globalState });
          }
        }
        let Rf, Df;
        We("FillBucket", $d, { omit: ["layers", "patternFeatures"] });
        var by = { get paint() {
          return Df = Df || new br({ "fill-antialias": new nt(fe.paint_fill["fill-antialias"]), "fill-opacity": new dt(fe.paint_fill["fill-opacity"]), "fill-color": new dt(fe.paint_fill["fill-color"]), "fill-outline-color": new dt(fe.paint_fill["fill-outline-color"]), "fill-translate": new nt(fe.paint_fill["fill-translate"]), "fill-translate-anchor": new nt(fe.paint_fill["fill-translate-anchor"]), "fill-pattern": new Ja(fe.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Rf = Rf || new br({ "fill-sort-key": new dt(fe.layout_fill["fill-sort-key"]) });
        } };
        class wy extends Kr {
          constructor(t) {
            super(t, by);
          }
          recalculate(t, i) {
            super.recalculate(t, i);
            const s = this.paint._values["fill-outline-color"];
            s.value.kind === "constant" && s.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t) {
            return new $d(t);
          }
          queryRadius() {
            return ih(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, geometry: i, transform: s, pixelsToTileUnits: l }) {
            return df(rh(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -s.bearingInRadians, l), i);
          }
          isTileClipped() {
            return !0;
          }
        }
        const Ty = Pi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Sy = Pi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Py } = Ty;
        class cl {
          constructor(t, i, s, l, p) {
            this.properties = {}, this.extent = s, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = l, this._values = p, t.readFields(My, this, i);
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const i = t.readVarint() + t.pos, s = [];
            let l, p = 1, f = 0, _ = 0, y = 0;
            for (; t.pos < i; ) {
              if (f <= 0) {
                const w = t.readVarint();
                p = 7 & w, f = w >> 3;
              }
              if (f--, p === 1 || p === 2) _ += t.readSVarint(), y += t.readSVarint(), p === 1 && (l && s.push(l), l = []), l && l.push(new U(_, y));
              else {
                if (p !== 7) throw new Error(`unknown command ${p}`);
                l && l.push(l[0].clone());
              }
            }
            return l && s.push(l), s;
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const i = t.readVarint() + t.pos;
            let s = 1, l = 0, p = 0, f = 0, _ = 1 / 0, y = -1 / 0, w = 1 / 0, P = -1 / 0;
            for (; t.pos < i; ) {
              if (l <= 0) {
                const I = t.readVarint();
                s = 7 & I, l = I >> 3;
              }
              if (l--, s === 1 || s === 2) p += t.readSVarint(), f += t.readSVarint(), p < _ && (_ = p), p > y && (y = p), f < w && (w = f), f > P && (P = f);
              else if (s !== 7) throw new Error(`unknown command ${s}`);
            }
            return [_, w, y, P];
          }
          toGeoJSON(t, i, s) {
            const l = this.extent * Math.pow(2, s), p = this.extent * t, f = this.extent * i, _ = this.loadGeometry();
            function y(z) {
              return [360 * (z.x + p) / l - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (z.y + f) / l) * Math.PI)) - 90];
            }
            function w(z) {
              return z.map(y);
            }
            let P;
            if (this.type === 1) {
              const z = [];
              for (const F of _) z.push(F[0]);
              const L = w(z);
              P = z.length === 1 ? { type: "Point", coordinates: L[0] } : { type: "MultiPoint", coordinates: L };
            } else if (this.type === 2) {
              const z = _.map(w);
              P = z.length === 1 ? { type: "LineString", coordinates: z[0] } : { type: "MultiLineString", coordinates: z };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const z = function(F) {
                  const V = F.length;
                  if (V <= 1) return [F];
                  const $ = [];
                  let H, he;
                  for (let ee = 0; ee < V; ee++) {
                    const re = Cy(F[ee]);
                    re !== 0 && (he === void 0 && (he = re < 0), he === re < 0 ? (H && $.push(H), H = [F[ee]]) : H && H.push(F[ee]));
                  }
                  return H && $.push(H), $;
                }(_), L = [];
                for (const F of z) L.push(F.map(w));
                P = L.length === 1 ? { type: "Polygon", coordinates: L[0] } : { type: "MultiPolygon", coordinates: L };
              }
            }
            const I = { type: "Feature", geometry: P, properties: this.properties };
            return this.id != null && (I.id = this.id), I;
          }
        }
        function My(r, t, i) {
          r === 1 ? t.id = i.readVarint() : r === 2 ? function(s, l) {
            const p = s.readVarint() + s.pos;
            for (; s.pos < p; ) {
              const f = l._keys[s.readVarint()], _ = l._values[s.readVarint()];
              l.properties[f] = _;
            }
          }(i, t) : r === 3 ? t.type = i.readVarint() : r === 4 && (t._geometry = i.pos);
        }
        function Cy(r) {
          let t = 0;
          for (let i, s, l = 0, p = r.length, f = p - 1; l < p; f = l++) i = r[l], s = r[f], t += (s.x - i.x) * (i.y + s.y);
          return t;
        }
        cl.types = ["Unknown", "Point", "LineString", "Polygon"];
        class Lf {
          constructor(t, i) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(Iy, this, i), this.length = this._features.length;
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const i = this._pbf.readVarint() + this._pbf.pos;
            return new cl(this._pbf, i, this.extent, this._keys, this._values);
          }
        }
        function Iy(r, t, i) {
          r === 15 ? t.version = i.readVarint() : r === 1 ? t.name = i.readString() : r === 5 ? t.extent = i.readVarint() : r === 2 ? t._features.push(i.pos) : r === 3 ? t._keys.push(i.readString()) : r === 4 && t._values.push(function(s) {
            let l = null;
            const p = s.readVarint() + s.pos;
            for (; s.pos < p; ) {
              const f = s.readVarint() >> 3;
              l = f === 1 ? s.readString() : f === 2 ? s.readFloat() : f === 3 ? s.readDouble() : f === 4 ? s.readVarint64() : f === 5 ? s.readVarint() : f === 6 ? s.readSVarint() : f === 7 ? s.readBoolean() : null;
            }
            if (l == null) throw new Error("unknown feature value");
            return l;
          }(i));
        }
        class Ff {
          constructor(t, i) {
            this.layers = t.readFields(Ey, {}, i);
          }
        }
        function Ey(r, t, i) {
          if (r === 3) {
            const s = new Lf(i, i.readVarint() + i.pos);
            s.length && (t[s.name] = s);
          }
        }
        const Ud = Math.pow(2, 13);
        function Lc(r, t, i, s, l, p, f, _) {
          r.emplaceBack(t, i, 2 * Math.floor(s * Ud) + f, l * Ud * 2, p * Ud * 2, Math.round(_));
        }
        class Zd {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((i) => i.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new ge(), this.centroidVertexArray = new Y(), this.indexArray = new ri(), this.programConfigurations = new Br(t.layers, t.zoom), this.segments = new Pt(), this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id);
          }
          populate(t, i, s) {
            this.features = [], this.hasPattern = Od("fill-extrusion", this.layers, i);
            for (const { feature: l, id: p, index: f, sourceLayerIndex: _ } of t) {
              const y = this.layers[0]._featureFilter.needGeometry, w = Rn(l, y);
              if (!this.layers[0]._featureFilter.filter(new ai(this.zoom, { globalState: this.globalState }), w, s)) continue;
              const P = { id: p, sourceLayerIndex: _, index: f, geometry: y ? w.geometry : ts(l), properties: l.properties, type: l.type, patterns: {} };
              this.hasPattern ? this.features.push(jd("fill-extrusion", this.layers, P, { zoom: this.zoom, globalState: this.globalState }, i)) : this.addFeature(P, P.geometry, f, s, {}, i.subdivisionGranularity), i.featureIndex.insert(l, P.geometry, f, _, this.index, !0);
            }
          }
          addFeatures(t, i, s) {
            for (const l of this.features) {
              const { geometry: p } = l;
              this.addFeature(l, p, l.index, i, s, t.subdivisionGranularity);
            }
          }
          update(t, i, s) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, { imagePositions: s, globalState: this.globalState });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Py), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Sy.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t, i, s, l, p, f) {
            for (const _ of jo(i, 500)) {
              const y = { x: 0, y: 0, sampleCount: 0 }, w = this.layoutVertexArray.length;
              this.processPolygon(y, l, t, _, f);
              const P = this.layoutVertexArray.length - w, I = Math.floor(y.x / y.sampleCount), z = Math.floor(y.y / y.sampleCount);
              for (let L = 0; L < P; L++) this.centroidVertexArray.emplaceBack(I, z);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, { imagePositions: p, canonical: l, globalState: this.globalState });
          }
          processPolygon(t, i, s, l, p) {
            if (l.length < 1 || Bf(l[0])) return;
            for (const I of l) I.length !== 0 && Ay(t, I);
            const f = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, _ = p.fill.getGranularityForZoomLevel(i.z), y = cl.types[s.type] === "Polygon";
            for (const I of l) {
              if (I.length === 0 || Bf(I)) continue;
              const z = ia(I, _, y);
              this._generateSideFaces(z, f);
            }
            if (!y) return;
            const w = kf(l, i, _, !1), P = this.layoutVertexArray;
            zf((I, z) => {
              Lc(P, I, z, 0, 0, 1, 1, 0);
            }, this.segments, this.layoutVertexArray, this.indexArray, w.verticesFlattened, w.indicesTriangles);
          }
          _generateSideFaces(t, i) {
            let s = 0;
            for (let l = 1; l < t.length; l++) {
              const p = t[l], f = t[l - 1];
              if (ky(p, f)) continue;
              i.segment.vertexLength + 4 > Pt.MAX_VERTEX_ARRAY_LENGTH && (i.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const _ = p.sub(f)._perp()._unit(), y = f.dist(p);
              s + y > 32768 && (s = 0), Lc(this.layoutVertexArray, p.x, p.y, _.x, _.y, 0, 0, s), Lc(this.layoutVertexArray, p.x, p.y, _.x, _.y, 0, 1, s), s += y, Lc(this.layoutVertexArray, f.x, f.y, _.x, _.y, 0, 0, s), Lc(this.layoutVertexArray, f.x, f.y, _.x, _.y, 0, 1, s);
              const w = i.segment.vertexLength;
              this.indexArray.emplaceBack(w, w + 2, w + 1), this.indexArray.emplaceBack(w + 1, w + 2, w + 3), i.segment.vertexLength += 4, i.segment.primitiveLength += 2;
            }
          }
        }
        function Ay(r, t) {
          for (let i = 0; i < t.length; i++) {
            const s = t[i];
            i === t.length - 1 && t[0].x === s.x && t[0].y === s.y || (r.x += s.x, r.y += s.y, r.sampleCount++);
          }
        }
        function ky(r, t) {
          return r.x === t.x && (r.x < 0 || r.x > Zt) || r.y === t.y && (r.y < 0 || r.y > Zt);
        }
        function Bf(r) {
          return r.every((t) => t.x < 0) || r.every((t) => t.x > Zt) || r.every((t) => t.y < 0) || r.every((t) => t.y > Zt);
        }
        let Of;
        We("FillExtrusionBucket", Zd, { omit: ["layers", "features"] });
        var zy = { get paint() {
          return Of = Of || new br({ "fill-extrusion-opacity": new nt(fe["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new dt(fe["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new nt(fe["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new nt(fe["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Ja(fe["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new dt(fe["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new dt(fe["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new nt(fe["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class Ry extends Kr {
          constructor(t) {
            super(t, zy);
          }
          createBucket(t) {
            return new Zd(t);
          }
          queryRadius() {
            return ih(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature({ queryGeometry: t, feature: i, featureState: s, geometry: l, transform: p, pixelsToTileUnits: f, pixelPosMatrix: _ }) {
            const y = rh(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -p.bearingInRadians, f), w = this.paint.get("fill-extrusion-height").evaluate(i, s), P = this.paint.get("fill-extrusion-base").evaluate(i, s), I = function(L, F) {
              const V = [];
              for (const $ of L) {
                const H = [$.x, $.y, 0, 1];
                Jr(H, H, F), V.push(new U(H[0] / H[3], H[1] / H[3]));
              }
              return V;
            }(y, _), z = function(L, F, V, $) {
              const H = [], he = [], ee = $[8] * F, re = $[9] * F, ye = $[10] * F, Te = $[11] * F, Ee = $[8] * V, $e = $[9] * V, Be = $[10] * V, Ve = $[11] * V;
              for (const st of L) {
                const je = [], Ne = [];
                for (const Me of st) {
                  const mt = Me.x, xt = Me.y, lt = $[0] * mt + $[4] * xt + $[12], tt = $[1] * mt + $[5] * xt + $[13], $t = $[2] * mt + $[6] * xt + $[14], wi = $[3] * mt + $[7] * xt + $[15], Ui = $t + ye, mr = wi + Te, pn = lt + Ee, jr = tt + $e, sr = $t + Be, _i = wi + Ve, Ki = new U((lt + ee) / mr, (tt + re) / mr);
                  Ki.z = Ui / mr, je.push(Ki);
                  const or = new U(pn / _i, jr / _i);
                  or.z = sr / _i, Ne.push(or);
                }
                H.push(je), he.push(Ne);
              }
              return [H, he];
            }(l, P, w, _);
            return function(L, F, V) {
              let $ = 1 / 0;
              df(V, F) && ($ = jf(V, F[0]));
              for (let H = 0; H < F.length; H++) {
                const he = F[H], ee = L[H];
                for (let re = 0; re < he.length - 1; re++) {
                  const ye = he[re], Te = [ye, he[re + 1], ee[re + 1], ee[re], ye];
                  hf(V, Te) && ($ = Math.min($, jf(V, Te)));
                }
              }
              return $ !== 1 / 0 && $;
            }(z[0], z[1], I);
          }
        }
        function Fc(r, t) {
          return r.x * t.x + r.y * t.y;
        }
        function jf(r, t) {
          if (r.length === 1) {
            let i = 0;
            const s = t[i++];
            let l;
            for (; !l || s.equals(l); ) if (l = t[i++], !l) return 1 / 0;
            for (; i < t.length; i++) {
              const p = t[i], f = r[0], _ = l.sub(s), y = p.sub(s), w = f.sub(s), P = Fc(_, _), I = Fc(_, y), z = Fc(y, y), L = Fc(w, _), F = Fc(w, y), V = P * z - I * I, $ = (z * L - I * F) / V, H = (P * F - I * L) / V, he = s.z * (1 - $ - H) + l.z * $ + p.z * H;
              if (isFinite(he)) return he;
            }
            return 1 / 0;
          }
          {
            let i = 1 / 0;
            for (const s of t) i = Math.min(i, s.z);
            return i;
          }
        }
        const Dy = Pi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Ly } = Dy, Fy = Pi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: By } = Fy, Oy = Math.cos(Math.PI / 180 * 37.5), Vf = Math.pow(2, 14) / 0.5;
        class Gd {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((i) => i.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((i) => {
              this.gradients[i.id] = {};
            }), this.layoutVertexArray = new _e(), this.layoutVertexArray2 = new xe(), this.indexArray = new ri(), this.programConfigurations = new Br(t.layers, t.zoom), this.segments = new Pt(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id);
          }
          populate(t, i, s) {
            this.hasPattern = Od("line", this.layers, i);
            const l = this.layers[0].layout.get("line-sort-key"), p = !l.isConstant(), f = [];
            for (const { feature: _, id: y, index: w, sourceLayerIndex: P } of t) {
              const I = this.layers[0]._featureFilter.needGeometry, z = Rn(_, I);
              if (!this.layers[0]._featureFilter.filter(new ai(this.zoom, { globalState: this.globalState }), z, s)) continue;
              const L = p ? l.evaluate(z, {}, s) : void 0, F = { id: y, properties: _.properties, type: _.type, sourceLayerIndex: P, index: w, geometry: I ? z.geometry : ts(_), patterns: {}, sortKey: L };
              f.push(F);
            }
            p && f.sort((_, y) => _.sortKey - y.sortKey);
            for (const _ of f) {
              const { geometry: y, index: w, sourceLayerIndex: P } = _;
              if (this.hasPattern) {
                const I = jd("line", this.layers, _, { zoom: this.zoom, globalState: this.globalState }, i);
                this.patternFeatures.push(I);
              } else this.addFeature(_, y, w, s, {}, i.subdivisionGranularity);
              i.featureIndex.insert(t[w].feature, y, w, P, this.index);
            }
          }
          update(t, i, s) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, { imagePositions: s, globalState: this.globalState });
          }
          addFeatures(t, i, s) {
            for (const l of this.patternFeatures) this.addFeature(l, l.geometry, l.index, i, s, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, By)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ly), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
          }
          addFeature(t, i, s, l, p, f) {
            const _ = this.layers[0].layout, y = _.get("line-join").evaluate(t, {}), w = _.get("line-cap"), P = _.get("line-miter-limit"), I = _.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const z of i) this.addLine(z, t, y, w, P, I, l, f);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, { imagePositions: p, canonical: l, globalState: this.globalState });
          }
          addLine(t, i, s, l, p, f, _, y) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = ia(t, _ ? y.line.getGranularityForZoomLevel(_.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ee = 0; ee < t.length - 1; ee++) this.totalDistance += t[ee].dist(t[ee + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const w = cl.types[i.type] === "Polygon";
            let P = t.length;
            for (; P >= 2 && t[P - 1].equals(t[P - 2]); ) P--;
            let I = 0;
            for (; I < P - 1 && t[I].equals(t[I + 1]); ) I++;
            if (P < (w ? 3 : 2)) return;
            s === "bevel" && (p = 1.05);
            const z = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, L = this.segments.prepareSegment(10 * P, this.layoutVertexArray, this.indexArray);
            let F, V, $, H, he;
            this.e1 = this.e2 = -1, w && (F = t[P - 2], he = t[I].sub(F)._unit()._perp());
            for (let ee = I; ee < P; ee++) {
              if ($ = ee === P - 1 ? w ? t[I + 1] : void 0 : t[ee + 1], $ && t[ee].equals($)) continue;
              he && (H = he), F && (V = F), F = t[ee], he = $ ? $.sub(F)._unit()._perp() : H, H = H || he;
              let re = H.add(he);
              re.x === 0 && re.y === 0 || re._unit();
              const ye = H.x * he.x + H.y * he.y, Te = re.x * he.x + re.y * he.y, Ee = Te !== 0 ? 1 / Te : 1 / 0, $e = 2 * Math.sqrt(2 - 2 * Te), Be = Te < Oy && V && $, Ve = H.x * he.y - H.y * he.x > 0;
              if (Be && ee > I) {
                const Ne = F.dist(V);
                if (Ne > 2 * z) {
                  const Me = F.sub(F.sub(V)._mult(z / Ne)._round());
                  this.updateDistance(V, Me), this.addCurrentVertex(Me, H, 0, 0, L), V = Me;
                }
              }
              const st = V && $;
              let je = st ? s : w ? "butt" : l;
              if (st && je === "round" && (Ee < f ? je = "miter" : Ee <= 2 && (je = "fakeround")), je === "miter" && Ee > p && (je = "bevel"), je === "bevel" && (Ee > 2 && (je = "flipbevel"), Ee < p && (je = "miter")), V && this.updateDistance(V, F), je === "miter") re._mult(Ee), this.addCurrentVertex(F, re, 0, 0, L);
              else if (je === "flipbevel") {
                if (Ee > 100) re = he.mult(-1);
                else {
                  const Ne = Ee * H.add(he).mag() / H.sub(he).mag();
                  re._perp()._mult(Ne * (Ve ? -1 : 1));
                }
                this.addCurrentVertex(F, re, 0, 0, L), this.addCurrentVertex(F, re.mult(-1), 0, 0, L);
              } else if (je === "bevel" || je === "fakeround") {
                const Ne = -Math.sqrt(Ee * Ee - 1), Me = Ve ? Ne : 0, mt = Ve ? 0 : Ne;
                if (V && this.addCurrentVertex(F, H, Me, mt, L), je === "fakeround") {
                  const xt = Math.round(180 * $e / Math.PI / 20);
                  for (let lt = 1; lt < xt; lt++) {
                    let tt = lt / xt;
                    if (tt !== 0.5) {
                      const wi = tt - 0.5;
                      tt += tt * wi * (tt - 1) * ((1.0904 + ye * (ye * (3.55645 - 1.43519 * ye) - 3.2452)) * wi * wi + (0.848013 + ye * (0.215638 * ye - 1.06021)));
                    }
                    const $t = he.sub(H)._mult(tt)._add(H)._unit()._mult(Ve ? -1 : 1);
                    this.addHalfVertex(F, $t.x, $t.y, !1, Ve, 0, L);
                  }
                }
                $ && this.addCurrentVertex(F, he, -Me, -mt, L);
              } else if (je === "butt") this.addCurrentVertex(F, re, 0, 0, L);
              else if (je === "square") {
                const Ne = V ? 1 : -1;
                this.addCurrentVertex(F, re, Ne, Ne, L);
              } else je === "round" && (V && (this.addCurrentVertex(F, H, 0, 0, L), this.addCurrentVertex(F, H, 1, 1, L, !0)), $ && (this.addCurrentVertex(F, he, -1, -1, L, !0), this.addCurrentVertex(F, he, 0, 0, L)));
              if (Be && ee < P - 1) {
                const Ne = F.dist($);
                if (Ne > 2 * z) {
                  const Me = F.add($.sub(F)._mult(z / Ne)._round());
                  this.updateDistance(F, Me), this.addCurrentVertex(Me, he, 0, 0, L), F = Me;
                }
              }
            }
          }
          addCurrentVertex(t, i, s, l, p, f = !1) {
            const _ = i.y * l - i.x, y = -i.y - i.x * l;
            this.addHalfVertex(t, i.x + i.y * s, i.y - i.x * s, f, !1, s, p), this.addHalfVertex(t, _, y, f, !0, -l, p), this.distance > Vf / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, i, s, l, p, f));
          }
          addHalfVertex({ x: t, y: i }, s, l, p, f, _, y) {
            const w = 0.5 * (this.lineClips ? this.scaledDistance * (Vf - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (p ? 1 : 0), (i << 1) + (f ? 1 : 0), Math.round(63 * s) + 128, Math.round(63 * l) + 128, 1 + (_ === 0 ? 0 : _ < 0 ? -1 : 1) | (63 & w) << 2, w >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const P = y.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, P, this.e2), y.primitiveLength++), f ? this.e2 = P : this.e1 = P;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t, i) {
            this.distance += t.dist(i), this.updateScaledDistance();
          }
        }
        let Nf, $f;
        We("LineBucket", Gd, { omit: ["layers", "patternFeatures"] });
        var Uf = { get paint() {
          return $f = $f || new br({ "line-opacity": new dt(fe.paint_line["line-opacity"]), "line-color": new dt(fe.paint_line["line-color"]), "line-translate": new nt(fe.paint_line["line-translate"]), "line-translate-anchor": new nt(fe.paint_line["line-translate-anchor"]), "line-width": new dt(fe.paint_line["line-width"]), "line-gap-width": new dt(fe.paint_line["line-gap-width"]), "line-offset": new dt(fe.paint_line["line-offset"]), "line-blur": new dt(fe.paint_line["line-blur"]), "line-dasharray": new Kn(fe.paint_line["line-dasharray"]), "line-pattern": new Ja(fe.paint_line["line-pattern"]), "line-gradient": new Qa(fe.paint_line["line-gradient"]) });
        }, get layout() {
          return Nf = Nf || new br({ "line-cap": new nt(fe.layout_line["line-cap"]), "line-join": new dt(fe.layout_line["line-join"]), "line-miter-limit": new nt(fe.layout_line["line-miter-limit"]), "line-round-limit": new nt(fe.layout_line["line-round-limit"]), "line-sort-key": new dt(fe.layout_line["line-sort-key"]) });
        } };
        class jy extends dt {
          possiblyEvaluate(t, i) {
            return i = new ai(Math.floor(i.zoom), { now: i.now, fadeDuration: i.fadeDuration, zoomHistory: i.zoomHistory, transition: i.transition }), super.possiblyEvaluate(t, i);
          }
          evaluate(t, i, s, l) {
            return i = ur({}, i, { zoom: Math.floor(i.zoom) }), super.evaluate(t, i, s, l);
          }
        }
        let ah;
        class Vy extends Kr {
          constructor(t) {
            super(t, Uf), this.gradientVersion = 0, ah || (ah = new jy(Uf.paint.properties["line-width"].specification), ah.useIntegerZoom = !0);
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const i = this.gradientExpression();
              this.stepInterpolant = !!function(s) {
                return s._styleExpression !== void 0;
              }(i) && i._styleExpression.expression instanceof Si, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t, i) {
            super.recalculate(t, i), this.paint._values["line-floorwidth"] = ah.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
          }
          createBucket(t) {
            return new Gd(t);
          }
          queryRadius(t) {
            const i = t, s = Zf(Cc("line-width", this, i), Cc("line-gap-width", this, i)), l = Cc("line-offset", this, i);
            return s / 2 + Math.abs(l) + ih(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: i, featureState: s, geometry: l, transform: p, pixelsToTileUnits: f }) {
            const _ = rh(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -p.bearingInRadians, f), y = f / 2 * Zf(this.paint.get("line-width").evaluate(i, s), this.paint.get("line-gap-width").evaluate(i, s)), w = this.paint.get("line-offset").evaluate(i, s);
            return w && (l = function(P, I) {
              const z = [];
              for (let L = 0; L < P.length; L++) {
                const F = P[L], V = [];
                for (let $ = 0; $ < F.length; $++) {
                  const H = F[$ - 1], he = F[$], ee = F[$ + 1], re = $ === 0 ? new U(0, 0) : he.sub(H)._unit()._perp(), ye = $ === F.length - 1 ? new U(0, 0) : ee.sub(he)._unit()._perp(), Te = re._add(ye)._unit(), Ee = Te.x * ye.x + Te.y * ye.y;
                  Ee !== 0 && Te._mult(1 / Ee), V.push(Te._mult(I)._add(he));
                }
                z.push(V);
              }
              return z;
            }(l, w * f)), function(P, I, z) {
              for (let L = 0; L < I.length; L++) {
                const F = I[L];
                if (P.length >= 3) {
                  for (let V = 0; V < F.length; V++) if (sl(P, F[V])) return !0;
                }
                if (Y_(P, F, z)) return !0;
              }
              return !1;
            }(_, l, y);
          }
          isTileClipped() {
            return !0;
          }
        }
        function Zf(r, t) {
          return t > 0 ? t + 2 * r : r;
        }
        const Ny = Pi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), $y = Pi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Pi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Uy = Pi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        Pi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Gf = Pi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Zy = Pi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function Gy(r, t, i) {
          return r.sections.forEach((s) => {
            s.text = function(l, p, f) {
              const _ = p.layout.get("text-transform").evaluate(f, {});
              return _ === "uppercase" ? l = l.toLocaleUpperCase() : _ === "lowercase" && (l = l.toLocaleLowerCase()), ln.applyArabicShaping && (l = ln.applyArabicShaping(l)), l;
            }(s.text, t, i);
          }), r;
        }
        Pi([{ name: "triangle", components: 3, type: "Uint16" }]), Pi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Pi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Pi([{ type: "Float32", name: "offsetX" }]), Pi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Pi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const Bc = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
        var Xi = 24;
        const qd = 4294967296, qf = 1 / qd, Hf = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class Hd {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(t, i, s = this.length) {
            for (; this.pos < s; ) {
              const l = this.readVarint(), p = l >> 3, f = this.pos;
              this.type = 7 & l, t(p, i, this), this.pos === f && this.skip(l);
            }
            return i;
          }
          readMessage(t, i) {
            return this.readFields(t, i, this.readVarint() + this.pos);
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t;
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t;
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * qd;
            return this.pos += 8, t;
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * qd;
            return this.pos += 8, t;
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t;
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t;
          }
          readVarint(t) {
            const i = this.buf;
            let s, l;
            return l = i[this.pos++], s = 127 & l, l < 128 ? s : (l = i[this.pos++], s |= (127 & l) << 7, l < 128 ? s : (l = i[this.pos++], s |= (127 & l) << 14, l < 128 ? s : (l = i[this.pos++], s |= (127 & l) << 21, l < 128 ? s : (l = i[this.pos], s |= (15 & l) << 28, function(p, f, _) {
              const y = _.buf;
              let w, P;
              if (P = y[_.pos++], w = (112 & P) >> 4, P < 128 || (P = y[_.pos++], w |= (127 & P) << 3, P < 128) || (P = y[_.pos++], w |= (127 & P) << 10, P < 128) || (P = y[_.pos++], w |= (127 & P) << 17, P < 128) || (P = y[_.pos++], w |= (127 & P) << 24, P < 128) || (P = y[_.pos++], w |= (1 & P) << 31, P < 128)) return ul(p, w, f);
              throw new Error("Expected varint not more than 10 bytes");
            }(s, t, this)))));
          }
          readVarint64() {
            return this.readVarint(!0);
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const t = this.readVarint() + this.pos, i = this.pos;
            return this.pos = t, t - i >= 12 && Hf ? Hf.decode(this.buf.subarray(i, t)) : function(s, l, p) {
              let f = "", _ = l;
              for (; _ < p; ) {
                const y = s[_];
                let w, P, I, z = null, L = y > 239 ? 4 : y > 223 ? 3 : y > 191 ? 2 : 1;
                if (_ + L > p) break;
                L === 1 ? y < 128 && (z = y) : L === 2 ? (w = s[_ + 1], (192 & w) == 128 && (z = (31 & y) << 6 | 63 & w, z <= 127 && (z = null))) : L === 3 ? (w = s[_ + 1], P = s[_ + 2], (192 & w) == 128 && (192 & P) == 128 && (z = (15 & y) << 12 | (63 & w) << 6 | 63 & P, (z <= 2047 || z >= 55296 && z <= 57343) && (z = null))) : L === 4 && (w = s[_ + 1], P = s[_ + 2], I = s[_ + 3], (192 & w) == 128 && (192 & P) == 128 && (192 & I) == 128 && (z = (15 & y) << 18 | (63 & w) << 12 | (63 & P) << 6 | 63 & I, (z <= 65535 || z >= 1114112) && (z = null))), z === null ? (z = 65533, L = 1) : z > 65535 && (z -= 65536, f += String.fromCharCode(z >>> 10 & 1023 | 55296), z = 56320 | 1023 & z), f += String.fromCharCode(z), _ += L;
              }
              return f;
            }(this.buf, i, t);
          }
          readBytes() {
            const t = this.readVarint() + this.pos, i = this.buf.subarray(this.pos, t);
            return this.pos = t, i;
          }
          readPackedVarint(t = [], i) {
            const s = this.readPackedEnd();
            for (; this.pos < s; ) t.push(this.readVarint(i));
            return t;
          }
          readPackedSVarint(t = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) t.push(this.readSVarint());
            return t;
          }
          readPackedBoolean(t = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) t.push(this.readBoolean());
            return t;
          }
          readPackedFloat(t = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) t.push(this.readFloat());
            return t;
          }
          readPackedDouble(t = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) t.push(this.readDouble());
            return t;
          }
          readPackedFixed32(t = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) t.push(this.readFixed32());
            return t;
          }
          readPackedSFixed32(t = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) t.push(this.readSFixed32());
            return t;
          }
          readPackedFixed64(t = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) t.push(this.readFixed64());
            return t;
          }
          readPackedSFixed64(t = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) t.push(this.readSFixed64());
            return t;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(t) {
            const i = 7 & t;
            if (i === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (i === 2) this.pos = this.readVarint() + this.pos;
            else if (i === 5) this.pos += 4;
            else {
              if (i !== 1) throw new Error(`Unimplemented type: ${i}`);
              this.pos += 8;
            }
          }
          writeTag(t, i) {
            this.writeVarint(t << 3 | i);
          }
          realloc(t) {
            let i = this.length || 16;
            for (; i < this.pos + t; ) i *= 2;
            if (i !== this.length) {
              const s = new Uint8Array(i);
              s.set(this.buf), this.buf = s, this.dataView = new DataView(s.buffer), this.length = i;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4;
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4;
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * qf), !0), this.pos += 8;
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * qf), !0), this.pos += 8;
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? function(i, s) {
              let l, p;
              if (i >= 0 ? (l = i % 4294967296 | 0, p = i / 4294967296 | 0) : (l = ~(-i % 4294967296), p = ~(-i / 4294967296), 4294967295 ^ l ? l = l + 1 | 0 : (l = 0, p = p + 1 | 0)), i >= 18446744073709552e3 || i < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              s.realloc(10), function(f, _, y) {
                y.buf[y.pos++] = 127 & f | 128, f >>>= 7, y.buf[y.pos++] = 127 & f | 128, f >>>= 7, y.buf[y.pos++] = 127 & f | 128, f >>>= 7, y.buf[y.pos++] = 127 & f | 128, y.buf[y.pos] = 127 & (f >>>= 7);
              }(l, 0, s), function(f, _) {
                const y = (7 & f) << 4;
                _.buf[_.pos++] |= y | ((f >>>= 3) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f)))));
              }(p, s);
            }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
          }
          writeBoolean(t) {
            this.writeVarint(+t);
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const i = this.pos;
            this.pos = function(l, p, f) {
              for (let _, y, w = 0; w < p.length; w++) {
                if (_ = p.charCodeAt(w), _ > 55295 && _ < 57344) {
                  if (!y) {
                    _ > 56319 || w + 1 === p.length ? (l[f++] = 239, l[f++] = 191, l[f++] = 189) : y = _;
                    continue;
                  }
                  if (_ < 56320) {
                    l[f++] = 239, l[f++] = 191, l[f++] = 189, y = _;
                    continue;
                  }
                  _ = y - 55296 << 10 | _ - 56320 | 65536, y = null;
                } else y && (l[f++] = 239, l[f++] = 191, l[f++] = 189, y = null);
                _ < 128 ? l[f++] = _ : (_ < 2048 ? l[f++] = _ >> 6 | 192 : (_ < 65536 ? l[f++] = _ >> 12 | 224 : (l[f++] = _ >> 18 | 240, l[f++] = _ >> 12 & 63 | 128), l[f++] = _ >> 6 & 63 | 128), l[f++] = 63 & _ | 128);
              }
              return f;
            }(this.buf, t, this.pos);
            const s = this.pos - i;
            s >= 128 && Wf(i, s, this), this.pos = i - 1, this.writeVarint(s), this.pos += s;
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4;
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8;
          }
          writeBytes(t) {
            const i = t.length;
            this.writeVarint(i), this.realloc(i);
            for (let s = 0; s < i; s++) this.buf[this.pos++] = t[s];
          }
          writeRawMessage(t, i) {
            this.pos++;
            const s = this.pos;
            t(i, this);
            const l = this.pos - s;
            l >= 128 && Wf(s, l, this), this.pos = s - 1, this.writeVarint(l), this.pos += l;
          }
          writeMessage(t, i, s) {
            this.writeTag(t, 2), this.writeRawMessage(i, s);
          }
          writePackedVarint(t, i) {
            i.length && this.writeMessage(t, qy, i);
          }
          writePackedSVarint(t, i) {
            i.length && this.writeMessage(t, Hy, i);
          }
          writePackedBoolean(t, i) {
            i.length && this.writeMessage(t, Ky, i);
          }
          writePackedFloat(t, i) {
            i.length && this.writeMessage(t, Wy, i);
          }
          writePackedDouble(t, i) {
            i.length && this.writeMessage(t, Xy, i);
          }
          writePackedFixed32(t, i) {
            i.length && this.writeMessage(t, Yy, i);
          }
          writePackedSFixed32(t, i) {
            i.length && this.writeMessage(t, Jy, i);
          }
          writePackedFixed64(t, i) {
            i.length && this.writeMessage(t, Qy, i);
          }
          writePackedSFixed64(t, i) {
            i.length && this.writeMessage(t, ev, i);
          }
          writeBytesField(t, i) {
            this.writeTag(t, 2), this.writeBytes(i);
          }
          writeFixed32Field(t, i) {
            this.writeTag(t, 5), this.writeFixed32(i);
          }
          writeSFixed32Field(t, i) {
            this.writeTag(t, 5), this.writeSFixed32(i);
          }
          writeFixed64Field(t, i) {
            this.writeTag(t, 1), this.writeFixed64(i);
          }
          writeSFixed64Field(t, i) {
            this.writeTag(t, 1), this.writeSFixed64(i);
          }
          writeVarintField(t, i) {
            this.writeTag(t, 0), this.writeVarint(i);
          }
          writeSVarintField(t, i) {
            this.writeTag(t, 0), this.writeSVarint(i);
          }
          writeStringField(t, i) {
            this.writeTag(t, 2), this.writeString(i);
          }
          writeFloatField(t, i) {
            this.writeTag(t, 5), this.writeFloat(i);
          }
          writeDoubleField(t, i) {
            this.writeTag(t, 1), this.writeDouble(i);
          }
          writeBooleanField(t, i) {
            this.writeVarintField(t, +i);
          }
        }
        function ul(r, t, i) {
          return i ? 4294967296 * t + (r >>> 0) : 4294967296 * (t >>> 0) + (r >>> 0);
        }
        function Wf(r, t, i) {
          const s = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          i.realloc(s);
          for (let l = i.pos - 1; l >= r; l--) i.buf[l + s] = i.buf[l];
        }
        function qy(r, t) {
          for (let i = 0; i < r.length; i++) t.writeVarint(r[i]);
        }
        function Hy(r, t) {
          for (let i = 0; i < r.length; i++) t.writeSVarint(r[i]);
        }
        function Wy(r, t) {
          for (let i = 0; i < r.length; i++) t.writeFloat(r[i]);
        }
        function Xy(r, t) {
          for (let i = 0; i < r.length; i++) t.writeDouble(r[i]);
        }
        function Ky(r, t) {
          for (let i = 0; i < r.length; i++) t.writeBoolean(r[i]);
        }
        function Yy(r, t) {
          for (let i = 0; i < r.length; i++) t.writeFixed32(r[i]);
        }
        function Jy(r, t) {
          for (let i = 0; i < r.length; i++) t.writeSFixed32(r[i]);
        }
        function Qy(r, t) {
          for (let i = 0; i < r.length; i++) t.writeFixed64(r[i]);
        }
        function ev(r, t) {
          for (let i = 0; i < r.length; i++) t.writeSFixed64(r[i]);
        }
        function tv(r, t, i) {
          r === 1 && i.readMessage(iv, t);
        }
        function iv(r, t, i) {
          if (r === 3) {
            const { id: s, bitmap: l, width: p, height: f, left: _, top: y, advance: w } = i.readMessage(rv, {});
            t.push({ id: s, bitmap: new Ic({ width: p + 6, height: f + 6 }, l), metrics: { width: p, height: f, left: _, top: y, advance: w } });
          }
        }
        function rv(r, t, i) {
          r === 1 ? t.id = i.readVarint() : r === 2 ? t.bitmap = i.readBytes() : r === 3 ? t.width = i.readVarint() : r === 4 ? t.height = i.readVarint() : r === 5 ? t.left = i.readSVarint() : r === 6 ? t.top = i.readSVarint() : r === 7 && (t.advance = i.readVarint());
        }
        function Xf(r) {
          let t = 0, i = 0;
          for (const f of r) t += f.w * f.h, i = Math.max(i, f.w);
          r.sort((f, _) => _.h - f.h);
          const s = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), i), h: 1 / 0 }];
          let l = 0, p = 0;
          for (const f of r) for (let _ = s.length - 1; _ >= 0; _--) {
            const y = s[_];
            if (!(f.w > y.w || f.h > y.h)) {
              if (f.x = y.x, f.y = y.y, p = Math.max(p, f.y + f.h), l = Math.max(l, f.x + f.w), f.w === y.w && f.h === y.h) {
                const w = s.pop();
                w && _ < s.length && (s[_] = w);
              } else f.h === y.h ? (y.x += f.w, y.w -= f.w) : f.w === y.w ? (y.y += f.h, y.h -= f.h) : (s.push({ x: y.x + f.w, y: y.y, w: y.w - f.w, h: f.h }), y.y += f.h, y.h -= f.h);
              break;
            }
          }
          return { w: l, h: p, fill: t / (l * p) || 0 };
        }
        class Wd {
          constructor(t, { pixelRatio: i, version: s, stretchX: l, stretchY: p, content: f, textFitWidth: _, textFitHeight: y }) {
            this.paddedRect = t, this.pixelRatio = i, this.stretchX = l, this.stretchY = p, this.content = f, this.version = s, this.textFitWidth = _, this.textFitHeight = y;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class Kf {
          constructor(t, i) {
            const s = {}, l = {};
            this.haveRenderCallbacks = [];
            const p = [];
            this.addImages(t, s, p), this.addImages(i, l, p);
            const { w: f, h: _ } = Xf(p), y = new Or({ width: f || 1, height: _ || 1 });
            for (const w in t) {
              const P = t[w], I = s[w].paddedRect;
              Or.copy(P.data, y, { x: 0, y: 0 }, { x: I.x + 1, y: I.y + 1 }, P.data);
            }
            for (const w in i) {
              const P = i[w], I = l[w].paddedRect, z = I.x + 1, L = I.y + 1, F = P.data.width, V = P.data.height;
              Or.copy(P.data, y, { x: 0, y: 0 }, { x: z, y: L }, P.data), Or.copy(P.data, y, { x: 0, y: V - 1 }, { x: z, y: L - 1 }, { width: F, height: 1 }), Or.copy(P.data, y, { x: 0, y: 0 }, { x: z, y: L + V }, { width: F, height: 1 }), Or.copy(P.data, y, { x: F - 1, y: 0 }, { x: z - 1, y: L }, { width: 1, height: V }), Or.copy(P.data, y, { x: 0, y: 0 }, { x: z + F, y: L }, { width: 1, height: V });
            }
            this.image = y, this.iconPositions = s, this.patternPositions = l;
          }
          addImages(t, i, s) {
            for (const l in t) {
              const p = t[l], f = { x: 0, y: 0, w: p.data.width + 2, h: p.data.height + 2 };
              s.push(f), i[l] = new Wd(f, p), p.hasRenderCallback && this.haveRenderCallbacks.push(l);
            }
          }
          patchUpdatedImages(t, i) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const s in t.updatedImages) this.patchUpdatedImage(this.iconPositions[s], t.getImage(s), i), this.patchUpdatedImage(this.patternPositions[s], t.getImage(s), i);
          }
          patchUpdatedImage(t, i, s) {
            if (!t || !i || t.version === i.version) return;
            t.version = i.version;
            const [l, p] = t.tl;
            s.update(i.data, void 0, { x: l, y: p });
          }
        }
        var fo;
        We("ImagePosition", Wd), We("ImageAtlas", Kf), T.ao = void 0, (fo = T.ao || (T.ao = {}))[fo.none = 0] = "none", fo[fo.horizontal = 1] = "horizontal", fo[fo.vertical = 2] = "vertical", fo[fo.horizontalOnly = 3] = "horizontalOnly";
        class Oc {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(t, i, s) {
            const l = new Oc();
            return l.scale = t || 1, l.fontStack = i, l.verticalAlign = s || "bottom", l;
          }
          static forImage(t, i) {
            const s = new Oc();
            return s.imageName = t, s.verticalAlign = i || "bottom", s;
          }
        }
        class hl {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t, i) {
            const s = new hl();
            for (let l = 0; l < t.sections.length; l++) {
              const p = t.sections[l];
              p.image ? s.addImageSection(p) : s.addTextSection(p, i);
            }
            return s;
          }
          length() {
            return this.text.length;
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]];
          }
          getSectionIndex(t) {
            return this.sectionIndex[t];
          }
          getCharCode(t) {
            return this.text.charCodeAt(t);
          }
          verticalizePunctuation() {
            this.text = function(t) {
              let i = "";
              for (let s = 0; s < t.length; s++) {
                const l = t.charCodeAt(s + 1) || null, p = t.charCodeAt(s - 1) || null;
                i += l && Hu(l) && !Bc[t[s + 1]] || p && Hu(p) && !Bc[t[s - 1]] || !Bc[t[s]] ? t[s] : Bc[t[s]];
              }
              return i;
            }(this.text);
          }
          trim() {
            let t = 0;
            for (let s = 0; s < this.text.length && ch[this.text.charCodeAt(s)]; s++) t++;
            let i = this.text.length;
            for (let s = this.text.length - 1; s >= 0 && s >= t && ch[this.text.charCodeAt(s)]; s--) i--;
            this.text = this.text.substring(t, i), this.sectionIndex = this.sectionIndex.slice(t, i);
          }
          substring(t, i) {
            const s = new hl();
            return s.text = this.text.substring(t, i), s.sectionIndex = this.sectionIndex.slice(t, i), s.sections = this.sections, s;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t, i) => Math.max(t, this.sections[i].scale), 0);
          }
          getMaxImageSize(t) {
            let i = 0, s = 0;
            for (let l = 0; l < this.length(); l++) {
              const p = this.getSection(l);
              if (p.imageName) {
                const f = t[p.imageName];
                if (!f) continue;
                const _ = f.displaySize;
                i = Math.max(i, _[0]), s = Math.max(s, _[1]);
              }
            }
            return { maxImageWidth: i, maxImageHeight: s };
          }
          addTextSection(t, i) {
            this.text += t.text, this.sections.push(Oc.forText(t.scale, t.fontStack || i, t.verticalAlign));
            const s = this.sections.length - 1;
            for (let l = 0; l < t.text.length; ++l) this.sectionIndex.push(s);
          }
          addImageSection(t) {
            const i = t.image ? t.image.name : "";
            if (i.length === 0) return void Se("Can't add FormattedSection with an empty image.");
            const s = this.getNextImageSectionCharCode();
            s ? (this.text += String.fromCharCode(s), this.sections.push(Oc.forImage(i, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Se("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function lh(r, t, i, s, l, p, f, _, y, w, P, I, z, L, F) {
          const V = hl.fromFeature(r, l);
          let $;
          I === T.ao.vertical && V.verticalizePunctuation();
          const { processBidirectionalText: H, processStyledBidirectionalText: he } = ln;
          if (H && V.sections.length === 1) {
            $ = [];
            const ye = H(V.toString(), Xd(V, w, p, t, s, L));
            for (const Te of ye) {
              const Ee = new hl();
              Ee.text = Te, Ee.sections = V.sections;
              for (let $e = 0; $e < Te.length; $e++) Ee.sectionIndex.push(0);
              $.push(Ee);
            }
          } else if (he) {
            $ = [];
            const ye = he(V.text, V.sectionIndex, Xd(V, w, p, t, s, L));
            for (const Te of ye) {
              const Ee = new hl();
              Ee.text = Te[0], Ee.sectionIndex = Te[1], Ee.sections = V.sections, $.push(Ee);
            }
          } else $ = function(ye, Te) {
            const Ee = [], $e = ye.text;
            let Be = 0;
            for (const Ve of Te) Ee.push(ye.substring(Be, Ve)), Be = Ve;
            return Be < $e.length && Ee.push(ye.substring(Be, $e.length)), Ee;
          }(V, Xd(V, w, p, t, s, L));
          const ee = [], re = { positionedLines: ee, text: V.toString(), top: P[1], bottom: P[1], left: P[0], right: P[0], writingMode: I, iconsInText: !1, verticalizable: !1 };
          return function(ye, Te, Ee, $e, Be, Ve, st, je, Ne, Me, mt, xt) {
            let lt = 0, tt = 0, $t = 0, wi = 0;
            const Ui = je === "right" ? 1 : je === "left" ? 0 : 0.5, mr = Xi / xt;
            let pn = 0;
            for (const _i of Be) {
              _i.trim();
              const Ki = _i.getMaxScale(), or = { positionedGlyphs: [], lineOffset: 0 };
              ye.positionedLines[pn] = or;
              const ar = or.positionedGlyphs;
              let kr = 0;
              if (!_i.length()) {
                tt += Ve, ++pn;
                continue;
              }
              const fn = av($e, _i, mr);
              for (let Vr = 0; Vr < _i.length(); Vr++) {
                const Zi = _i.getSection(Vr), Ji = _i.getSectionIndex(Vr), Qi = _i.getCharCode(Vr), Oi = lv(Ne, mt, Qi);
                let di;
                if (Zi.imageName) {
                  if (ye.iconsInText = !0, Zi.scale = Zi.scale * mr, di = uv(Zi, Oi, Ki, fn, $e), !di) continue;
                  kr = Math.max(kr, di.imageOffset);
                } else if (di = cv(Zi, Qi, Oi, fn, Te, Ee), !di) continue;
                const { rect: Dn, metrics: ml, baselineOffset: Ln } = di;
                ar.push({ glyph: Qi, imageName: Zi.imageName, x: lt, y: tt + Ln + -17, vertical: Oi, scale: Zi.scale, fontStack: Zi.fontStack, sectionIndex: Ji, metrics: ml, rect: Dn }), Oi ? (ye.verticalizable = !0, lt += (Zi.imageName ? ml.advance : Xi) * Zi.scale + Me) : lt += ml.advance * Zi.scale + Me;
              }
              ar.length !== 0 && ($t = Math.max(lt - Me, $t), hv(ar, 0, ar.length - 1, Ui)), lt = 0, or.lineOffset = Math.max(kr, (Ki - 1) * Xi);
              const Yi = Ve * Ki + kr;
              tt += Yi, wi = Math.max(Yi, wi), ++pn;
            }
            const { horizontalAlign: jr, verticalAlign: sr } = Kd(st);
            (function(_i, Ki, or, ar, kr, fn, Yi, Vr, Zi) {
              const Ji = (Ki - or) * kr;
              let Qi = 0;
              Qi = fn !== Yi ? -Vr * ar - -17 : -ar * Zi * Yi + 0.5 * Yi;
              for (const Oi of _i) for (const di of Oi.positionedGlyphs) di.x += Ji, di.y += Qi;
            })(ye.positionedLines, Ui, jr, sr, $t, wi, Ve, tt, Be.length), ye.top += -sr * tt, ye.bottom = ye.top + tt, ye.left += -jr * $t, ye.right = ye.left + $t;
          }(re, t, i, s, $, f, _, y, I, w, z, F), !function(ye) {
            for (const Te of ye) if (Te.positionedGlyphs.length !== 0) return !1;
            return !0;
          }(ee) && re;
        }
        const ch = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, nv = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, sv = { 40: !0 };
        function Yf(r, t, i, s, l, p) {
          if (t.imageName) {
            const f = s[t.imageName];
            return f ? f.displaySize[0] * t.scale * Xi / p + l : 0;
          }
          {
            const f = i[t.fontStack], _ = f && f[r];
            return _ ? _.metrics.advance * t.scale + l : 0;
          }
        }
        function Jf(r, t, i, s) {
          const l = Math.pow(r - t, 2);
          return s ? r < t ? l / 2 : 2 * l : l + Math.abs(i) * i;
        }
        function ov(r, t, i) {
          let s = 0;
          return r === 10 && (s -= 1e4), i && (s += 150), r !== 40 && r !== 65288 || (s += 50), t !== 41 && t !== 65289 || (s += 50), s;
        }
        function Qf(r, t, i, s, l, p) {
          let f = null, _ = Jf(t, i, l, p);
          for (const y of s) {
            const w = Jf(t - y.x, i, l, p) + y.badness;
            w <= _ && (f = y, _ = w);
          }
          return { index: r, x: t, priorBreak: f, badness: _ };
        }
        function em(r) {
          return r ? em(r.priorBreak).concat(r.index) : [];
        }
        function Xd(r, t, i, s, l, p) {
          if (!r) return [];
          const f = [], _ = function(I, z, L, F, V, $) {
            let H = 0;
            for (let he = 0; he < I.length(); he++) {
              const ee = I.getSection(he);
              H += Yf(I.getCharCode(he), ee, F, V, z, $);
            }
            return H / Math.max(1, Math.ceil(H / L));
          }(r, t, i, s, l, p), y = r.text.indexOf("") >= 0;
          let w = 0;
          for (let I = 0; I < r.length(); I++) {
            const z = r.getSection(I), L = r.getCharCode(I);
            if (ch[L] || (w += Yf(L, z, s, l, t, p)), I < r.length() - 1) {
              const F = !((P = L) < 11904) && (!!Nt["CJK Compatibility Forms"](P) || !!Nt["CJK Compatibility"](P) || !!Nt["CJK Strokes"](P) || !!Nt["CJK Symbols and Punctuation"](P) || !!Nt["Enclosed CJK Letters and Months"](P) || !!Nt["Halfwidth and Fullwidth Forms"](P) || !!Nt["Ideographic Description Characters"](P) || !!Nt["Vertical Forms"](P) || gc.test(String.fromCodePoint(P)));
              (nv[L] || F || z.imageName || I !== r.length() - 2 && sv[r.getCharCode(I + 1)]) && f.push(Qf(I + 1, w, _, f, ov(L, r.getCharCode(I + 1), F && y), !1));
            }
          }
          var P;
          return em(Qf(r.length(), w, _, f, 0, !0));
        }
        function Kd(r) {
          let t = 0.5, i = 0.5;
          switch (r) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0;
          }
          switch (r) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              i = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              i = 0;
          }
          return { horizontalAlign: t, verticalAlign: i };
        }
        function av(r, t, i) {
          const s = t.getMaxScale() * Xi, { maxImageWidth: l, maxImageHeight: p } = t.getMaxImageSize(r), f = Math.max(s, p * i);
          return { verticalLineContentWidth: Math.max(s, l * i), horizontalLineContentHeight: f };
        }
        function tm(r) {
          switch (r) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function lv(r, t, i) {
          return !(r === T.ao.horizontal || !t && !_c(i) || t && (ch[i] || (s = i, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(s)))));
          var s;
        }
        function cv(r, t, i, s, l, p) {
          const f = p[r.fontStack], _ = function(w, P, I, z) {
            if (w && w.rect) return w;
            const L = P[I.fontStack], F = L && L[z];
            return F ? { rect: null, metrics: F.metrics } : null;
          }(f && f[t], l, r, t);
          if (_ === null) return null;
          let y;
          if (i) y = s.verticalLineContentWidth - r.scale * Xi;
          else {
            const w = tm(r.verticalAlign);
            y = (s.horizontalLineContentHeight - r.scale * Xi) * w;
          }
          return { rect: _.rect, metrics: _.metrics, baselineOffset: y };
        }
        function uv(r, t, i, s, l) {
          const p = l[r.imageName];
          if (!p) return null;
          const f = p.paddedRect, _ = p.displaySize, y = { width: _[0], height: _[1], left: 1, top: -3, advance: t ? _[1] : _[0] };
          let w;
          if (t) w = s.verticalLineContentWidth - _[1] * r.scale;
          else {
            const P = tm(r.verticalAlign);
            w = (s.horizontalLineContentHeight - _[1] * r.scale) * P;
          }
          return { rect: f, metrics: y, baselineOffset: w, imageOffset: (t ? _[0] : _[1]) * r.scale - Xi * i };
        }
        function hv(r, t, i, s) {
          if (s === 0) return;
          const l = r[i], p = (r[i].x + l.metrics.advance * l.scale) * s;
          for (let f = t; f <= i; f++) r[f].x -= p;
        }
        function dv(r, t, i) {
          const { horizontalAlign: s, verticalAlign: l } = Kd(i), p = t[0] - r.displaySize[0] * s, f = t[1] - r.displaySize[1] * l;
          return { image: r, top: f, bottom: f + r.displaySize[1], left: p, right: p + r.displaySize[0] };
        }
        function im(r) {
          var t, i;
          let s = r.left, l = r.top, p = r.right - s, f = r.bottom - l;
          const _ = (t = r.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", y = (i = r.image.textFitHeight) !== null && i !== void 0 ? i : "stretchOrShrink", w = (r.image.content[2] - r.image.content[0]) / (r.image.content[3] - r.image.content[1]);
          if (y === "proportional") {
            if (_ === "stretchOnly" && p / f < w || _ === "proportional") {
              const P = Math.ceil(f * w);
              s *= P / p, p = P;
            }
          } else if (_ === "proportional" && y === "stretchOnly" && w !== 0 && p / f > w) {
            const P = Math.ceil(p / w);
            l *= P / f, f = P;
          }
          return { x1: s, y1: l, x2: s + p, y2: l + f };
        }
        function rm(r, t, i, s, l, p) {
          const f = r.image;
          let _;
          if (f.content) {
            const $ = f.content, H = f.pixelRatio || 1;
            _ = [$[0] / H, $[1] / H, f.displaySize[0] - $[2] / H, f.displaySize[1] - $[3] / H];
          }
          const y = t.left * p, w = t.right * p;
          let P, I, z, L;
          i === "width" || i === "both" ? (L = l[0] + y - s[3], I = l[0] + w + s[1]) : (L = l[0] + (y + w - f.displaySize[0]) / 2, I = L + f.displaySize[0]);
          const F = t.top * p, V = t.bottom * p;
          return i === "height" || i === "both" ? (P = l[1] + F - s[0], z = l[1] + V + s[2]) : (P = l[1] + (F + V - f.displaySize[1]) / 2, z = P + f.displaySize[1]), { image: f, top: P, right: I, bottom: z, left: L, collisionPadding: _ };
        }
        const zs = 128, mo = 32640;
        function nm(r, t) {
          const { expression: i } = t;
          if (i.kind === "constant") return { kind: "constant", layoutSize: i.evaluate(new ai(r + 1)) };
          if (i.kind === "source") return { kind: "source" };
          {
            const { zoomStops: s, interpolationType: l } = i;
            let p = 0;
            for (; p < s.length && s[p] <= r; ) p++;
            p = Math.max(0, p - 1);
            let f = p;
            for (; f < s.length && s[f] < r + 1; ) f++;
            f = Math.min(s.length - 1, f);
            const _ = s[p], y = s[f];
            return i.kind === "composite" ? { kind: "composite", minZoom: _, maxZoom: y, interpolationType: l } : { kind: "camera", minZoom: _, maxZoom: y, minSize: i.evaluate(new ai(_)), maxSize: i.evaluate(new ai(y)), interpolationType: l };
          }
        }
        function Yd(r, t, i) {
          let s = "never";
          const l = r.get(t);
          return l ? s = l : r.get(i) && (s = "always"), s;
        }
        const pv = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function uh(r, t, i, s, l, p, f, _, y, w, P, I, z) {
          const L = _ ? Math.min(mo, Math.round(_[0])) : 0, F = _ ? Math.min(mo, Math.round(_[1])) : 0;
          r.emplaceBack(t, i, Math.round(32 * s), Math.round(32 * l), p, f, (L << 1) + (y ? 1 : 0), F, 16 * w, 16 * P, 256 * I, 256 * z);
        }
        function Jd(r, t, i) {
          r.emplaceBack(t.x, t.y, i), r.emplaceBack(t.x, t.y, i), r.emplaceBack(t.x, t.y, i), r.emplaceBack(t.x, t.y, i);
        }
        function fv(r) {
          for (const t of r.sections) if (Ku(t.text)) return !0;
          return !1;
        }
        class Qd {
          constructor(t) {
            this.layoutVertexArray = new Oe(), this.indexArray = new ri(), this.programConfigurations = t, this.segments = new Pt(), this.dynamicLayoutVertexArray = new Ie(), this.opacityVertexArray = new et(), this.hasVisibleVertices = !1, this.placedSymbolArray = new O();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(t, i, s, l) {
            this.isEmpty() || (s && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ny.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, i), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, $y.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, pv, !0), this.opacityVertexBuffer.itemSize = 1), (s || l) && this.programConfigurations.upload(t));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        We("SymbolBuffers", Qd);
        class ep {
          constructor(t, i, s) {
            this.layoutVertexArray = new t(), this.layoutAttributes = i, this.indexArray = new s(), this.segments = new Pt(), this.collisionVertexArray = new Kt();
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Uy.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        We("CollisionBuffers", ep);
        class dl {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((f) => f.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const i = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = nm(this.zoom, i["text-size"]), this.iconSizeData = nm(this.zoom, i["icon-size"]);
            const s = this.layers[0].layout, l = s.get("symbol-sort-key"), p = s.get("symbol-z-order");
            this.canOverlap = Yd(s, "text-overlap", "text-allow-overlap") !== "never" || Yd(s, "icon-overlap", "icon-allow-overlap") !== "never" || s.get("text-ignore-placement") || s.get("icon-ignore-placement"), this.sortFeaturesByKey = p !== "viewport-y" && !l.isConstant(), this.sortFeaturesByY = (p === "viewport-y" || p === "auto" && !this.sortFeaturesByKey) && this.canOverlap, s.get("symbol-placement") === "point" && (this.writingModes = s.get("text-writing-mode").map((f) => T.ao[f])), this.stateDependentLayerIds = this.layers.filter((f) => f.isStateDependent()).map((f) => f.id), this.sourceID = t.sourceID;
          }
          createArrays() {
            this.text = new Qd(new Br(this.layers, this.zoom, (t) => /^text/.test(t))), this.icon = new Qd(new Br(this.layers, this.zoom, (t) => /^icon/.test(t))), this.glyphOffsetArray = new q(), this.lineVertexArray = new W(), this.symbolInstances = new Z(), this.textAnchorOffsets = new K();
          }
          calculateGlyphDependencies(t, i, s, l, p) {
            for (let f = 0; f < t.length; f++) if (i[t.charCodeAt(f)] = !0, (s || l) && p) {
              const _ = Bc[t.charAt(f)];
              _ && (i[_.charCodeAt(0)] = !0);
            }
          }
          populate(t, i, s) {
            const l = this.layers[0], p = l.layout, f = p.get("text-font"), _ = p.get("text-field"), y = p.get("icon-image"), w = (_.value.kind !== "constant" || _.value.value instanceof yr && !_.value.value.isEmpty() || _.value.value.toString().length > 0) && (f.value.kind !== "constant" || f.value.value.length > 0), P = y.value.kind !== "constant" || !!y.value.value || Object.keys(y.parameters).length > 0, I = p.get("symbol-sort-key");
            if (this.features = [], !w && !P) return;
            const z = i.iconDependencies, L = i.glyphDependencies, F = i.availableImages, V = new ai(this.zoom, { globalState: this.globalState });
            for (const { feature: $, id: H, index: he, sourceLayerIndex: ee } of t) {
              const re = l._featureFilter.needGeometry, ye = Rn($, re);
              if (!l._featureFilter.filter(V, ye, s)) continue;
              let Te, Ee;
              if (re || (ye.geometry = ts($)), w) {
                const Be = l.getValueAndResolveTokens("text-field", ye, s, F), Ve = yr.factory(Be), st = this.hasRTLText = this.hasRTLText || fv(Ve);
                (!st || ln.getRTLTextPluginStatus() === "unavailable" || st && ln.isParsed()) && (Te = Gy(Ve, l, ye));
              }
              if (P) {
                const Be = l.getValueAndResolveTokens("icon-image", ye, s, F);
                Ee = Be instanceof Lr ? Be : Lr.fromString(Be);
              }
              if (!Te && !Ee) continue;
              const $e = this.sortFeaturesByKey ? I.evaluate(ye, {}, s) : void 0;
              if (this.features.push({ id: H, text: Te, icon: Ee, index: he, sourceLayerIndex: ee, geometry: ye.geometry, properties: $.properties, type: cl.types[$.type], sortKey: $e }), Ee && (z[Ee.name] = !0), Te) {
                const Be = f.evaluate(ye, {}, s).join(","), Ve = p.get("text-rotation-alignment") !== "viewport" && p.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(T.ao.vertical) >= 0;
                for (const st of Te.sections) if (st.image) z[st.image.name] = !0;
                else {
                  const je = Xa(Te.toString()), Ne = st.fontStack || Be, Me = L[Ne] = L[Ne] || {};
                  this.calculateGlyphDependencies(st.text, Me, Ve, this.allowVerticalPlacement, je);
                }
              }
            }
            p.get("symbol-placement") === "line" && (this.features = function($) {
              const H = {}, he = {}, ee = [];
              let re = 0;
              function ye(Be) {
                ee.push($[Be]), re++;
              }
              function Te(Be, Ve, st) {
                const je = he[Be];
                return delete he[Be], he[Ve] = je, ee[je].geometry[0].pop(), ee[je].geometry[0] = ee[je].geometry[0].concat(st[0]), je;
              }
              function Ee(Be, Ve, st) {
                const je = H[Ve];
                return delete H[Ve], H[Be] = je, ee[je].geometry[0].shift(), ee[je].geometry[0] = st[0].concat(ee[je].geometry[0]), je;
              }
              function $e(Be, Ve, st) {
                const je = st ? Ve[0][Ve[0].length - 1] : Ve[0][0];
                return `${Be}:${je.x}:${je.y}`;
              }
              for (let Be = 0; Be < $.length; Be++) {
                const Ve = $[Be], st = Ve.geometry, je = Ve.text ? Ve.text.toString() : null;
                if (!je) {
                  ye(Be);
                  continue;
                }
                const Ne = $e(je, st), Me = $e(je, st, !0);
                if (Ne in he && Me in H && he[Ne] !== H[Me]) {
                  const mt = Ee(Ne, Me, st), xt = Te(Ne, Me, ee[mt].geometry);
                  delete H[Ne], delete he[Me], he[$e(je, ee[xt].geometry, !0)] = xt, ee[mt].geometry = null;
                } else Ne in he ? Te(Ne, Me, st) : Me in H ? Ee(Ne, Me, st) : (ye(Be), H[Ne] = re - 1, he[Me] = re - 1);
              }
              return ee.filter((Be) => Be.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort(($, H) => $.sortKey - H.sortKey);
          }
          update(t, i, s) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, i, this.layers, { imagePositions: s, globalState: this.globalState }), this.icon.programConfigurations.updatePaintArrays(t, i, this.layers, { imagePositions: s, globalState: this.globalState }));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t, i) {
            const s = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let l = t.dist(i[t.segment + 1]), p = t.dist(i[t.segment]);
              const f = {};
              for (let _ = t.segment + 1; _ < i.length; _++) f[_] = { x: i[_].x, y: i[_].y, tileUnitDistanceFromAnchor: l }, _ < i.length - 1 && (l += i[_ + 1].dist(i[_]));
              for (let _ = t.segment || 0; _ >= 0; _--) f[_] = { x: i[_].x, y: i[_].y, tileUnitDistanceFromAnchor: p }, _ > 0 && (p += i[_ - 1].dist(i[_]));
              for (let _ = 0; _ < i.length; _++) {
                const y = f[_];
                this.lineVertexArray.emplaceBack(y.x, y.y, y.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: s, lineLength: this.lineVertexArray.length - s };
          }
          addSymbols(t, i, s, l, p, f, _, y, w, P, I, z) {
            const L = t.indexArray, F = t.layoutVertexArray, V = t.segments.prepareSegment(4 * i.length, F, L, this.canOverlap ? f.sortKey : void 0), $ = this.glyphOffsetArray.length, H = V.vertexLength, he = this.allowVerticalPlacement && _ === T.ao.vertical ? Math.PI / 2 : 0, ee = f.text && f.text.sections;
            for (let re = 0; re < i.length; re++) {
              const { tl: ye, tr: Te, bl: Ee, br: $e, tex: Be, pixelOffsetTL: Ve, pixelOffsetBR: st, minFontScaleX: je, minFontScaleY: Ne, glyphOffset: Me, isSDF: mt, sectionIndex: xt } = i[re], lt = V.vertexLength, tt = Me[1];
              uh(F, y.x, y.y, ye.x, tt + ye.y, Be.x, Be.y, s, mt, Ve.x, Ve.y, je, Ne), uh(F, y.x, y.y, Te.x, tt + Te.y, Be.x + Be.w, Be.y, s, mt, st.x, Ve.y, je, Ne), uh(F, y.x, y.y, Ee.x, tt + Ee.y, Be.x, Be.y + Be.h, s, mt, Ve.x, st.y, je, Ne), uh(F, y.x, y.y, $e.x, tt + $e.y, Be.x + Be.w, Be.y + Be.h, s, mt, st.x, st.y, je, Ne), Jd(t.dynamicLayoutVertexArray, y, he), L.emplaceBack(lt, lt + 2, lt + 1), L.emplaceBack(lt + 1, lt + 2, lt + 3), V.vertexLength += 4, V.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Me[0]), re !== i.length - 1 && xt === i[re + 1].sectionIndex || t.programConfigurations.populatePaintArrays(F.length, f, f.index, { imagePositions: {}, canonical: z, formattedSection: ee && ee[xt], globalState: this.globalState });
            }
            t.placedSymbolArray.emplaceBack(y.x, y.y, $, this.glyphOffsetArray.length - $, H, w, P, y.segment, s ? s[0] : 0, s ? s[1] : 0, l[0], l[1], _, 0, !1, 0, I);
          }
          _addCollisionDebugVertex(t, i, s, l, p, f) {
            return i.emplaceBack(0, 0), t.emplaceBack(s.x, s.y, l, p, Math.round(f.x), Math.round(f.y));
          }
          addCollisionDebugVertices(t, i, s, l, p, f, _) {
            const y = p.segments.prepareSegment(4, p.layoutVertexArray, p.indexArray), w = y.vertexLength, P = p.layoutVertexArray, I = p.collisionVertexArray, z = _.anchorX, L = _.anchorY;
            this._addCollisionDebugVertex(P, I, f, z, L, new U(t, i)), this._addCollisionDebugVertex(P, I, f, z, L, new U(s, i)), this._addCollisionDebugVertex(P, I, f, z, L, new U(s, l)), this._addCollisionDebugVertex(P, I, f, z, L, new U(t, l)), y.vertexLength += 4;
            const F = p.indexArray;
            F.emplaceBack(w, w + 1), F.emplaceBack(w + 1, w + 2), F.emplaceBack(w + 2, w + 3), F.emplaceBack(w + 3, w), y.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t, i, s, l) {
            for (let p = t; p < i; p++) {
              const f = this.collisionBoxArray.get(p);
              this.addCollisionDebugVertices(f.x1, f.y1, f.x2, f.y2, l ? this.textCollisionBox : this.iconCollisionBox, f.anchorPoint, s);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ep(Ct, Gf.members, ei), this.iconCollisionBox = new ep(Ct, Gf.members, ei);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const i = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(i.textBoxStartIndex, i.textBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.iconBoxStartIndex, i.iconBoxEndIndex, i, !1), this.addDebugCollisionBoxes(i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex, i, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(t, i, s, l, p, f, _, y, w) {
            const P = {};
            for (let I = i; I < s; I++) {
              const z = t.get(I);
              P.textBox = { x1: z.x1, y1: z.y1, x2: z.x2, y2: z.y2, anchorPointX: z.anchorPointX, anchorPointY: z.anchorPointY }, P.textFeatureIndex = z.featureIndex;
              break;
            }
            for (let I = l; I < p; I++) {
              const z = t.get(I);
              P.verticalTextBox = { x1: z.x1, y1: z.y1, x2: z.x2, y2: z.y2, anchorPointX: z.anchorPointX, anchorPointY: z.anchorPointY }, P.verticalTextFeatureIndex = z.featureIndex;
              break;
            }
            for (let I = f; I < _; I++) {
              const z = t.get(I);
              P.iconBox = { x1: z.x1, y1: z.y1, x2: z.x2, y2: z.y2, anchorPointX: z.anchorPointX, anchorPointY: z.anchorPointY }, P.iconFeatureIndex = z.featureIndex;
              break;
            }
            for (let I = y; I < w; I++) {
              const z = t.get(I);
              P.verticalIconBox = { x1: z.x1, y1: z.y1, x2: z.x2, y2: z.y2, anchorPointX: z.anchorPointX, anchorPointY: z.anchorPointY }, P.verticalIconFeatureIndex = z.featureIndex;
              break;
            }
            return P;
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let i = 0; i < this.symbolInstances.length; i++) {
              const s = this.symbolInstances.get(i);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, s.textBoxStartIndex, s.textBoxEndIndex, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s.iconBoxStartIndex, s.iconBoxEndIndex, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t, i) {
            const s = t.placedSymbolArray.get(i), l = s.vertexStartIndex + 4 * s.numGlyphs;
            for (let p = s.vertexStartIndex; p < l; p += 4) t.indexArray.emplaceBack(p, p + 2, p + 1), t.indexArray.emplaceBack(p + 1, p + 2, p + 3);
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const i = Math.sin(t), s = Math.cos(t), l = [], p = [], f = [];
            for (let _ = 0; _ < this.symbolInstances.length; ++_) {
              f.push(_);
              const y = this.symbolInstances.get(_);
              l.push(0 | Math.round(i * y.anchorX + s * y.anchorY)), p.push(y.featureIndex);
            }
            return f.sort((_, y) => l[_] - l[y] || p[y] - p[_]), f;
          }
          addToSortKeyRanges(t, i) {
            const s = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            s && s.sortKey === i ? s.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: i, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const i of this.symbolInstanceIndexes) {
                const s = this.symbolInstances.get(i);
                this.featureSortOrder.push(s.featureIndex), [s.rightJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.leftJustifiedTextSymbolIndex].forEach((l, p, f) => {
                  l >= 0 && f.indexOf(l) === p && this.addIndicesForPlacedSymbol(this.text, l);
                }), s.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, s.verticalPlacedTextSymbolIndex), s.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, s.placedIconSymbolIndex), s.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, s.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let sm, om;
        We("SymbolBucket", dl, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), dl.MAX_GLYPHS = 65535, dl.addDynamicAttributes = Jd;
        var tp = { get paint() {
          return om = om || new br({ "icon-opacity": new dt(fe.paint_symbol["icon-opacity"]), "icon-color": new dt(fe.paint_symbol["icon-color"]), "icon-halo-color": new dt(fe.paint_symbol["icon-halo-color"]), "icon-halo-width": new dt(fe.paint_symbol["icon-halo-width"]), "icon-halo-blur": new dt(fe.paint_symbol["icon-halo-blur"]), "icon-translate": new nt(fe.paint_symbol["icon-translate"]), "icon-translate-anchor": new nt(fe.paint_symbol["icon-translate-anchor"]), "text-opacity": new dt(fe.paint_symbol["text-opacity"]), "text-color": new dt(fe.paint_symbol["text-color"], { runtimeType: rr, getOverride: (r) => r.textColor, hasOverride: (r) => !!r.textColor }), "text-halo-color": new dt(fe.paint_symbol["text-halo-color"]), "text-halo-width": new dt(fe.paint_symbol["text-halo-width"]), "text-halo-blur": new dt(fe.paint_symbol["text-halo-blur"]), "text-translate": new nt(fe.paint_symbol["text-translate"]), "text-translate-anchor": new nt(fe.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return sm = sm || new br({ "symbol-placement": new nt(fe.layout_symbol["symbol-placement"]), "symbol-spacing": new nt(fe.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new nt(fe.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new dt(fe.layout_symbol["symbol-sort-key"]), "symbol-z-order": new nt(fe.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new nt(fe.layout_symbol["icon-allow-overlap"]), "icon-overlap": new nt(fe.layout_symbol["icon-overlap"]), "icon-ignore-placement": new nt(fe.layout_symbol["icon-ignore-placement"]), "icon-optional": new nt(fe.layout_symbol["icon-optional"]), "icon-rotation-alignment": new nt(fe.layout_symbol["icon-rotation-alignment"]), "icon-size": new dt(fe.layout_symbol["icon-size"]), "icon-text-fit": new nt(fe.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new nt(fe.layout_symbol["icon-text-fit-padding"]), "icon-image": new dt(fe.layout_symbol["icon-image"]), "icon-rotate": new dt(fe.layout_symbol["icon-rotate"]), "icon-padding": new dt(fe.layout_symbol["icon-padding"]), "icon-keep-upright": new nt(fe.layout_symbol["icon-keep-upright"]), "icon-offset": new dt(fe.layout_symbol["icon-offset"]), "icon-anchor": new dt(fe.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new nt(fe.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new nt(fe.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new nt(fe.layout_symbol["text-rotation-alignment"]), "text-field": new dt(fe.layout_symbol["text-field"]), "text-font": new dt(fe.layout_symbol["text-font"]), "text-size": new dt(fe.layout_symbol["text-size"]), "text-max-width": new dt(fe.layout_symbol["text-max-width"]), "text-line-height": new nt(fe.layout_symbol["text-line-height"]), "text-letter-spacing": new dt(fe.layout_symbol["text-letter-spacing"]), "text-justify": new dt(fe.layout_symbol["text-justify"]), "text-radial-offset": new dt(fe.layout_symbol["text-radial-offset"]), "text-variable-anchor": new nt(fe.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new dt(fe.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new dt(fe.layout_symbol["text-anchor"]), "text-max-angle": new nt(fe.layout_symbol["text-max-angle"]), "text-writing-mode": new nt(fe.layout_symbol["text-writing-mode"]), "text-rotate": new dt(fe.layout_symbol["text-rotate"]), "text-padding": new nt(fe.layout_symbol["text-padding"]), "text-keep-upright": new nt(fe.layout_symbol["text-keep-upright"]), "text-transform": new dt(fe.layout_symbol["text-transform"]), "text-offset": new dt(fe.layout_symbol["text-offset"]), "text-allow-overlap": new nt(fe.layout_symbol["text-allow-overlap"]), "text-overlap": new nt(fe.layout_symbol["text-overlap"]), "text-ignore-placement": new nt(fe.layout_symbol["text-ignore-placement"]), "text-optional": new nt(fe.layout_symbol["text-optional"]) });
        } };
        class am {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : $s, this.defaultValue = t;
          }
          evaluate(t) {
            if (t.formattedSection) {
              const i = this.defaultValue.property.overrides;
              if (i && i.hasOverride(t.formattedSection)) return i.getOverride(t.formattedSection);
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        We("FormatSectionOverride", am, { omit: ["defaultValue"] });
        class hh extends Kr {
          constructor(t) {
            super(t, tp);
          }
          recalculate(t, i) {
            if (super.recalculate(t, i), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const s = this.layout.get("text-writing-mode");
              if (s) {
                const l = [];
                for (const p of s) l.indexOf(p) < 0 && l.push(p);
                this.layout._values["text-writing-mode"] = l;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t, i, s, l) {
            const p = this.layout.get(t).evaluate(i, {}, s, l), f = this._unevaluatedLayout._values[t];
            return f.isDataDriven() || Na(f.value) || !p ? p : function(_, y) {
              return y.replace(/{([^{}]+)}/g, (w, P) => _ && P in _ ? String(_[P]) : "");
            }(i.properties, p);
          }
          createBucket(t) {
            return new dl(t);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t of tp.paint.overridableProperties) {
              if (!hh.hasPaintOverride(this.layout, t)) continue;
              const i = this.paint.get(t), s = new am(i), l = new nc(s, i.property.specification);
              let p = null;
              p = i.value.kind === "constant" || i.value.kind === "source" ? new Zo("source", l) : new sc("composite", l, i.value.zoomStops), this.paint._values[t] = new Pn(i.property, p, i.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t, i, s) {
            return !(!this.layout || i.isDataDriven() || s.isDataDriven()) && hh.hasPaintOverride(this.layout, t);
          }
          static hasPaintOverride(t, i) {
            const s = t.get("text-field"), l = tp.paint.properties[i];
            let p = !1;
            const f = (_) => {
              for (const y of _) if (l.overrides && l.overrides.hasOverride(y)) return void (p = !0);
            };
            if (s.value.kind === "constant" && s.value.value instanceof yr) f(s.value.value.sections);
            else if (s.value.kind === "source" || s.value.kind === "composite") {
              const _ = (w) => {
                p || (w instanceof En && ft(w.value) === Zn ? f(w.value.sections) : w instanceof ys ? f(w.sections) : w.eachChild(_));
              }, y = s.value;
              y._styleExpression && _(y._styleExpression.expression);
            }
            return p;
          }
        }
        let lm;
        var mv = { get paint() {
          return lm = lm || new br({ "background-color": new nt(fe.paint_background["background-color"]), "background-pattern": new Kn(fe.paint_background["background-pattern"]), "background-opacity": new nt(fe.paint_background["background-opacity"]) });
        } };
        class gv extends Kr {
          constructor(t) {
            super(t, mv);
          }
        }
        let cm;
        var _v = { get paint() {
          return cm = cm || new br({ "raster-opacity": new nt(fe.paint_raster["raster-opacity"]), "raster-hue-rotate": new nt(fe.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new nt(fe.paint_raster["raster-brightness-min"]), "raster-brightness-max": new nt(fe.paint_raster["raster-brightness-max"]), "raster-saturation": new nt(fe.paint_raster["raster-saturation"]), "raster-contrast": new nt(fe.paint_raster["raster-contrast"]), "raster-resampling": new nt(fe.paint_raster["raster-resampling"]), "raster-fade-duration": new nt(fe.paint_raster["raster-fade-duration"]) });
        } };
        class yv extends Kr {
          constructor(t) {
            super(t, _v);
          }
        }
        class vv extends Kr {
          constructor(t) {
            super(t, {}), this.onAdd = (i) => {
              this.implementation.onAdd && this.implementation.onAdd(i, i.painter.context.gl);
            }, this.onRemove = (i) => {
              this.implementation.onRemove && this.implementation.onRemove(i, i.painter.context.gl);
            }, this.implementation = t;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class xv {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
              this._triggered = !1, this._methodToThrottle();
            }, 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const bv = { once: !0 }, ip = 63710088e-1;
        class go {
          constructor(t, i) {
            if (isNaN(t) || isNaN(i)) throw new Error(`Invalid LngLat object: (${t}, ${i})`);
            if (this.lng = +t, this.lat = +i, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new go(Qr(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t) {
            const i = Math.PI / 180, s = this.lat * i, l = t.lat * i, p = Math.sin(s) * Math.sin(l) + Math.cos(s) * Math.cos(l) * Math.cos((t.lng - this.lng) * i);
            return ip * Math.acos(Math.min(p, 1));
          }
          static convert(t) {
            if (t instanceof go) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new go(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new go(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const um = 2 * Math.PI * ip;
        function hm(r) {
          return um * Math.cos(r * Math.PI / 180);
        }
        function dm(r) {
          return (180 + r) / 360;
        }
        function pm(r) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
        }
        function fm(r, t) {
          return r / hm(t);
        }
        function rp(r) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90;
        }
        function mm(r, t) {
          return r * hm(rp(t));
        }
        class jc {
          constructor(t, i, s = 0) {
            this.x = +t, this.y = +i, this.z = +s;
          }
          static fromLngLat(t, i = 0) {
            const s = go.convert(t);
            return new jc(dm(s.lng), pm(s.lat), fm(i, s.lat));
          }
          toLngLat() {
            return new go(360 * this.x - 180, rp(this.y));
          }
          toAltitude() {
            return mm(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / um * (t = rp(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t;
          }
        }
        function gm(r, t, i) {
          var s = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i);
          return [r * s - 2 * Math.PI * 6378137 / 2, t * s - 2 * Math.PI * 6378137 / 2];
        }
        class np {
          constructor(t, i, s) {
            if (!function(l, p, f) {
              return !(l < 0 || l > 25 || f < 0 || f >= Math.pow(2, l) || p < 0 || p >= Math.pow(2, l));
            }(t, i, s)) throw new Error(`x=${i}, y=${s}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
            this.z = t, this.x = i, this.y = s, this.key = pl(0, t, t, i, s);
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y;
          }
          url(t, i, s) {
            const l = (f = this.y, _ = this.z, y = gm(256 * (p = this.x), 256 * (f = Math.pow(2, _) - f - 1), _), w = gm(256 * (p + 1), 256 * (f + 1), _), y[0] + "," + y[1] + "," + w[0] + "," + w[1]);
            var p, f, _, y, w;
            const P = function(I, z, L) {
              let F, V = "";
              for (let $ = I; $ > 0; $--) F = 1 << $ - 1, V += (z & F ? 1 : 0) + (L & F ? 2 : 0);
              return V;
            }(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(s === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, i > 1 ? "@2x" : "").replace(/{quadkey}/g, P).replace(/{bbox-epsg-3857}/g, l);
          }
          isChildOf(t) {
            const i = this.z - t.z;
            return i > 0 && t.x === this.x >> i && t.y === this.y >> i;
          }
          getTilePoint(t) {
            const i = Math.pow(2, this.z);
            return new U((t.x * i - this.x) * Zt, (t.y * i - this.y) * Zt);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class _m {
          constructor(t, i) {
            this.wrap = t, this.canonical = i, this.key = pl(t, i.z, i.z, i.x, i.y);
          }
        }
        class dn {
          constructor(t, i, s, l, p) {
            if (this.terrainRttPosMatrix32f = null, t < s) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${s}`);
            this.overscaledZ = t, this.wrap = i, this.canonical = new np(s, +l, +p), this.key = pl(i, t, s, l, p);
          }
          clone() {
            return new dn(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const i = this.canonical.z - t;
            return t > this.canonical.z ? new dn(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new dn(t, this.wrap, t, this.canonical.x >> i, this.canonical.y >> i);
          }
          calculateScaledKey(t, i) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const s = this.canonical.z - t;
            return t > this.canonical.z ? pl(this.wrap * +i, t, this.canonical.z, this.canonical.x, this.canonical.y) : pl(this.wrap * +i, t, t, this.canonical.x >> s, this.canonical.y >> s);
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap) return !1;
            const i = this.canonical.z - t.canonical.z;
            return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> i && t.canonical.y === this.canonical.y >> i;
          }
          children(t) {
            if (this.overscaledZ >= t) return [new dn(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const i = this.canonical.z + 1, s = 2 * this.canonical.x, l = 2 * this.canonical.y;
            return [new dn(i, this.wrap, i, s, l), new dn(i, this.wrap, i, s + 1, l), new dn(i, this.wrap, i, s, l + 1), new dn(i, this.wrap, i, s + 1, l + 1)];
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
          }
          wrapped() {
            return new dn(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t) {
            return new dn(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new _m(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new jc(t.x - this.wrap, t.y));
          }
        }
        function pl(r, t, i, s, l) {
          (r *= 2) < 0 && (r = -1 * r - 1);
          const p = 1 << i;
          return (p * p * r + p * l + s).toString(36) + i.toString(36) + t.toString(36);
        }
        function Vc(r, t) {
          return t ? r.properties[t] : r.id;
        }
        We("CanonicalTileID", np), We("OverscaledTileID", dn, { omit: ["terrainRttPosMatrix32f"] });
        class ra {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this;
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(t) {
            return this.expandBy(-t);
          }
          map(t) {
            const i = new ra();
            return i.extend(t(new U(this.minX, this.minY))), i.extend(t(new U(this.maxX, this.minY))), i.extend(t(new U(this.minX, this.maxY))), i.extend(t(new U(this.maxX, this.maxY))), i;
          }
          static fromPoints(t) {
            const i = new ra();
            for (const s of t) i.extend(s);
            return i;
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY;
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY;
          }
        }
        class ym {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let i = 0; i < t.length; i++) {
              const s = t[i];
              this._stringToNumber[s] = i, this._numberToString[i] = s;
            }
          }
          encode(t) {
            return this._stringToNumber[t];
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t];
          }
        }
        class vm {
          constructor(t, i, s, l, p) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = i, t._x = s, t._y = l, this.properties = t.properties, this.id = p;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t) {
            this._geometry = t;
          }
          toJSON() {
            const t = { geometry: this.geometry };
            for (const i in this) i !== "_geometry" && i !== "_vectorTileFeature" && (t[i] = this[i]);
            return t;
          }
        }
        class xm {
          constructor(t, i) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Yo(Zt, 16, 0), this.grid3D = new Yo(Zt, 16, 0), this.featureIndexArray = new se(), this.promoteId = i;
          }
          insert(t, i, s, l, p, f) {
            const _ = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(s, l, p);
            const y = f ? this.grid3D : this.grid;
            for (let w = 0; w < i.length; w++) {
              const P = i[w], I = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let z = 0; z < P.length; z++) {
                const L = P[z];
                I[0] = Math.min(I[0], L.x), I[1] = Math.min(I[1], L.y), I[2] = Math.max(I[2], L.x), I[3] = Math.max(I[3], L.y);
              }
              I[0] < Zt && I[1] < Zt && I[2] >= 0 && I[3] >= 0 && y.insert(_, I[0], I[1], I[2], I[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Ff(new Hd(this.rawTileData)).layers, this.sourceLayerCoder = new ym(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t, i, s, l) {
            this.loadVTLayers();
            const p = t.params, f = Zt / t.tileSize / t.scale, _ = Ss(p.filter), y = t.queryGeometry, w = t.queryPadding * f, P = ra.fromPoints(y), I = this.grid.query(P.minX - w, P.minY - w, P.maxX + w, P.maxY + w), z = ra.fromPoints(t.cameraQueryGeometry).expandBy(w), L = this.grid3D.query(z.minX, z.minY, z.maxX, z.maxY, ($, H, he, ee) => function(re, ye, Te, Ee, $e) {
              for (const Ve of re) if (ye <= Ve.x && Te <= Ve.y && Ee >= Ve.x && $e >= Ve.y) return !0;
              const Be = [new U(ye, Te), new U(ye, $e), new U(Ee, $e), new U(Ee, Te)];
              if (re.length > 2) {
                for (const Ve of Be) if (sl(re, Ve)) return !0;
              }
              for (let Ve = 0; Ve < re.length - 1; Ve++) if (Q_(re[Ve], re[Ve + 1], Be)) return !0;
              return !1;
            }(t.cameraQueryGeometry, $ - w, H - w, he + w, ee + w));
            for (const $ of L) I.push($);
            I.sort(wv);
            const F = {};
            let V;
            for (let $ = 0; $ < I.length; $++) {
              const H = I[$];
              if (H === V) continue;
              V = H;
              const he = this.featureIndexArray.get(H);
              let ee = null;
              this.loadMatchingFeature(F, he.bucketIndex, he.sourceLayerIndex, he.featureIndex, _, p.layers, p.availableImages, i, s, l, (re, ye, Te) => (ee || (ee = ts(re)), ye.queryIntersectsFeature({ queryGeometry: y, feature: re, featureState: Te, geometry: ee, zoom: this.z, transform: t.transform, pixelsToTileUnits: f, pixelPosMatrix: t.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t.getElevation })));
            }
            return F;
          }
          loadMatchingFeature(t, i, s, l, p, f, _, y, w, P, I) {
            const z = this.bucketLayerIDs[i];
            if (f && !z.some(($) => f.has($))) return;
            const L = this.sourceLayerCoder.decode(s), F = this.vtLayers[L].feature(l);
            if (p.needGeometry) {
              const $ = Rn(F, !0);
              if (!p.filter(new ai(this.tileID.overscaledZ), $, this.tileID.canonical)) return;
            } else if (!p.filter(new ai(this.tileID.overscaledZ), F)) return;
            const V = this.getId(F, L);
            for (let $ = 0; $ < z.length; $++) {
              const H = z[$];
              if (f && !f.has(H)) continue;
              const he = y[H];
              if (!he) continue;
              let ee = {};
              V && P && (ee = P.getState(he.sourceLayer || "_geojsonTileLayer", V));
              const re = ur({}, w[H]);
              re.paint = bm(re.paint, he.paint, F, ee, _), re.layout = bm(re.layout, he.layout, F, ee, _);
              const ye = !I || I(F, he, ee);
              if (!ye) continue;
              const Te = new vm(F, this.z, this.x, this.y, V);
              Te.layer = re;
              let Ee = t[H];
              Ee === void 0 && (Ee = t[H] = []), Ee.push({ featureIndex: l, feature: Te, intersectionZ: ye });
            }
          }
          lookupSymbolFeatures(t, i, s, l, p, f, _, y) {
            const w = {};
            this.loadVTLayers();
            const P = Ss(p);
            for (const I of t) this.loadMatchingFeature(w, s, l, I, P, f, _, y, i);
            return w;
          }
          hasLayer(t) {
            for (const i of this.bucketLayerIDs) for (const s of i) if (t === s) return !0;
            return !1;
          }
          getId(t, i) {
            var s;
            let l = t.id;
            return this.promoteId && (l = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[i]], typeof l == "boolean" && (l = Number(l)), l === void 0 && (!((s = t.properties) === null || s === void 0) && s.cluster) && this.promoteId && (l = Number(t.properties.cluster_id))), l;
          }
        }
        function bm(r, t, i, s, l) {
          return Hr(r, (p, f) => {
            const _ = t instanceof Ya ? t.get(f) : null;
            return _ && _.evaluate ? _.evaluate(i, s, l) : _;
          });
        }
        function wv(r, t) {
          return t - r;
        }
        function wm(r, t, i, s, l) {
          const p = [];
          for (let f = 0; f < r.length; f++) {
            const _ = r[f];
            let y;
            for (let w = 0; w < _.length - 1; w++) {
              let P = _[w], I = _[w + 1];
              P.x < t && I.x < t || (P.x < t ? P = new U(t, P.y + (t - P.x) / (I.x - P.x) * (I.y - P.y))._round() : I.x < t && (I = new U(t, P.y + (t - P.x) / (I.x - P.x) * (I.y - P.y))._round()), P.y < i && I.y < i || (P.y < i ? P = new U(P.x + (i - P.y) / (I.y - P.y) * (I.x - P.x), i)._round() : I.y < i && (I = new U(P.x + (i - P.y) / (I.y - P.y) * (I.x - P.x), i)._round()), P.x >= s && I.x >= s || (P.x >= s ? P = new U(s, P.y + (s - P.x) / (I.x - P.x) * (I.y - P.y))._round() : I.x >= s && (I = new U(s, P.y + (s - P.x) / (I.x - P.x) * (I.y - P.y))._round()), P.y >= l && I.y >= l || (P.y >= l ? P = new U(P.x + (l - P.y) / (I.y - P.y) * (I.x - P.x), l)._round() : I.y >= l && (I = new U(P.x + (l - P.y) / (I.y - P.y) * (I.x - P.x), l)._round()), y && P.equals(y[y.length - 1]) || (y = [P], p.push(y)), y.push(I)))));
            }
          }
          return p;
        }
        We("FeatureIndex", xm, { omit: ["rawTileData", "sourceLayerCoder"] });
        class _o extends U {
          constructor(t, i, s, l) {
            super(t, i), this.angle = s, l !== void 0 && (this.segment = l);
          }
          clone() {
            return new _o(this.x, this.y, this.angle, this.segment);
          }
        }
        function Tm(r, t, i, s, l) {
          if (t.segment === void 0 || i === 0) return !0;
          let p = t, f = t.segment + 1, _ = 0;
          for (; _ > -i / 2; ) {
            if (f--, f < 0) return !1;
            _ -= r[f].dist(p), p = r[f];
          }
          _ += r[f].dist(r[f + 1]), f++;
          const y = [];
          let w = 0;
          for (; _ < i / 2; ) {
            const P = r[f], I = r[f + 1];
            if (!I) return !1;
            let z = r[f - 1].angleTo(P) - P.angleTo(I);
            for (z = Math.abs((z + 3 * Math.PI) % (2 * Math.PI) - Math.PI), y.push({ distance: _, angleDelta: z }), w += z; _ - y[0].distance > s; ) w -= y.shift().angleDelta;
            if (w > l) return !1;
            f++, _ += P.dist(I);
          }
          return !0;
        }
        function Sm(r) {
          let t = 0;
          for (let i = 0; i < r.length - 1; i++) t += r[i].dist(r[i + 1]);
          return t;
        }
        function Pm(r, t, i) {
          return r ? 0.6 * t * i : 0;
        }
        function Mm(r, t) {
          return Math.max(r ? r.right - r.left : 0, t ? t.right - t.left : 0);
        }
        function Tv(r, t, i, s, l, p) {
          const f = Pm(i, l, p), _ = Mm(i, s) * p;
          let y = 0;
          const w = Sm(r) / 2;
          for (let P = 0; P < r.length - 1; P++) {
            const I = r[P], z = r[P + 1], L = I.dist(z);
            if (y + L > w) {
              const F = (w - y) / L, V = Tn.number(I.x, z.x, F), $ = Tn.number(I.y, z.y, F), H = new _o(V, $, z.angleTo(I), P);
              return H._round(), !f || Tm(r, H, _, f, t) ? H : void 0;
            }
            y += L;
          }
        }
        function Sv(r, t, i, s, l, p, f, _, y) {
          const w = Pm(s, p, f), P = Mm(s, l), I = P * f, z = r[0].x === 0 || r[0].x === y || r[0].y === 0 || r[0].y === y;
          return t - I < t / 4 && (t = I + t / 4), Cm(r, z ? t / 2 * _ % t : (P / 2 + 2 * p) * f * _ % t, t, w, i, I, z, !1, y);
        }
        function Cm(r, t, i, s, l, p, f, _, y) {
          const w = p / 2, P = Sm(r);
          let I = 0, z = t - i, L = [];
          for (let F = 0; F < r.length - 1; F++) {
            const V = r[F], $ = r[F + 1], H = V.dist($), he = $.angleTo(V);
            for (; z + i < I + H; ) {
              z += i;
              const ee = (z - I) / H, re = Tn.number(V.x, $.x, ee), ye = Tn.number(V.y, $.y, ee);
              if (re >= 0 && re < y && ye >= 0 && ye < y && z - w >= 0 && z + w <= P) {
                const Te = new _o(re, ye, he, F);
                Te._round(), s && !Tm(r, Te, p, s, l) || L.push(Te);
              }
            }
            I += H;
          }
          return _ || L.length || f || (L = Cm(r, I / 2, i, s, l, p, f, !0, y)), L;
        }
        function Im(r, t, i, s) {
          const l = [], p = r.image, f = p.pixelRatio, _ = p.paddedRect.w - 2, y = p.paddedRect.h - 2;
          let w = { x1: r.left, y1: r.top, x2: r.right, y2: r.bottom };
          const P = p.stretchX || [[0, _]], I = p.stretchY || [[0, y]], z = (Me, mt) => Me + mt[1] - mt[0], L = P.reduce(z, 0), F = I.reduce(z, 0), V = _ - L, $ = y - F;
          let H = 0, he = L, ee = 0, re = F, ye = 0, Te = V, Ee = 0, $e = $;
          if (p.content && s) {
            const Me = p.content, mt = Me[2] - Me[0], xt = Me[3] - Me[1];
            (p.textFitWidth || p.textFitHeight) && (w = im(r)), H = dh(P, 0, Me[0]), ee = dh(I, 0, Me[1]), he = dh(P, Me[0], Me[2]), re = dh(I, Me[1], Me[3]), ye = Me[0] - H, Ee = Me[1] - ee, Te = mt - he, $e = xt - re;
          }
          const Be = w.x1, Ve = w.y1, st = w.x2 - Be, je = w.y2 - Ve, Ne = (Me, mt, xt, lt) => {
            const tt = ph(Me.stretch - H, he, st, Be), $t = fh(Me.fixed - ye, Te, Me.stretch, L), wi = ph(mt.stretch - ee, re, je, Ve), Ui = fh(mt.fixed - Ee, $e, mt.stretch, F), mr = ph(xt.stretch - H, he, st, Be), pn = fh(xt.fixed - ye, Te, xt.stretch, L), jr = ph(lt.stretch - ee, re, je, Ve), sr = fh(lt.fixed - Ee, $e, lt.stretch, F), _i = new U(tt, wi), Ki = new U(mr, wi), or = new U(mr, jr), ar = new U(tt, jr), kr = new U($t / f, Ui / f), fn = new U(pn / f, sr / f), Yi = t * Math.PI / 180;
            if (Yi) {
              const Ji = Math.sin(Yi), Qi = Math.cos(Yi), Oi = [Qi, -Ji, Ji, Qi];
              _i._matMult(Oi), Ki._matMult(Oi), ar._matMult(Oi), or._matMult(Oi);
            }
            const Vr = Me.stretch + Me.fixed, Zi = mt.stretch + mt.fixed;
            return { tl: _i, tr: Ki, bl: ar, br: or, tex: { x: p.paddedRect.x + 1 + Vr, y: p.paddedRect.y + 1 + Zi, w: xt.stretch + xt.fixed - Vr, h: lt.stretch + lt.fixed - Zi }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: kr, pixelOffsetBR: fn, minFontScaleX: Te / f / st, minFontScaleY: $e / f / je, isSDF: i };
          };
          if (s && (p.stretchX || p.stretchY)) {
            const Me = Em(P, V, L), mt = Em(I, $, F);
            for (let xt = 0; xt < Me.length - 1; xt++) {
              const lt = Me[xt], tt = Me[xt + 1];
              for (let $t = 0; $t < mt.length - 1; $t++) l.push(Ne(lt, mt[$t], tt, mt[$t + 1]));
            }
          } else l.push(Ne({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: _ + 1 }, { fixed: 0, stretch: y + 1 }));
          return l;
        }
        function dh(r, t, i) {
          let s = 0;
          for (const l of r) s += Math.max(t, Math.min(i, l[1])) - Math.max(t, Math.min(i, l[0]));
          return s;
        }
        function Em(r, t, i) {
          const s = [{ fixed: -1, stretch: 0 }];
          for (const [l, p] of r) {
            const f = s[s.length - 1];
            s.push({ fixed: l - f.stretch, stretch: f.stretch }), s.push({ fixed: l - f.stretch, stretch: f.stretch + (p - l) });
          }
          return s.push({ fixed: t + 1, stretch: i }), s;
        }
        function ph(r, t, i, s) {
          return r / t * i + s;
        }
        function fh(r, t, i, s) {
          return r - t * i / s;
        }
        We("Anchor", _o);
        class mh {
          constructor(t, i, s, l, p, f, _, y, w, P) {
            var I;
            if (this.boxStartIndex = t.length, w) {
              let z = f.top, L = f.bottom;
              const F = f.collisionPadding;
              F && (z -= F[1], L += F[3]);
              let V = L - z;
              V > 0 && (V = Math.max(10, V), this.circleDiameter = V);
            } else {
              const z = !((I = f.image) === null || I === void 0) && I.content && (f.image.textFitWidth || f.image.textFitHeight) ? im(f) : { x1: f.left, y1: f.top, x2: f.right, y2: f.bottom };
              z.y1 = z.y1 * _ - y[0], z.y2 = z.y2 * _ + y[2], z.x1 = z.x1 * _ - y[3], z.x2 = z.x2 * _ + y[1];
              const L = f.collisionPadding;
              if (L && (z.x1 -= L[0] * _, z.y1 -= L[1] * _, z.x2 += L[2] * _, z.y2 += L[3] * _), P) {
                const F = new U(z.x1, z.y1), V = new U(z.x2, z.y1), $ = new U(z.x1, z.y2), H = new U(z.x2, z.y2), he = P * Math.PI / 180;
                F._rotate(he), V._rotate(he), $._rotate(he), H._rotate(he), z.x1 = Math.min(F.x, V.x, $.x, H.x), z.x2 = Math.max(F.x, V.x, $.x, H.x), z.y1 = Math.min(F.y, V.y, $.y, H.y), z.y2 = Math.max(F.y, V.y, $.y, H.y);
              }
              t.emplaceBack(i.x, i.y, z.x1, z.y1, z.x2, z.y2, s, l, p);
            }
            this.boxEndIndex = t.length;
          }
        }
        class Pv {
          constructor(t = [], i = (s, l) => s < l ? -1 : s > l ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = i, this.length > 0) for (let s = (this.length >> 1) - 1; s >= 0; s--) this._down(s);
          }
          push(t) {
            this.data.push(t), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0], i = this.data.pop();
            return --this.length > 0 && (this.data[0] = i, this._down(0)), t;
          }
          peek() {
            return this.data[0];
          }
          _up(t) {
            const { data: i, compare: s } = this, l = i[t];
            for (; t > 0; ) {
              const p = t - 1 >> 1, f = i[p];
              if (s(l, f) >= 0) break;
              i[t] = f, t = p;
            }
            i[t] = l;
          }
          _down(t) {
            const { data: i, compare: s } = this, l = this.length >> 1, p = i[t];
            for (; t < l; ) {
              let f = 1 + (t << 1);
              const _ = f + 1;
              if (_ < this.length && s(i[_], i[f]) < 0 && (f = _), s(i[f], p) >= 0) break;
              i[t] = i[f], t = f;
            }
            i[t] = p;
          }
        }
        function Mv(r, t = 1, i = !1) {
          const s = ra.fromPoints(r[0]), l = Math.min(s.width(), s.height());
          let p = l / 2;
          const f = new Pv([], Cv), { minX: _, minY: y, maxX: w, maxY: P } = s;
          if (l === 0) return new U(_, y);
          for (let L = _; L < w; L += l) for (let F = y; F < P; F += l) f.push(new fl(L + p, F + p, p, r));
          let I = function(L) {
            let F = 0, V = 0, $ = 0;
            const H = L[0];
            for (let he = 0, ee = H.length, re = ee - 1; he < ee; re = he++) {
              const ye = H[he], Te = H[re], Ee = ye.x * Te.y - Te.x * ye.y;
              V += (ye.x + Te.x) * Ee, $ += (ye.y + Te.y) * Ee, F += 3 * Ee;
            }
            return new fl(V / F, $ / F, 0, L);
          }(r), z = f.length;
          for (; f.length; ) {
            const L = f.pop();
            (L.d > I.d || !I.d) && (I = L, i && console.log("found best %d after %d probes", Math.round(1e4 * L.d) / 1e4, z)), L.max - I.d <= t || (p = L.h / 2, f.push(new fl(L.p.x - p, L.p.y - p, p, r)), f.push(new fl(L.p.x + p, L.p.y - p, p, r)), f.push(new fl(L.p.x - p, L.p.y + p, p, r)), f.push(new fl(L.p.x + p, L.p.y + p, p, r)), z += 4);
          }
          return i && (console.log(`num probes: ${z}`), console.log(`best distance: ${I.d}`)), I.p;
        }
        function Cv(r, t) {
          return t.max - r.max;
        }
        function fl(r, t, i, s) {
          this.p = new U(r, t), this.h = i, this.d = function(l, p) {
            let f = !1, _ = 1 / 0;
            for (let y = 0; y < p.length; y++) {
              const w = p[y];
              for (let P = 0, I = w.length, z = I - 1; P < I; z = P++) {
                const L = w[P], F = w[z];
                L.y > l.y != F.y > l.y && l.x < (F.x - L.x) * (l.y - L.y) / (F.y - L.y) + L.x && (f = !f), _ = Math.min(_, pf(l, L, F));
              }
            }
            return (f ? 1 : -1) * Math.sqrt(_);
          }(this.p, s), this.max = this.d + this.h * Math.SQRT2;
        }
        var fr;
        T.aE = void 0, (fr = T.aE || (T.aE = {}))[fr.center = 1] = "center", fr[fr.left = 2] = "left", fr[fr.right = 3] = "right", fr[fr.top = 4] = "top", fr[fr.bottom = 5] = "bottom", fr[fr["top-left"] = 6] = "top-left", fr[fr["top-right"] = 7] = "top-right", fr[fr["bottom-left"] = 8] = "bottom-left", fr[fr["bottom-right"] = 9] = "bottom-right";
        const sp = Number.POSITIVE_INFINITY;
        function Am(r, t) {
          return t[1] !== sp ? function(i, s, l) {
            let p = 0, f = 0;
            switch (s = Math.abs(s), l = Math.abs(l), i) {
              case "top-right":
              case "top-left":
              case "top":
                f = l - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                f = 7 - l;
            }
            switch (i) {
              case "top-right":
              case "bottom-right":
              case "right":
                p = -s;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                p = s;
            }
            return [p, f];
          }(r, t[0], t[1]) : function(i, s) {
            let l = 0, p = 0;
            s < 0 && (s = 0);
            const f = s / Math.SQRT2;
            switch (i) {
              case "top-right":
              case "top-left":
                p = f - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                p = 7 - f;
                break;
              case "bottom":
                p = 7 - s;
                break;
              case "top":
                p = s - 7;
            }
            switch (i) {
              case "top-right":
              case "bottom-right":
                l = -f;
                break;
              case "top-left":
              case "bottom-left":
                l = f;
                break;
              case "left":
                l = s;
                break;
              case "right":
                l = -s;
            }
            return [l, p];
          }(r, t[0]);
        }
        function km(r, t, i) {
          var s;
          const l = r.layout, p = (s = l.get("text-variable-anchor-offset")) === null || s === void 0 ? void 0 : s.evaluate(t, {}, i);
          if (p) {
            const _ = p.values, y = [];
            for (let w = 0; w < _.length; w += 2) {
              const P = y[w] = _[w], I = _[w + 1].map((z) => z * Xi);
              P.startsWith("top") ? I[1] -= 7 : P.startsWith("bottom") && (I[1] += 7), y[w + 1] = I;
            }
            return new xr(y);
          }
          const f = l.get("text-variable-anchor");
          if (f) {
            let _;
            _ = r._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [l.get("text-radial-offset").evaluate(t, {}, i) * Xi, sp] : l.get("text-offset").evaluate(t, {}, i).map((w) => w * Xi);
            const y = [];
            for (const w of f) y.push(w, Am(w, _));
            return new xr(y);
          }
          return null;
        }
        function op(r) {
          switch (r) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function Iv(r, t, i, s, l, p, f, _, y, w, P, I) {
          let z = p.textMaxSize.evaluate(t, {});
          z === void 0 && (z = f);
          const L = r.layers[0].layout, F = L.get("icon-offset").evaluate(t, {}, P), V = Rm(i.horizontal), $ = f / 24, H = r.tilePixelRatio * $, he = r.tilePixelRatio * z / 24, ee = r.tilePixelRatio * _, re = r.tilePixelRatio * L.get("symbol-spacing"), ye = L.get("text-padding") * r.tilePixelRatio, Te = function(xt, lt, tt, $t = 1) {
            const wi = xt.get("icon-padding").evaluate(lt, {}, tt), Ui = wi && wi.values;
            return [Ui[0] * $t, Ui[1] * $t, Ui[2] * $t, Ui[3] * $t];
          }(L, t, P, r.tilePixelRatio), Ee = L.get("text-max-angle") / 180 * Math.PI, $e = L.get("text-rotation-alignment") !== "viewport" && L.get("symbol-placement") !== "point", Be = L.get("icon-rotation-alignment") === "map" && L.get("symbol-placement") !== "point", Ve = L.get("symbol-placement"), st = re / 2, je = L.get("icon-text-fit");
          let Ne;
          s && je !== "none" && (r.allowVerticalPlacement && i.vertical && (Ne = rm(s, i.vertical, je, L.get("icon-text-fit-padding"), F, $)), V && (s = rm(s, V, je, L.get("icon-text-fit-padding"), F, $)));
          const Me = P ? I.line.getGranularityForZoomLevel(P.z) : 1, mt = (xt, lt) => {
            lt.x < 0 || lt.x >= Zt || lt.y < 0 || lt.y >= Zt || function(tt, $t, wi, Ui, mr, pn, jr, sr, _i, Ki, or, ar, kr, fn, Yi, Vr, Zi, Ji, Qi, Oi, di, Dn, ml, Ln, kv) {
              const gl = tt.addToLineVertexArray($t, wi);
              let na, _l, yl, vl, Bm = 0, Om = 0, jm = 0, Vm = 0, fp = -1, mp = -1;
              const Rs = {};
              let Nm = ho("");
              if (tt.allowVerticalPlacement && Ui.vertical) {
                const Sr = sr.layout.get("text-rotate").evaluate(di, {}, Ln) + 90;
                yl = new mh(_i, $t, Ki, or, ar, Ui.vertical, kr, fn, Yi, Sr), jr && (vl = new mh(_i, $t, Ki, or, ar, jr, Zi, Ji, Yi, Sr));
              }
              if (mr) {
                const Sr = sr.layout.get("icon-rotate").evaluate(di, {}), mn = sr.layout.get("icon-text-fit") !== "none", sa = Im(mr, Sr, ml, mn), Bn = jr ? Im(jr, Sr, ml, mn) : void 0;
                _l = new mh(_i, $t, Ki, or, ar, mr, Zi, Ji, !1, Sr), Bm = 4 * sa.length;
                const oa = tt.iconSizeData;
                let is = null;
                oa.kind === "source" ? (is = [zs * sr.layout.get("icon-size").evaluate(di, {})], is[0] > mo && Se(`${tt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : oa.kind === "composite" && (is = [zs * Dn.compositeIconSizes[0].evaluate(di, {}, Ln), zs * Dn.compositeIconSizes[1].evaluate(di, {}, Ln)], (is[0] > mo || is[1] > mo) && Se(`${tt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), tt.addSymbols(tt.icon, sa, is, Oi, Qi, di, T.ao.none, $t, gl.lineStartIndex, gl.lineLength, -1, Ln), fp = tt.icon.placedSymbolArray.length - 1, Bn && (Om = 4 * Bn.length, tt.addSymbols(tt.icon, Bn, is, Oi, Qi, di, T.ao.vertical, $t, gl.lineStartIndex, gl.lineLength, -1, Ln), mp = tt.icon.placedSymbolArray.length - 1);
              }
              const $m = Object.keys(Ui.horizontal);
              for (const Sr of $m) {
                const mn = Ui.horizontal[Sr];
                if (!na) {
                  Nm = ho(mn.text);
                  const Bn = sr.layout.get("text-rotate").evaluate(di, {}, Ln);
                  na = new mh(_i, $t, Ki, or, ar, mn, kr, fn, Yi, Bn);
                }
                const sa = mn.positionedLines.length === 1;
                if (jm += zm(tt, $t, mn, pn, sr, Yi, di, Vr, gl, Ui.vertical ? T.ao.horizontal : T.ao.horizontalOnly, sa ? $m : [Sr], Rs, fp, Dn, Ln), sa) break;
              }
              Ui.vertical && (Vm += zm(tt, $t, Ui.vertical, pn, sr, Yi, di, Vr, gl, T.ao.vertical, ["vertical"], Rs, mp, Dn, Ln));
              const zv = na ? na.boxStartIndex : tt.collisionBoxArray.length, Rv = na ? na.boxEndIndex : tt.collisionBoxArray.length, Dv = yl ? yl.boxStartIndex : tt.collisionBoxArray.length, Lv = yl ? yl.boxEndIndex : tt.collisionBoxArray.length, Fv = _l ? _l.boxStartIndex : tt.collisionBoxArray.length, Bv = _l ? _l.boxEndIndex : tt.collisionBoxArray.length, Ov = vl ? vl.boxStartIndex : tt.collisionBoxArray.length, jv = vl ? vl.boxEndIndex : tt.collisionBoxArray.length;
              let Fn = -1;
              const _h = (Sr, mn) => Sr && Sr.circleDiameter ? Math.max(Sr.circleDiameter, mn) : mn;
              Fn = _h(na, Fn), Fn = _h(yl, Fn), Fn = _h(_l, Fn), Fn = _h(vl, Fn);
              const Um = Fn > -1 ? 1 : 0;
              Um && (Fn *= kv / Xi), tt.glyphOffsetArray.length >= dl.MAX_GLYPHS && Se("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), di.sortKey !== void 0 && tt.addToSortKeyRanges(tt.symbolInstances.length, di.sortKey);
              const Vv = km(sr, di, Ln), [Nv, $v] = function(Sr, mn) {
                const sa = Sr.length, Bn = mn == null ? void 0 : mn.values;
                if ((Bn == null ? void 0 : Bn.length) > 0) for (let oa = 0; oa < Bn.length; oa += 2) {
                  const is = Bn[oa + 1];
                  Sr.emplaceBack(T.aE[Bn[oa]], is[0], is[1]);
                }
                return [sa, Sr.length];
              }(tt.textAnchorOffsets, Vv);
              tt.symbolInstances.emplaceBack($t.x, $t.y, Rs.right >= 0 ? Rs.right : -1, Rs.center >= 0 ? Rs.center : -1, Rs.left >= 0 ? Rs.left : -1, Rs.vertical || -1, fp, mp, Nm, zv, Rv, Dv, Lv, Fv, Bv, Ov, jv, Ki, jm, Vm, Bm, Om, Um, 0, kr, Fn, Nv, $v);
            }(r, lt, xt, i, s, l, Ne, r.layers[0], r.collisionBoxArray, t.index, t.sourceLayerIndex, r.index, H, [ye, ye, ye, ye], $e, y, ee, Te, Be, F, t, p, w, P, f);
          };
          if (Ve === "line") for (const xt of wm(t.geometry, 0, 0, Zt, Zt)) {
            const lt = ia(xt, Me), tt = Sv(lt, re, Ee, i.vertical || V, s, 24, he, r.overscaling, Zt);
            for (const $t of tt) V && Ev(r, V.text, st, $t) || mt(lt, $t);
          }
          else if (Ve === "line-center") {
            for (const xt of t.geometry) if (xt.length > 1) {
              const lt = ia(xt, Me), tt = Tv(lt, Ee, i.vertical || V, s, 24, he);
              tt && mt(lt, tt);
            }
          } else if (t.type === "Polygon") for (const xt of jo(t.geometry, 0)) {
            const lt = Mv(xt, 16);
            mt(ia(xt[0], Me, !0), new _o(lt.x, lt.y, 0));
          }
          else if (t.type === "LineString") for (const xt of t.geometry) {
            const lt = ia(xt, Me);
            mt(lt, new _o(lt[0].x, lt[0].y, 0));
          }
          else if (t.type === "Point") for (const xt of t.geometry) for (const lt of xt) mt([lt], new _o(lt.x, lt.y, 0));
        }
        function zm(r, t, i, s, l, p, f, _, y, w, P, I, z, L, F) {
          const V = function(he, ee, re, ye, Te, Ee, $e, Be) {
            const Ve = ye.layout.get("text-rotate").evaluate(Ee, {}) * Math.PI / 180, st = [];
            for (const je of ee.positionedLines) for (const Ne of je.positionedGlyphs) {
              if (!Ne.rect) continue;
              const Me = Ne.rect || {};
              let mt = 4, xt = !0, lt = 1, tt = 0;
              const $t = (Te || Be) && Ne.vertical, wi = Ne.metrics.advance * Ne.scale / 2;
              if (Be && ee.verticalizable && (tt = je.lineOffset / 2 - (Ne.imageName ? -(Xi - Ne.metrics.width * Ne.scale) / 2 : (Ne.scale - 1) * Xi)), Ne.imageName) {
                const Ji = $e[Ne.imageName];
                xt = Ji.sdf, lt = Ji.pixelRatio, mt = 1 / lt;
              }
              const Ui = Te ? [Ne.x + wi, Ne.y] : [0, 0];
              let mr = Te ? [0, 0] : [Ne.x + wi + re[0], Ne.y + re[1] - tt], pn = [0, 0];
              $t && (pn = mr, mr = [0, 0]);
              const jr = Ne.metrics.isDoubleResolution ? 2 : 1, sr = (Ne.metrics.left - mt) * Ne.scale - wi + mr[0], _i = (-Ne.metrics.top - mt) * Ne.scale + mr[1], Ki = sr + Me.w / jr * Ne.scale / lt, or = _i + Me.h / jr * Ne.scale / lt, ar = new U(sr, _i), kr = new U(Ki, _i), fn = new U(sr, or), Yi = new U(Ki, or);
              if ($t) {
                const Ji = new U(-wi, wi - -17), Qi = -Math.PI / 2, Oi = 12 - wi, di = new U(22 - Oi, -(Ne.imageName ? Oi : 0)), Dn = new U(...pn);
                ar._rotateAround(Qi, Ji)._add(di)._add(Dn), kr._rotateAround(Qi, Ji)._add(di)._add(Dn), fn._rotateAround(Qi, Ji)._add(di)._add(Dn), Yi._rotateAround(Qi, Ji)._add(di)._add(Dn);
              }
              if (Ve) {
                const Ji = Math.sin(Ve), Qi = Math.cos(Ve), Oi = [Qi, -Ji, Ji, Qi];
                ar._matMult(Oi), kr._matMult(Oi), fn._matMult(Oi), Yi._matMult(Oi);
              }
              const Vr = new U(0, 0), Zi = new U(0, 0);
              st.push({ tl: ar, tr: kr, bl: fn, br: Yi, tex: Me, writingMode: ee.writingMode, glyphOffset: Ui, sectionIndex: Ne.sectionIndex, isSDF: xt, pixelOffsetTL: Vr, pixelOffsetBR: Zi, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return st;
          }(0, i, _, l, p, f, s, r.allowVerticalPlacement), $ = r.textSizeData;
          let H = null;
          $.kind === "source" ? (H = [zs * l.layout.get("text-size").evaluate(f, {})], H[0] > mo && Se(`${r.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : $.kind === "composite" && (H = [zs * L.compositeTextSizes[0].evaluate(f, {}, F), zs * L.compositeTextSizes[1].evaluate(f, {}, F)], (H[0] > mo || H[1] > mo) && Se(`${r.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), r.addSymbols(r.text, V, H, _, p, f, w, t, y.lineStartIndex, y.lineLength, z, F);
          for (const he of P) I[he] = r.text.placedSymbolArray.length - 1;
          return 4 * V.length;
        }
        function Rm(r) {
          for (const t in r) return r[t];
          return null;
        }
        function Ev(r, t, i, s) {
          const l = r.compareText;
          if (t in l) {
            const p = l[t];
            for (let f = p.length - 1; f >= 0; f--) if (s.dist(p[f]) < i) return !0;
          } else l[t] = [];
          return l[t].push(s), !1;
        }
        const Dm = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class ap {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [i, s] = new Uint8Array(t, 0, 2);
            if (i !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const l = s >> 4;
            if (l !== 1) throw new Error(`Got v${l} data when expected v1.`);
            const p = Dm[15 & s];
            if (!p) throw new Error("Unrecognized array type.");
            const [f] = new Uint16Array(t, 2, 1), [_] = new Uint32Array(t, 4, 1);
            return new ap(_, f, p, t);
          }
          constructor(t, i = 64, s = Float64Array, l) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+i, 2), 65535), this.ArrayType = s, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const p = Dm.indexOf(this.ArrayType), f = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, _ = t * this.IndexArrayType.BYTES_PER_ELEMENT, y = (8 - _ % 8) % 8;
            if (p < 0) throw new Error(`Unexpected typed array class: ${s}.`);
            l && l instanceof ArrayBuffer ? (this.data = l, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + _ + y, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + f + _ + y), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + _ + y, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + p]), new Uint16Array(this.data, 2, 1)[0] = i, new Uint32Array(this.data, 4, 1)[0] = t);
          }
          add(t, i) {
            const s = this._pos >> 1;
            return this.ids[s] = s, this.coords[this._pos++] = t, this.coords[this._pos++] = i, s;
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return lp(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(t, i, s, l) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: p, coords: f, nodeSize: _ } = this, y = [0, p.length - 1, 0], w = [];
            for (; y.length; ) {
              const P = y.pop() || 0, I = y.pop() || 0, z = y.pop() || 0;
              if (I - z <= _) {
                for (let $ = z; $ <= I; $++) {
                  const H = f[2 * $], he = f[2 * $ + 1];
                  H >= t && H <= s && he >= i && he <= l && w.push(p[$]);
                }
                continue;
              }
              const L = z + I >> 1, F = f[2 * L], V = f[2 * L + 1];
              F >= t && F <= s && V >= i && V <= l && w.push(p[L]), (P === 0 ? t <= F : i <= V) && (y.push(z), y.push(L - 1), y.push(1 - P)), (P === 0 ? s >= F : l >= V) && (y.push(L + 1), y.push(I), y.push(1 - P));
            }
            return w;
          }
          within(t, i, s) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: l, coords: p, nodeSize: f } = this, _ = [0, l.length - 1, 0], y = [], w = s * s;
            for (; _.length; ) {
              const P = _.pop() || 0, I = _.pop() || 0, z = _.pop() || 0;
              if (I - z <= f) {
                for (let $ = z; $ <= I; $++) Fm(p[2 * $], p[2 * $ + 1], t, i) <= w && y.push(l[$]);
                continue;
              }
              const L = z + I >> 1, F = p[2 * L], V = p[2 * L + 1];
              Fm(F, V, t, i) <= w && y.push(l[L]), (P === 0 ? t - s <= F : i - s <= V) && (_.push(z), _.push(L - 1), _.push(1 - P)), (P === 0 ? t + s >= F : i + s >= V) && (_.push(L + 1), _.push(I), _.push(1 - P));
            }
            return y;
          }
        }
        function lp(r, t, i, s, l, p) {
          if (l - s <= i) return;
          const f = s + l >> 1;
          Lm(r, t, f, s, l, p), lp(r, t, i, s, f - 1, 1 - p), lp(r, t, i, f + 1, l, 1 - p);
        }
        function Lm(r, t, i, s, l, p) {
          for (; l > s; ) {
            if (l - s > 600) {
              const w = l - s + 1, P = i - s + 1, I = Math.log(w), z = 0.5 * Math.exp(2 * I / 3), L = 0.5 * Math.sqrt(I * z * (w - z) / w) * (P - w / 2 < 0 ? -1 : 1);
              Lm(r, t, i, Math.max(s, Math.floor(i - P * z / w + L)), Math.min(l, Math.floor(i + (w - P) * z / w + L)), p);
            }
            const f = t[2 * i + p];
            let _ = s, y = l;
            for (Nc(r, t, s, i), t[2 * l + p] > f && Nc(r, t, s, l); _ < y; ) {
              for (Nc(r, t, _, y), _++, y--; t[2 * _ + p] < f; ) _++;
              for (; t[2 * y + p] > f; ) y--;
            }
            t[2 * s + p] === f ? Nc(r, t, s, y) : (y++, Nc(r, t, y, l)), y <= i && (s = y + 1), i <= y && (l = y - 1);
          }
        }
        function Nc(r, t, i, s) {
          cp(r, i, s), cp(t, 2 * i, 2 * s), cp(t, 2 * i + 1, 2 * s + 1);
        }
        function cp(r, t, i) {
          const s = r[t];
          r[t] = r[i], r[i] = s;
        }
        function Fm(r, t, i, s) {
          const l = r - i, p = t - s;
          return l * l + p * p;
        }
        var up;
        T.cx = void 0, (up = T.cx || (T.cx = {})).create = "create", up.load = "load", up.fullLoad = "fullLoad";
        let gh = null, $c = [];
        const hp = 1e3 / 60, dp = "loadTime", pp = "fullLoadTime", Av = { mark(r) {
          performance.mark(r);
        }, frame(r) {
          const t = r;
          gh != null && $c.push(t - gh), gh = t;
        }, clearMetrics() {
          gh = null, $c = [], performance.clearMeasures(dp), performance.clearMeasures(pp);
          for (const r in T.cx) performance.clearMarks(T.cx[r]);
        }, getPerformanceMetrics() {
          performance.measure(dp, T.cx.create, T.cx.load), performance.measure(pp, T.cx.create, T.cx.fullLoad);
          const r = performance.getEntriesByName(dp)[0].duration, t = performance.getEntriesByName(pp)[0].duration, i = $c.length, s = 1 / ($c.reduce((p, f) => p + f, 0) / i / 1e3), l = $c.filter((p) => p > hp).reduce((p, f) => p + (f - hp) / hp, 0);
          return { loadTime: r, fullLoadTime: t, fps: s, percentDroppedFrames: l / (i + l) * 100, totalFrames: i };
        } };
        T.$ = Zt, T.A = ut, T.B = function([r, t, i]) {
          return t += 90, t *= Math.PI / 180, i *= Math.PI / 180, { x: r * Math.cos(t) * Math.sin(i), y: r * Math.sin(t) * Math.sin(i), z: r * Math.cos(i) };
        }, T.C = Tn, T.D = nt, T.E = rt, T.F = ai, T.G = Xo, T.H = function(r) {
          if (Re == null) {
            const t = r.navigator ? r.navigator.userAgent : null;
            Re = !!r.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
          }
          return Re;
        }, T.I = Wd, T.J = class {
          constructor(r, t) {
            this.target = r, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new xv(() => this.process()), this.subscription = Ye(this.target, "message", (i) => this.receive(i), !1), this.globalScope = Ae(self) ? r : window;
          }
          registerMessageHandler(r, t) {
            this.messageHandlers[r] = t;
          }
          sendAsync(r, t) {
            return new Promise((i, s) => {
              const l = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), p = t ? Ye(t.signal, "abort", () => {
                p == null || p.unsubscribe(), delete this.resolveRejects[l];
                const y = { id: l, type: "<cancel>", origin: location.origin, targetMapId: r.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(y);
              }, bv) : null;
              this.resolveRejects[l] = { resolve: (y) => {
                p == null || p.unsubscribe(), i(y);
              }, reject: (y) => {
                p == null || p.unsubscribe(), s(y);
              } };
              const f = [], _ = Object.assign(Object.assign({}, r), { id: l, sourceMapId: this.mapId, origin: location.origin, data: so(r.data, f) });
              this.target.postMessage(_, { transfer: f });
            });
          }
          receive(r) {
            const t = r.data, i = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[i];
                const s = this.abortControllers[i];
                return delete this.abortControllers[i], void (s && s.abort());
              }
              if (Ae(self) || t.mustQueue) return this.tasks[i] = t, this.taskQueue.push(i), void this.invoker.trigger();
              this.processTask(i, t);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const r = this.taskQueue.shift(), t = this.tasks[r];
            delete this.tasks[r], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(r, t);
          }
          processTask(r, t) {
            return a(this, void 0, void 0, function* () {
              if (t.type === "<response>") {
                const l = this.resolveRejects[r];
                return delete this.resolveRejects[r], l ? void (t.error ? l.reject(Cs(t.error)) : l.resolve(Cs(t.data))) : void 0;
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(r, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const i = Cs(t.data), s = new AbortController();
              this.abortControllers[r] = s;
              try {
                const l = yield this.messageHandlers[t.type](t.sourceMapId, i, s);
                this.completeTask(r, null, l);
              } catch (l) {
                this.completeTask(r, l);
              }
            });
          }
          completeTask(r, t, i) {
            const s = [];
            delete this.abortControllers[r];
            const l = { id: r, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? so(t) : null, data: so(i, s) };
            this.target.postMessage(l, { transfer: s });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, T.K = N, T.L = function() {
          var r = new ut(16);
          return ut != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;
        }, T.M = function(r, t, i) {
          var s, l, p, f, _, y, w, P, I, z, L, F, V = i[0], $ = i[1], H = i[2];
          return t === r ? (r[12] = t[0] * V + t[4] * $ + t[8] * H + t[12], r[13] = t[1] * V + t[5] * $ + t[9] * H + t[13], r[14] = t[2] * V + t[6] * $ + t[10] * H + t[14], r[15] = t[3] * V + t[7] * $ + t[11] * H + t[15]) : (l = t[1], p = t[2], f = t[3], _ = t[4], y = t[5], w = t[6], P = t[7], I = t[8], z = t[9], L = t[10], F = t[11], r[0] = s = t[0], r[1] = l, r[2] = p, r[3] = f, r[4] = _, r[5] = y, r[6] = w, r[7] = P, r[8] = I, r[9] = z, r[10] = L, r[11] = F, r[12] = s * V + _ * $ + I * H + t[12], r[13] = l * V + y * $ + z * H + t[13], r[14] = p * V + w * $ + L * H + t[14], r[15] = f * V + P * $ + F * H + t[15]), r;
        }, T.N = function(r, t, i) {
          var s = i[0], l = i[1], p = i[2];
          return r[0] = t[0] * s, r[1] = t[1] * s, r[2] = t[2] * s, r[3] = t[3] * s, r[4] = t[4] * l, r[5] = t[5] * l, r[6] = t[6] * l, r[7] = t[7] * l, r[8] = t[8] * p, r[9] = t[9] * p, r[10] = t[10] * p, r[11] = t[11] * p, r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15], r;
        }, T.O = function(r, t, i) {
          var s = t[0], l = t[1], p = t[2], f = t[3], _ = t[4], y = t[5], w = t[6], P = t[7], I = t[8], z = t[9], L = t[10], F = t[11], V = t[12], $ = t[13], H = t[14], he = t[15], ee = i[0], re = i[1], ye = i[2], Te = i[3];
          return r[0] = ee * s + re * _ + ye * I + Te * V, r[1] = ee * l + re * y + ye * z + Te * $, r[2] = ee * p + re * w + ye * L + Te * H, r[3] = ee * f + re * P + ye * F + Te * he, r[4] = (ee = i[4]) * s + (re = i[5]) * _ + (ye = i[6]) * I + (Te = i[7]) * V, r[5] = ee * l + re * y + ye * z + Te * $, r[6] = ee * p + re * w + ye * L + Te * H, r[7] = ee * f + re * P + ye * F + Te * he, r[8] = (ee = i[8]) * s + (re = i[9]) * _ + (ye = i[10]) * I + (Te = i[11]) * V, r[9] = ee * l + re * y + ye * z + Te * $, r[10] = ee * p + re * w + ye * L + Te * H, r[11] = ee * f + re * P + ye * F + Te * he, r[12] = (ee = i[12]) * s + (re = i[13]) * _ + (ye = i[14]) * I + (Te = i[15]) * V, r[13] = ee * l + re * y + ye * z + Te * $, r[14] = ee * p + re * w + ye * L + Te * H, r[15] = ee * f + re * P + ye * F + Te * he, r;
        }, T.P = U, T.Q = function(r, t) {
          const i = {};
          for (let s = 0; s < t.length; s++) {
            const l = t[s];
            l in r && (i[l] = r[l]);
          }
          return i;
        }, T.R = Or, T.S = go, T.T = Bd, T.U = pm, T.V = dm, T.W = vt, T.X = Ze, T.Y = Ge, T.Z = dn, T._ = a, T.a = B, T.a$ = ir, T.a0 = function(r, t) {
          var i, s, l, p, f;
          if (!r) return t ?? {};
          if (!t) return r;
          let _ = Object.assign({}, r);
          if (t.removeAll && (_ = { removeAll: !0 }), t.remove) {
            const y = new Set(t.remove);
            _.add && (_.add = _.add.filter((P) => !y.has(P.id))), _.update && (_.update = _.update.filter((P) => !y.has(P.id)));
            const w = new Set(((i = r.add) !== null && i !== void 0 ? i : []).map((P) => P.id));
            t.remove = t.remove.filter((P) => !w.has(P));
          }
          if (t.remove) {
            const y = new Set(_.remove ? _.remove.concat(t.remove) : t.remove);
            _.remove = Array.from(y.values());
          }
          if (t.add) {
            const y = _.add ? _.add.concat(t.add) : t.add, w = new Map(y.map((P) => [P.id, P]));
            _.add = Array.from(w.values());
          }
          if (t.update) {
            const y = new Map((s = _.update) === null || s === void 0 ? void 0 : s.map((w) => [w.id, w]));
            for (const w of t.update) {
              const P = (l = y.get(w.id)) !== null && l !== void 0 ? l : { id: w.id };
              w.newGeometry && (P.newGeometry = w.newGeometry), w.addOrUpdateProperties && (P.addOrUpdateProperties = ((p = P.addOrUpdateProperties) !== null && p !== void 0 ? p : []).concat(w.addOrUpdateProperties)), w.removeProperties && (P.removeProperties = ((f = P.removeProperties) !== null && f !== void 0 ? f : []).concat(w.removeProperties)), w.removeAllProperties && (P.removeAllProperties = !0), y.set(w.id, P);
            }
            _.update = Array.from(y.values());
          }
          return _.remove && _.add && (_.remove = _.remove.filter((y) => _.add.findIndex((w) => w.id === y) === -1)), _;
        }, T.a1 = jc, T.a2 = ra, T.a3 = 25, T.a4 = np, T.a5 = (r) => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((i) => {
            t.onloadstart = () => {
              i(t);
            };
            for (const s of r) {
              const l = window.document.createElement("source");
              me(s) || (t.crossOrigin = "Anonymous"), l.src = s, t.appendChild(l);
            }
          });
        }, T.a6 = Fe, T.a7 = function() {
          return Mr++;
        }, T.a8 = A, T.a9 = dl, T.aA = function(r) {
          let t = 1 / 0, i = 1 / 0, s = -1 / 0, l = -1 / 0;
          for (const p of r) t = Math.min(t, p.x), i = Math.min(i, p.y), s = Math.max(s, p.x), l = Math.max(l, p.y);
          return [t, i, s, l];
        }, T.aB = Xi, T.aC = qr, T.aD = function(r, t, i, s, l = !1) {
          if (!i[0] && !i[1]) return [0, 0];
          const p = l ? s === "map" ? -r.bearingInRadians : 0 : s === "viewport" ? r.bearingInRadians : 0;
          if (p) {
            const f = Math.sin(p), _ = Math.cos(p);
            i = [i[0] * _ - i[1] * f, i[0] * f + i[1] * _];
          }
          return [l ? i[0] : qr(t, i[0], r.zoom), l ? i[1] : qr(t, i[1], r.zoom)];
        }, T.aF = Yd, T.aG = op, T.aH = Kd, T.aI = ap, T.aJ = Pi, T.aK = oh, T.aL = Y, T.aM = Pt, T.aN = ri, T.aO = Qr, T.aP = gt, T.aQ = mm, T.aR = Et, T.aS = _t, T.aT = function(r) {
          var t = new ut(3);
          return t[0] = r[0], t[1] = r[1], t[2] = r[2], t;
        }, T.aU = function(r, t, i) {
          return r[0] = t[0] - i[0], r[1] = t[1] - i[1], r[2] = t[2] - i[2], r;
        }, T.aV = function(r, t) {
          var i = t[0], s = t[1], l = t[2], p = i * i + s * s + l * l;
          return p > 0 && (p = 1 / Math.sqrt(p)), r[0] = t[0] * p, r[1] = t[1] * p, r[2] = t[2] * p, r;
        }, T.aW = Ut, T.aX = function(r, t) {
          return r[0] * t[0] + r[1] * t[1] + r[2] * t[2];
        }, T.aY = function(r, t, i) {
          return r[0] = t[0] * i[0], r[1] = t[1] * i[1], r[2] = t[2] * i[2], r[3] = t[3] * i[3], r;
        }, T.aZ = pt, T.a_ = function(r, t, i) {
          const s = t[0] * i[0] + t[1] * i[1] + t[2] * i[2];
          return s === 0 ? null : (-(r[0] * i[0] + r[1] * i[1] + r[2] * i[2]) - i[3]) / s;
        }, T.aa = Ss, T.ab = Rn, T.ac = vm, T.ad = function(r) {
          const t = {};
          if (r.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (i, s, l, p) => {
            const f = l || p;
            return t[s] = !f || f.toLowerCase(), "";
          }), t["max-age"]) {
            const i = parseInt(t["max-age"], 10);
            isNaN(i) ? delete t["max-age"] : t["max-age"] = i;
          }
          return t;
        }, T.ae = ct, T.af = function(r) {
          return Math.pow(2, r);
        }, T.ag = It, T.ah = zi, T.ai = 85.051129, T.aj = fm, T.ak = function(r) {
          return Math.log(r) / Math.LN2;
        }, T.al = function(r) {
          var t = r[0], i = r[1];
          return t * t + i * i;
        }, T.am = function(r, t) {
          const i = [];
          for (const s in r) s in t || i.push(s);
          return i;
        }, T.an = function(r, t) {
          let i = 0, s = 0;
          if (r.kind === "constant") s = r.layoutSize;
          else if (r.kind !== "source") {
            const { interpolationType: l, minZoom: p, maxZoom: f } = r, _ = l ? zi(nr.interpolationFactor(l, t, p, f), 0, 1) : 0;
            r.kind === "camera" ? s = Tn.number(r.minSize, r.maxSize, _) : i = _;
          }
          return { uSizeT: i, uSize: s };
        }, T.ap = function(r, { uSize: t, uSizeT: i }, { lowerSize: s, upperSize: l }) {
          return r.kind === "source" ? s / zs : r.kind === "composite" ? Tn.number(s / zs, l / zs, i) : t;
        }, T.aq = function(r, t) {
          var i = t[0], s = t[1], l = t[2], p = t[3], f = t[4], _ = t[5], y = t[6], w = t[7], P = t[8], I = t[9], z = t[10], L = t[11], F = t[12], V = t[13], $ = t[14], H = t[15], he = i * _ - s * f, ee = i * y - l * f, re = i * w - p * f, ye = s * y - l * _, Te = s * w - p * _, Ee = l * w - p * y, $e = P * V - I * F, Be = P * $ - z * F, Ve = P * H - L * F, st = I * $ - z * V, je = I * H - L * V, Ne = z * H - L * $, Me = he * Ne - ee * je + re * st + ye * Ve - Te * Be + Ee * $e;
          return Me ? (r[0] = (_ * Ne - y * je + w * st) * (Me = 1 / Me), r[1] = (l * je - s * Ne - p * st) * Me, r[2] = (V * Ee - $ * Te + H * ye) * Me, r[3] = (z * Te - I * Ee - L * ye) * Me, r[4] = (y * Ve - f * Ne - w * Be) * Me, r[5] = (i * Ne - l * Ve + p * Be) * Me, r[6] = ($ * re - F * Ee - H * ee) * Me, r[7] = (P * Ee - z * re + L * ee) * Me, r[8] = (f * je - _ * Ve + w * $e) * Me, r[9] = (s * Ve - i * je - p * $e) * Me, r[10] = (F * Te - V * re + H * he) * Me, r[11] = (I * re - P * Te - L * he) * Me, r[12] = (_ * Be - f * st - y * $e) * Me, r[13] = (i * st - s * Be + l * $e) * Me, r[14] = (V * ee - F * ye - $ * he) * Me, r[15] = (P * ye - I * ee + z * he) * Me, r) : null;
        }, T.ar = At, T.as = function(r) {
          var t = r[0], i = r[1];
          return Math.sqrt(t * t + i * i);
        }, T.at = function(r) {
          return r[0] = 0, r[1] = 0, r;
        }, T.au = function(r, t, i) {
          return r[0] = t[0] * i, r[1] = t[1] * i, r;
        }, T.av = Jd, T.aw = Jr, T.ax = function(r, t, i, s) {
          const l = t.y - r.y, p = t.x - r.x, f = s.y - i.y, _ = s.x - i.x, y = f * p - _ * l;
          if (y === 0) return null;
          const w = (_ * (r.y - i.y) - f * (r.x - i.x)) / y;
          return new U(r.x + w * p, r.y + w * l);
        }, T.ay = wm, T.az = hf, T.b = He, T.b$ = class extends h {
        }, T.b0 = function(r, t, i) {
          return r[0] = t[0] * i, r[1] = t[1] * i, r[2] = t[2] * i, r[3] = t[3] * i, r;
        }, T.b1 = function(r, t) {
          return r[0] * t[0] + r[1] * t[1] + r[2] * t[2] + r[3];
        }, T.b2 = _m, T.b3 = pl, T.b4 = function(r, t, i, s, l) {
          var p = 1 / Math.tan(t / 2);
          if (r[0] = p / i, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = p, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, l != null && l !== 1 / 0) {
            var f = 1 / (s - l);
            r[10] = (l + s) * f, r[14] = 2 * l * s * f;
          } else r[10] = -1, r[14] = -2 * s;
          return r;
        }, T.b5 = function(r) {
          var t = new ut(16);
          return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], t;
        }, T.b6 = function(r, t, i) {
          var s = Math.sin(i), l = Math.cos(i), p = t[0], f = t[1], _ = t[2], y = t[3], w = t[4], P = t[5], I = t[6], z = t[7];
          return t !== r && (r[8] = t[8], r[9] = t[9], r[10] = t[10], r[11] = t[11], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15]), r[0] = p * l + w * s, r[1] = f * l + P * s, r[2] = _ * l + I * s, r[3] = y * l + z * s, r[4] = w * l - p * s, r[5] = P * l - f * s, r[6] = I * l - _ * s, r[7] = z * l - y * s, r;
        }, T.b7 = function(r, t, i) {
          var s = Math.sin(i), l = Math.cos(i), p = t[4], f = t[5], _ = t[6], y = t[7], w = t[8], P = t[9], I = t[10], z = t[11];
          return t !== r && (r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15]), r[4] = p * l + w * s, r[5] = f * l + P * s, r[6] = _ * l + I * s, r[7] = y * l + z * s, r[8] = w * l - p * s, r[9] = P * l - f * s, r[10] = I * l - _ * s, r[11] = z * l - y * s, r;
        }, T.b8 = function() {
          const r = new Float32Array(16);
          return It(r), r;
        }, T.b9 = function() {
          const r = new Float64Array(16);
          return It(r), r;
        }, T.bA = function(r, t) {
          const i = mi(r, 360), s = mi(t, 360), l = s - i, p = s > i ? l - 360 : l + 360;
          return Math.abs(l) < Math.abs(p) ? l : p;
        }, T.bB = function(r) {
          return r[0] = 0, r[1] = 0, r[2] = 0, r;
        }, T.bC = function(r, t, i, s) {
          const l = Math.sqrt(r * r + t * t), p = Math.sqrt(i * i + s * s);
          r /= l, t /= l, i /= p, s /= p;
          const f = Math.acos(r * i + t * s);
          return -t * i + r * s > 0 ? f : -f;
        }, T.bD = function(r, t) {
          const i = mi(r, 2 * Math.PI), s = mi(t, 2 * Math.PI);
          return Math.min(Math.abs(i - s), Math.abs(i - s + 2 * Math.PI), Math.abs(i - s - 2 * Math.PI));
        }, T.bE = function() {
          const r = {}, t = fe.$version;
          for (const i in fe.$root) {
            const s = fe.$root[i];
            if (s.required) {
              let l = null;
              l = i === "version" ? t : s.type === "array" ? [] : {}, l != null && (r[i] = l);
            }
          }
          return r;
        }, T.bF = Wa, T.bG = ie, T.bH = function r(t, i) {
          if (Array.isArray(t)) {
            if (!Array.isArray(i) || t.length !== i.length) return !1;
            for (let s = 0; s < t.length; s++) if (!r(t[s], i[s])) return !1;
            return !0;
          }
          if (typeof t == "object" && t !== null && i !== null) {
            if (typeof i != "object" || Object.keys(t).length !== Object.keys(i).length) return !1;
            for (const s in t) if (!r(t[s], i[s])) return !1;
            return !0;
          }
          return t === i;
        }, T.bI = function(r) {
          r = r.slice();
          const t = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < r.length; i++) t[r[i].id] = r[i];
          for (let i = 0; i < r.length; i++) "ref" in r[i] && (r[i] = Dt(r[i], t[r[i].ref]));
          return r;
        }, T.bJ = function(r) {
          if (r.type === "custom") return new vv(r);
          switch (r.type) {
            case "background":
              return new gv(r);
            case "circle":
              return new ty(r);
            case "color-relief":
              return new ay(r);
            case "fill":
              return new wy(r);
            case "fill-extrusion":
              return new Ry(r);
            case "heatmap":
              return new ry(r);
            case "hillshade":
              return new sy(r);
            case "line":
              return new Vy(r);
            case "raster":
              return new yv(r);
            case "symbol":
              return new hh(r);
          }
        }, T.bK = ne, T.bL = function(r, t) {
          if (!r) return [{ command: "setStyle", args: [t] }];
          let i = [];
          try {
            if (!ot(r.version, t.version)) return [{ command: "setStyle", args: [t] }];
            ot(r.center, t.center) || i.push({ command: "setCenter", args: [t.center] }), ot(r.state, t.state) || i.push({ command: "setGlobalState", args: [t.state] }), ot(r.centerAltitude, t.centerAltitude) || i.push({ command: "setCenterAltitude", args: [t.centerAltitude] }), ot(r.zoom, t.zoom) || i.push({ command: "setZoom", args: [t.zoom] }), ot(r.bearing, t.bearing) || i.push({ command: "setBearing", args: [t.bearing] }), ot(r.pitch, t.pitch) || i.push({ command: "setPitch", args: [t.pitch] }), ot(r.roll, t.roll) || i.push({ command: "setRoll", args: [t.roll] }), ot(r.sprite, t.sprite) || i.push({ command: "setSprite", args: [t.sprite] }), ot(r.glyphs, t.glyphs) || i.push({ command: "setGlyphs", args: [t.glyphs] }), ot(r.transition, t.transition) || i.push({ command: "setTransition", args: [t.transition] }), ot(r.light, t.light) || i.push({ command: "setLight", args: [t.light] }), ot(r.terrain, t.terrain) || i.push({ command: "setTerrain", args: [t.terrain] }), ot(r.sky, t.sky) || i.push({ command: "setSky", args: [t.sky] }), ot(r.projection, t.projection) || i.push({ command: "setProjection", args: [t.projection] });
            const s = {}, l = [];
            (function(f, _, y, w) {
              let P;
              for (P in _ = _ || {}, f = f || {}) Object.prototype.hasOwnProperty.call(f, P) && (Object.prototype.hasOwnProperty.call(_, P) || ji(P, y, w));
              for (P in _) Object.prototype.hasOwnProperty.call(_, P) && (Object.prototype.hasOwnProperty.call(f, P) ? ot(f[P], _[P]) || (f[P].type === "geojson" && _[P].type === "geojson" && Ci(f, _, P) ? St(y, { command: "setGeoJSONSourceData", args: [P, _[P].data] }) : Vi(P, _, y, w)) : ui(P, _, y));
            })(r.sources, t.sources, l, s);
            const p = [];
            r.layers && r.layers.forEach((f) => {
              "source" in f && s[f.source] ? i.push({ command: "removeLayer", args: [f.id] }) : p.push(f);
            }), i = i.concat(l), function(f, _, y) {
              _ = _ || [];
              const w = (f = f || []).map(Gt), P = _.map(Gt), I = f.reduce(Ri, {}), z = _.reduce(Ri, {}), L = w.slice(), F = /* @__PURE__ */ Object.create(null);
              let V, $, H, he, ee;
              for (let re = 0, ye = 0; re < w.length; re++) V = w[re], Object.prototype.hasOwnProperty.call(z, V) ? ye++ : (St(y, { command: "removeLayer", args: [V] }), L.splice(L.indexOf(V, ye), 1));
              for (let re = 0, ye = 0; re < P.length; re++) V = P[P.length - 1 - re], L[L.length - 1 - re] !== V && (Object.prototype.hasOwnProperty.call(I, V) ? (St(y, { command: "removeLayer", args: [V] }), L.splice(L.lastIndexOf(V, L.length - ye), 1)) : ye++, he = L[L.length - re], St(y, { command: "addLayer", args: [z[V], he] }), L.splice(L.length - re, 0, V), F[V] = !0);
              for (let re = 0; re < P.length; re++) if (V = P[re], $ = I[V], H = z[V], !F[V] && !ot($, H)) if (ot($.source, H.source) && ot($["source-layer"], H["source-layer"]) && ot($.type, H.type)) {
                for (ee in Ot($.layout, H.layout, y, V, null, "setLayoutProperty"), Ot($.paint, H.paint, y, V, null, "setPaintProperty"), ot($.filter, H.filter) || St(y, { command: "setFilter", args: [V, H.filter] }), ot($.minzoom, H.minzoom) && ot($.maxzoom, H.maxzoom) || St(y, { command: "setLayerZoomRange", args: [V, H.minzoom, H.maxzoom] }), $) Object.prototype.hasOwnProperty.call($, ee) && ee !== "layout" && ee !== "paint" && ee !== "filter" && ee !== "metadata" && ee !== "minzoom" && ee !== "maxzoom" && (ee.indexOf("paint.") === 0 ? Ot($[ee], H[ee], y, V, ee.slice(6), "setPaintProperty") : ot($[ee], H[ee]) || St(y, { command: "setLayerProperty", args: [V, ee, H[ee]] }));
                for (ee in H) Object.prototype.hasOwnProperty.call(H, ee) && !Object.prototype.hasOwnProperty.call($, ee) && ee !== "layout" && ee !== "paint" && ee !== "filter" && ee !== "metadata" && ee !== "minzoom" && ee !== "maxzoom" && (ee.indexOf("paint.") === 0 ? Ot($[ee], H[ee], y, V, ee.slice(6), "setPaintProperty") : ot($[ee], H[ee]) || St(y, { command: "setLayerProperty", args: [V, ee, H[ee]] }));
              } else St(y, { command: "removeLayer", args: [V] }), he = L[L.lastIndexOf(V) + 1], St(y, { command: "addLayer", args: [H, he] });
            }(p, t.layers, i);
          } catch (s) {
            console.warn("Unable to compute style diff:", s), i = [{ command: "setStyle", args: [t] }];
          }
          return i;
        }, T.bM = function(r) {
          const t = [], i = r.id;
          return i === void 0 && t.push({ message: `layers.${i}: missing required property "id"` }), r.render === void 0 && t.push({ message: `layers.${i}: missing required method "render"` }), r.renderingMode && r.renderingMode !== "2d" && r.renderingMode !== "3d" && t.push({ message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"` }), t;
        }, T.bN = Hr, T.bO = hs, T.bP = class extends Tr {
          constructor(r, t) {
            super(r, t), this.current = 0;
          }
          set(r) {
            this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));
          }
        }, T.bQ = $i, T.bR = class extends Tr {
          constructor(r, t) {
            super(r, t), this.current = Yr;
          }
          set(r) {
            if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);
            for (let t = 1; t < 16; t++) if (r[t] !== this.current[t]) {
              this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);
              break;
            }
          }
        }, T.bS = Fi, T.bT = class extends Tr {
          constructor(r, t) {
            super(r, t), this.current = [0, 0, 0];
          }
          set(r) {
            r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2]));
          }
        }, T.bU = class extends Tr {
          constructor(r, t) {
            super(r, t), this.current = [0, 0];
          }
          set(r) {
            r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1]));
          }
        }, T.bV = Qe, T.bW = function(r, t) {
          var i = Math.sin(t), s = Math.cos(t);
          return r[0] = s, r[1] = i, r[2] = 0, r[3] = -i, r[4] = s, r[5] = 0, r[6] = 0, r[7] = 0, r[8] = 1, r;
        }, T.bX = function(r, t, i) {
          var s = t[0], l = t[1], p = t[2];
          return r[0] = s * i[0] + l * i[3] + p * i[6], r[1] = s * i[1] + l * i[4] + p * i[7], r[2] = s * i[2] + l * i[5] + p * i[8], r;
        }, T.bY = function(r, t, i, s, l, p, f) {
          var _ = 1 / (t - i), y = 1 / (s - l), w = 1 / (p - f);
          return r[0] = -2 * _, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * y, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * w, r[11] = 0, r[12] = (t + i) * _, r[13] = (l + s) * y, r[14] = (f + p) * w, r[15] = 1, r;
        }, T.bZ = class extends Tr {
          constructor(r, t) {
            super(r, t), this.current = new Array();
          }
          set(r) {
            if (r != this.current) {
              this.current = r;
              const t = new Float32Array(4 * r.length);
              for (let i = 0; i < r.length; i++) t[4 * i] = r[i].r, t[4 * i + 1] = r[i].g, t[4 * i + 2] = r[i].b, t[4 * i + 3] = r[i].a;
              this.gl.uniform4fv(this.location, t);
            }
          }
        }, T.b_ = class extends Tr {
          constructor(r, t) {
            super(r, t), this.current = new Array();
          }
          set(r) {
            if (r != this.current) {
              this.current = r;
              const t = new Float32Array(r);
              this.gl.uniform1fv(this.location, t);
            }
          }
        }, T.ba = function() {
          return new Float64Array(16);
        }, T.bb = function(r, t, i) {
          const s = new Float64Array(4);
          return ti(s, r, t - 90, i), s;
        }, T.bc = function(r, t, i, s) {
          var l, p, f, _, y, w = t[0], P = t[1], I = t[2], z = t[3], L = i[0], F = i[1], V = i[2], $ = i[3];
          return (p = w * L + P * F + I * V + z * $) < 0 && (p = -p, L = -L, F = -F, V = -V, $ = -$), 1 - p > Ke ? (l = Math.acos(p), f = Math.sin(l), _ = Math.sin((1 - s) * l) / f, y = Math.sin(s * l) / f) : (_ = 1 - s, y = s), r[0] = _ * w + y * L, r[1] = _ * P + y * F, r[2] = _ * I + y * V, r[3] = _ * z + y * $, r;
        }, T.bd = function(r) {
          const t = new Float64Array(9);
          var i, s, l, p, f, _, y, w, P, I, z, L, F, V, $, H, he, ee;
          I = (l = (s = r)[0]) * (y = l + l), z = (p = s[1]) * y, F = (f = s[2]) * y, V = f * (w = p + p), H = (_ = s[3]) * y, he = _ * w, ee = _ * (P = f + f), (i = t)[0] = 1 - (L = p * w) - ($ = f * P), i[3] = z - ee, i[6] = F + he, i[1] = z + ee, i[4] = 1 - I - $, i[7] = V - H, i[2] = F - he, i[5] = V + H, i[8] = 1 - I - L;
          const re = gt(-Math.asin(zi(t[2], -1, 1)));
          let ye, Te;
          return Math.hypot(t[5], t[8]) < 1e-3 ? (ye = 0, Te = -gt(Math.atan2(t[3], t[4]))) : (ye = gt(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), Te = gt(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), { roll: ye, pitch: re + 90, bearing: Te };
        }, T.be = function(r, t) {
          return r.roll == t.roll && r.pitch == t.pitch && r.bearing == t.bearing;
        }, T.bf = Bt, T.bg = Qn, T.bh = ll, T.bi = Rc, T.bj = al, T.bk = Gi, T.bl = Dr, T.bm = dr, T.bn = function(r, t, i, s, l) {
          return Gi(s, l, zi((r - t) / (i - t), 0, 1));
        }, T.bo = mi, T.bp = function() {
          return new Float64Array(3);
        }, T.bq = function(r, t, i, s) {
          return r[0] = t[0] + i[0] * s, r[1] = t[1] + i[1] * s, r[2] = t[2] + i[2] * s, r;
        }, T.br = ti, T.bs = function(r, t, i) {
          var s = i[0], l = i[1], p = i[2], f = i[3], _ = t[0], y = t[1], w = t[2], P = l * w - p * y, I = p * _ - s * w, z = s * y - l * _;
          return r[0] = _ + f * (P += P) + l * (z += z) - p * (I += I), r[1] = y + f * I + p * P - s * z, r[2] = w + f * z + s * I - l * P, r;
        }, T.bt = function(r, t, i) {
          const s = (l = [r[0], r[1], r[2], t[0], t[1], t[2], i[0], i[1], i[2]])[0] * ((P = l[8]) * (f = l[4]) - (_ = l[5]) * (w = l[7])) + l[1] * (-P * (p = l[3]) + _ * (y = l[6])) + l[2] * (w * p - f * y);
          var l, p, f, _, y, w, P;
          if (s === 0) return null;
          const I = Ut([], [t[0], t[1], t[2]], [i[0], i[1], i[2]]), z = Ut([], [i[0], i[1], i[2]], [r[0], r[1], r[2]]), L = Ut([], [r[0], r[1], r[2]], [t[0], t[1], t[2]]), F = Et([], I, -r[3]);
          return _t(F, F, Et([], z, -t[3])), _t(F, F, Et([], L, -i[3])), Et(F, F, 1 / s), F;
        }, T.bu = ip, T.bv = function() {
          return new Float64Array(4);
        }, T.bw = function(r, t, i, s) {
          var l = [], p = [];
          return l[0] = t[0] - i[0], l[1] = t[1] - i[1], l[2] = t[2] - i[2], p[0] = l[0] * Math.cos(s) - l[1] * Math.sin(s), p[1] = l[0] * Math.sin(s) + l[1] * Math.cos(s), p[2] = l[2], r[0] = p[0] + i[0], r[1] = p[1] + i[1], r[2] = p[2] + i[2], r;
        }, T.bx = function(r, t, i, s) {
          var l = [], p = [];
          return l[0] = t[0] - i[0], l[1] = t[1] - i[1], l[2] = t[2] - i[2], p[0] = l[0], p[1] = l[1] * Math.cos(s) - l[2] * Math.sin(s), p[2] = l[1] * Math.sin(s) + l[2] * Math.cos(s), r[0] = p[0] + i[0], r[1] = p[1] + i[1], r[2] = p[2] + i[2], r;
        }, T.by = function(r, t, i, s) {
          var l = [], p = [];
          return l[0] = t[0] - i[0], l[1] = t[1] - i[1], l[2] = t[2] - i[2], p[0] = l[2] * Math.sin(s) + l[0] * Math.cos(s), p[1] = l[1], p[2] = l[2] * Math.cos(s) - l[0] * Math.sin(s), r[0] = p[0] + i[0], r[1] = p[1] + i[1], r[2] = p[2] + i[2], r;
        }, T.bz = function(r, t, i) {
          var s = Math.sin(i), l = Math.cos(i), p = t[0], f = t[1], _ = t[2], y = t[3], w = t[8], P = t[9], I = t[10], z = t[11];
          return t !== r && (r[4] = t[4], r[5] = t[5], r[6] = t[6], r[7] = t[7], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15]), r[0] = p * l - w * s, r[1] = f * l - P * s, r[2] = _ * l - I * s, r[3] = y * l - z * s, r[8] = p * s + w * l, r[9] = f * s + P * l, r[10] = _ * s + I * l, r[11] = y * s + z * l, r;
        }, T.c = oe, T.c0 = Zy, T.c1 = class extends n {
        }, T.c2 = Fd, T.c3 = function(r) {
          return r <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
        }, T.c4 = bf, T.c5 = function(r, t, i) {
          var s = t[0], l = t[1], p = t[2], f = i[3] * s + i[7] * l + i[11] * p + i[15];
          return r[0] = (i[0] * s + i[4] * l + i[8] * p + i[12]) / (f = f || 1), r[1] = (i[1] * s + i[5] * l + i[9] * p + i[13]) / f, r[2] = (i[2] * s + i[6] * l + i[10] * p + i[14]) / f, r;
        }, T.c6 = class extends wc {
        }, T.c7 = class extends M {
        }, T.c8 = function(r, t) {
          return r[0] === t[0] && r[1] === t[1] && r[2] === t[2] && r[3] === t[3] && r[4] === t[4] && r[5] === t[5] && r[6] === t[6] && r[7] === t[7] && r[8] === t[8] && r[9] === t[9] && r[10] === t[10] && r[11] === t[11] && r[12] === t[12] && r[13] === t[13] && r[14] === t[14] && r[15] === t[15];
        }, T.c9 = function(r, t) {
          var i = r[0], s = r[1], l = r[2], p = r[3], f = r[4], _ = r[5], y = r[6], w = r[7], P = r[8], I = r[9], z = r[10], L = r[11], F = r[12], V = r[13], $ = r[14], H = r[15], he = t[0], ee = t[1], re = t[2], ye = t[3], Te = t[4], Ee = t[5], $e = t[6], Be = t[7], Ve = t[8], st = t[9], je = t[10], Ne = t[11], Me = t[12], mt = t[13], xt = t[14], lt = t[15];
          return Math.abs(i - he) <= Ke * Math.max(1, Math.abs(i), Math.abs(he)) && Math.abs(s - ee) <= Ke * Math.max(1, Math.abs(s), Math.abs(ee)) && Math.abs(l - re) <= Ke * Math.max(1, Math.abs(l), Math.abs(re)) && Math.abs(p - ye) <= Ke * Math.max(1, Math.abs(p), Math.abs(ye)) && Math.abs(f - Te) <= Ke * Math.max(1, Math.abs(f), Math.abs(Te)) && Math.abs(_ - Ee) <= Ke * Math.max(1, Math.abs(_), Math.abs(Ee)) && Math.abs(y - $e) <= Ke * Math.max(1, Math.abs(y), Math.abs($e)) && Math.abs(w - Be) <= Ke * Math.max(1, Math.abs(w), Math.abs(Be)) && Math.abs(P - Ve) <= Ke * Math.max(1, Math.abs(P), Math.abs(Ve)) && Math.abs(I - st) <= Ke * Math.max(1, Math.abs(I), Math.abs(st)) && Math.abs(z - je) <= Ke * Math.max(1, Math.abs(z), Math.abs(je)) && Math.abs(L - Ne) <= Ke * Math.max(1, Math.abs(L), Math.abs(Ne)) && Math.abs(F - Me) <= Ke * Math.max(1, Math.abs(F), Math.abs(Me)) && Math.abs(V - mt) <= Ke * Math.max(1, Math.abs(V), Math.abs(mt)) && Math.abs($ - xt) <= Ke * Math.max(1, Math.abs($), Math.abs(xt)) && Math.abs(H - lt) <= Ke * Math.max(1, Math.abs(H), Math.abs(lt));
        }, T.cA = function(r, t) {
          B.REGISTERED_PROTOCOLS[r] = t;
        }, T.cB = function(r) {
          delete B.REGISTERED_PROTOCOLS[r];
        }, T.cC = function(r, t) {
          const i = {};
          for (let l = 0; l < r.length; l++) {
            const p = t && t[r[l].id] || Sd(r[l]);
            t && (t[r[l].id] = p);
            let f = i[p];
            f || (f = i[p] = []), f.push(r[l]);
          }
          const s = [];
          for (const l in i) s.push(i[l]);
          return s;
        }, T.cD = We, T.cE = ym, T.cF = xm, T.cG = Kf, T.cH = function(r) {
          r.bucket.createArrays(), r.bucket.tilePixelRatio = Zt / (512 * r.bucket.overscaling), r.bucket.compareText = {}, r.bucket.iconsNeedLinear = !1;
          const t = r.bucket.layers[0], i = t.layout, s = t._unevaluatedLayout._values, l = { layoutIconSize: s["icon-size"].possiblyEvaluate(new ai(r.bucket.zoom + 1), r.canonical), layoutTextSize: s["text-size"].possiblyEvaluate(new ai(r.bucket.zoom + 1), r.canonical), textMaxSize: s["text-size"].possiblyEvaluate(new ai(18)) };
          if (r.bucket.textSizeData.kind === "composite") {
            const { minZoom: w, maxZoom: P } = r.bucket.textSizeData;
            l.compositeTextSizes = [s["text-size"].possiblyEvaluate(new ai(w), r.canonical), s["text-size"].possiblyEvaluate(new ai(P), r.canonical)];
          }
          if (r.bucket.iconSizeData.kind === "composite") {
            const { minZoom: w, maxZoom: P } = r.bucket.iconSizeData;
            l.compositeIconSizes = [s["icon-size"].possiblyEvaluate(new ai(w), r.canonical), s["icon-size"].possiblyEvaluate(new ai(P), r.canonical)];
          }
          const p = i.get("text-line-height") * Xi, f = i.get("text-rotation-alignment") !== "viewport" && i.get("symbol-placement") !== "point", _ = i.get("text-keep-upright"), y = i.get("text-size");
          for (const w of r.bucket.features) {
            const P = i.get("text-font").evaluate(w, {}, r.canonical).join(","), I = y.evaluate(w, {}, r.canonical), z = l.layoutTextSize.evaluate(w, {}, r.canonical), L = l.layoutIconSize.evaluate(w, {}, r.canonical), F = { horizontal: {}, vertical: void 0 }, V = w.text;
            let $, H = [0, 0];
            if (V) {
              const re = V.toString(), ye = i.get("text-letter-spacing").evaluate(w, {}, r.canonical) * Xi, Te = Id(re) ? ye : 0, Ee = i.get("text-anchor").evaluate(w, {}, r.canonical), $e = km(t, w, r.canonical);
              if (!$e) {
                const je = i.get("text-radial-offset").evaluate(w, {}, r.canonical);
                H = je ? Am(Ee, [je * Xi, sp]) : i.get("text-offset").evaluate(w, {}, r.canonical).map((Ne) => Ne * Xi);
              }
              let Be = f ? "center" : i.get("text-justify").evaluate(w, {}, r.canonical);
              const Ve = i.get("symbol-placement") === "point" ? i.get("text-max-width").evaluate(w, {}, r.canonical) * Xi : 1 / 0, st = () => {
                r.bucket.allowVerticalPlacement && Xa(re) && (F.vertical = lh(V, r.glyphMap, r.glyphPositions, r.imagePositions, P, Ve, p, Ee, "left", Te, H, T.ao.vertical, !0, z, I));
              };
              if (!f && $e) {
                const je = /* @__PURE__ */ new Set();
                if (Be === "auto") for (let Me = 0; Me < $e.values.length; Me += 2) je.add(op($e.values[Me]));
                else je.add(Be);
                let Ne = !1;
                for (const Me of je) if (!F.horizontal[Me]) if (Ne) F.horizontal[Me] = F.horizontal[0];
                else {
                  const mt = lh(V, r.glyphMap, r.glyphPositions, r.imagePositions, P, Ve, p, "center", Me, Te, H, T.ao.horizontal, !1, z, I);
                  mt && (F.horizontal[Me] = mt, Ne = mt.positionedLines.length === 1);
                }
                st();
              } else {
                Be === "auto" && (Be = op(Ee));
                const je = lh(V, r.glyphMap, r.glyphPositions, r.imagePositions, P, Ve, p, Ee, Be, Te, H, T.ao.horizontal, !1, z, I);
                je && (F.horizontal[Be] = je), st(), Xa(re) && f && _ && (F.vertical = lh(V, r.glyphMap, r.glyphPositions, r.imagePositions, P, Ve, p, Ee, Be, Te, H, T.ao.vertical, !1, z, I));
              }
            }
            let he = !1;
            if (w.icon && w.icon.name) {
              const re = r.imageMap[w.icon.name];
              re && ($ = dv(r.imagePositions[w.icon.name], i.get("icon-offset").evaluate(w, {}, r.canonical), i.get("icon-anchor").evaluate(w, {}, r.canonical)), he = !!re.sdf, r.bucket.sdfIcons === void 0 ? r.bucket.sdfIcons = he : r.bucket.sdfIcons !== he && Se("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (re.pixelRatio !== r.bucket.pixelRatio || i.get("icon-rotate").constantOr(1) !== 0) && (r.bucket.iconsNeedLinear = !0));
            }
            const ee = Rm(F.horizontal) || F.vertical;
            r.bucket.iconsInText = !!ee && ee.iconsInText, (ee || $) && Iv(r.bucket, w, F, $, r.imageMap, l, z, L, H, he, r.canonical, r.subdivisionGranularity);
          }
          r.showCollisionBoxes && r.bucket.generateCollisionDebugBuffers();
        }, T.cI = Gd, T.cJ = $d, T.cK = Zd, T.cL = Ff, T.cM = Hd, T.cN = class {
          constructor(r) {
            this._marks = { start: [r.url, "start"].join("#"), end: [r.url, "end"].join("#"), measure: r.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let r = performance.getEntriesByName(this._marks.measure);
            return r.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), r = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), r;
          }
        }, T.cO = function(r, t, i, s, l) {
          return a(this, void 0, void 0, function* () {
            if (Ze()) try {
              return yield Ge(r, t, i, s, l);
            } catch {
            }
            return function(p, f, _, y, w) {
              const P = p.width, I = p.height;
              De && ht || (De = new OffscreenCanvas(P, I), ht = De.getContext("2d", { willReadFrequently: !0 })), De.width = P, De.height = I, ht.drawImage(p, 0, 0, P, I);
              const z = ht.getImageData(f, _, y, w);
              return ht.clearRect(0, 0, P, I), z.data;
            }(r, t, i, s, l);
          });
        }, T.cP = Sf, T.cQ = ue, T.cR = Lf, T.cS = cl, T.cT = Uo, T.cU = function(r, t) {
          const i = /* @__PURE__ */ new Map();
          if (r != null) if (r.type === "Feature") i.set(Vc(r, t), r);
          else for (const s of r.features) i.set(Vc(s, t), s);
          return i;
        }, T.cV = function(r, t) {
          if (r == null) return !0;
          if (r.type === "Feature") return Vc(r, t) != null;
          if (r.type === "FeatureCollection") {
            const i = /* @__PURE__ */ new Set();
            for (const s of r.features) {
              const l = Vc(s, t);
              if (l == null || i.has(l)) return !1;
              i.add(l);
            }
            return !0;
          }
          return !1;
        }, T.cW = function(r, t, i) {
          var s, l, p, f;
          if (t.removeAll && r.clear(), t.remove) for (const _ of t.remove) r.delete(_);
          if (t.add) for (const _ of t.add) {
            const y = Vc(_, i);
            y != null && r.set(y, _);
          }
          if (t.update) for (const _ of t.update) {
            let y = r.get(_.id);
            if (y == null) continue;
            const w = !_.removeAllProperties && (((s = _.removeProperties) === null || s === void 0 ? void 0 : s.length) > 0 || ((l = _.addOrUpdateProperties) === null || l === void 0 ? void 0 : l.length) > 0);
            if ((_.newGeometry || _.removeAllProperties || w) && (y = Object.assign({}, y), r.set(_.id, y), w && (y.properties = Object.assign({}, y.properties))), _.newGeometry && (y.geometry = _.newGeometry), _.removeAllProperties) y.properties = {};
            else if (((p = _.removeProperties) === null || p === void 0 ? void 0 : p.length) > 0) for (const P of _.removeProperties) Object.prototype.hasOwnProperty.call(y.properties, P) && delete y.properties[P];
            if (((f = _.addOrUpdateProperties) === null || f === void 0 ? void 0 : f.length) > 0) for (const { key: P, value: I } of _.addOrUpdateProperties) y.properties[P] = I;
          }
        }, T.cX = ln, T.ca = function(r, t) {
          return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4], r[5] = t[5], r[6] = t[6], r[7] = t[7], r[8] = t[8], r[9] = t[9], r[10] = t[10], r[11] = t[11], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15], r;
        }, T.cb = (r) => r.type === "symbol", T.cc = (r) => r.type === "circle", T.cd = (r) => r.type === "heatmap", T.ce = (r) => r.type === "line", T.cf = (r) => r.type === "fill", T.cg = (r) => r.type === "fill-extrusion", T.ch = (r) => r.type === "hillshade", T.ci = (r) => r.type === "color-relief", T.cj = (r) => r.type === "raster", T.ck = (r) => r.type === "background", T.cl = (r) => r.type === "custom", T.cm = vn, T.cn = function(r, t, i) {
          const s = Jt(t.x - i.x, t.y - i.y), l = Jt(r.x - i.x, r.y - i.y);
          var p, f;
          return gt(Math.atan2(s[0] * l[1] - s[1] * l[0], (p = s)[0] * (f = l)[0] + p[1] * f[1]));
        }, T.co = Cn, T.cp = function(r, t) {
          return Wt[t] && (r instanceof MouseEvent || r instanceof WheelEvent);
        }, T.cq = function(r, t) {
          return zt[t] && "touches" in r;
        }, T.cr = function(r) {
          return zt[r] || Wt[r];
        }, T.cs = function(r, t, i) {
          var s = t[0], l = t[1];
          return r[0] = i[0] * s + i[4] * l + i[12], r[1] = i[1] * s + i[5] * l + i[13], r;
        }, T.ct = function(r, t) {
          const { x: i, y: s } = jc.fromLngLat(t);
          return !(r < 0 || r > 25 || s < 0 || s >= 1 || i < 0 || i >= 1);
        }, T.cu = function(r, t) {
          return r[0] = t[0], r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = t[1], r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = t[2], r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
        }, T.cv = class extends lo {
        }, T.cw = Av, T.cy = function(r) {
          return r.message === Ht;
        }, T.cz = X, T.d = me, T.e = ur, T.f = (r) => a(void 0, void 0, void 0, function* () {
          if (r.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(r)], { type: "image/png" });
          try {
            return createImageBitmap(t);
          } catch (i) {
            throw new Error(`Could not load image because of ${i.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        }), T.g = j, T.h = (r) => new Promise((t, i) => {
          const s = new Image();
          s.onload = () => {
            t(s), URL.revokeObjectURL(s.src), s.onload = null, window.requestAnimationFrame(() => {
              s.src = Ue;
            });
          }, s.onerror = () => i(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const l = new Blob([new Uint8Array(r)], { type: "image/png" });
          s.src = r.byteLength ? URL.createObjectURL(l) : Ue;
        }), T.i = Ae, T.j = (r, t) => le(ur(r, { type: "json" }), t), T.k = Ce, T.l = ke, T.m = le, T.n = (r, t) => le(ur(r, { type: "arrayBuffer" }), t), T.o = function(r) {
          return new Hd(r).readFields(tv, []);
        }, T.p = Xf, T.q = Ic, T.r = br, T.s = Ye, T.t = Yu, T.u = Nt, T.v = fe, T.w = Se, T.x = Pd, T.y = Ko, T.z = no;
      }), E("worker", ["./shared"], function(T) {
        class a {
          constructor(B) {
            this.keyCache = {}, B && this.replace(B);
          }
          replace(B) {
            this._layerConfigs = {}, this._layers = {}, this.update(B, []);
          }
          update(B, j) {
            for (const X of B) {
              this._layerConfigs[X.id] = X;
              const ie = this._layers[X.id] = T.bJ(X);
              ie._featureFilter = T.aa(ie.filter), this.keyCache[X.id] && delete this.keyCache[X.id];
            }
            for (const X of j) delete this.keyCache[X], delete this._layerConfigs[X], delete this._layers[X];
            this.familiesBySource = {};
            const N = T.cC(Object.values(this._layerConfigs), this.keyCache);
            for (const X of N) {
              const ie = X.map((Ce) => this._layers[Ce.id]), le = ie[0];
              if (le.visibility === "none") continue;
              const me = le.source || "";
              let de = this.familiesBySource[me];
              de || (de = this.familiesBySource[me] = {});
              const Pe = le.sourceLayer || "_geojsonTileLayer";
              let ke = de[Pe];
              ke || (ke = de[Pe] = []), ke.push(ie);
            }
          }
        }
        class U {
          constructor(B) {
            const j = {}, N = [];
            for (const me in B) {
              const de = B[me], Pe = j[me] = {};
              for (const ke in de) {
                const Ce = de[+ke];
                if (!Ce || Ce.bitmap.width === 0 || Ce.bitmap.height === 0) continue;
                const rt = { x: 0, y: 0, w: Ce.bitmap.width + 2, h: Ce.bitmap.height + 2 };
                N.push(rt), Pe[ke] = { rect: rt, metrics: Ce.metrics };
              }
            }
            const { w: X, h: ie } = T.p(N), le = new T.q({ width: X || 1, height: ie || 1 });
            for (const me in B) {
              const de = B[me];
              for (const Pe in de) {
                const ke = de[+Pe];
                if (!ke || ke.bitmap.width === 0 || ke.bitmap.height === 0) continue;
                const Ce = j[me][Pe].rect;
                T.q.copy(ke.bitmap, le, { x: 0, y: 0 }, { x: Ce.x + 1, y: Ce.y + 1 }, ke.bitmap);
              }
            }
            this.image = le, this.positions = j;
          }
        }
        T.cD("GlyphAtlas", U);
        class ue {
          constructor(B) {
            this.tileID = new T.Z(B.tileID.overscaledZ, B.tileID.wrap, B.tileID.canonical.z, B.tileID.canonical.x, B.tileID.canonical.y), this.uid = B.uid, this.zoom = B.zoom, this.pixelRatio = B.pixelRatio, this.tileSize = B.tileSize, this.source = B.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = B.showCollisionBoxes, this.collectResourceTiming = !!B.collectResourceTiming, this.returnDependencies = !!B.returnDependencies, this.promoteId = B.promoteId, this.inFlightDependencies = [], this.globalState = B.globalState;
          }
          parse(B, j, N, X, ie) {
            return T._(this, void 0, void 0, function* () {
              this.status = "parsing", this.data = B, this.collisionBoxArray = new T.a8();
              const le = new T.cE(Object.keys(B.layers).sort()), me = new T.cF(this.tileID, this.promoteId);
              me.bucketLayerIDs = [];
              const de = {}, Pe = { featureIndex: me, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: N, subdivisionGranularity: ie }, ke = j.familiesBySource[this.source];
              for (const Ot in ke) {
                const Gt = B.layers[Ot];
                if (!Gt) continue;
                Gt.version === 1 && T.w(`Vector tile source "${this.source}" layer "${Ot}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Ri = le.encode(Ot), Fe = [];
                for (let hr = 0; hr < Gt.length; hr++) {
                  const vi = Gt.feature(hr), $n = me.getId(vi, Ot);
                  Fe.push({ feature: vi, id: $n, index: hr, sourceLayerIndex: Ri });
                }
                for (const hr of ke[Ot]) {
                  const vi = hr[0];
                  vi.source !== this.source && T.w(`layer.source = ${vi.source} does not equal this.source = ${this.source}`), vi.minzoom && this.zoom < Math.floor(vi.minzoom) || vi.maxzoom && this.zoom >= vi.maxzoom || vi.visibility !== "none" && (ce(hr, this.zoom, N, this.globalState), (de[vi.id] = vi.createBucket({ index: me.bucketLayerIDs.length, layers: hr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Ri, sourceID: this.source, globalState: this.globalState })).populate(Fe, Pe, this.tileID.canonical), me.bucketLayerIDs.push(hr.map(($n) => $n.id)));
                }
              }
              const Ce = T.bN(Pe.glyphDependencies, (Ot) => Object.keys(Ot).map(Number));
              this.inFlightDependencies.forEach((Ot) => Ot == null ? void 0 : Ot.abort()), this.inFlightDependencies = [];
              let rt = Promise.resolve({});
              if (Object.keys(Ce).length) {
                const Ot = new AbortController();
                this.inFlightDependencies.push(Ot), rt = X.sendAsync({ type: "GG", data: { stacks: Ce, source: this.source, tileID: this.tileID, type: "glyphs" } }, Ot);
              }
              const fe = Object.keys(Pe.iconDependencies);
              let bt = Promise.resolve({});
              if (fe.length) {
                const Ot = new AbortController();
                this.inFlightDependencies.push(Ot), bt = X.sendAsync({ type: "GI", data: { icons: fe, source: this.source, tileID: this.tileID, type: "icons" } }, Ot);
              }
              const Dt = Object.keys(Pe.patternDependencies);
              let ot = Promise.resolve({});
              if (Dt.length) {
                const Ot = new AbortController();
                this.inFlightDependencies.push(Ot), ot = X.sendAsync({ type: "GI", data: { icons: Dt, source: this.source, tileID: this.tileID, type: "patterns" } }, Ot);
              }
              const [St, ui, ji] = yield Promise.all([rt, bt, ot]), Vi = new U(St), Ci = new T.cG(ui, ji);
              for (const Ot in de) {
                const Gt = de[Ot];
                Gt instanceof T.a9 ? (ce(Gt.layers, this.zoom, N, this.globalState), T.cH({ bucket: Gt, glyphMap: St, glyphPositions: Vi.positions, imageMap: ui, imagePositions: Ci.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: Pe.subdivisionGranularity })) : Gt.hasPattern && (Gt instanceof T.cI || Gt instanceof T.cJ || Gt instanceof T.cK) && (ce(Gt.layers, this.zoom, N, this.globalState), Gt.addFeatures(Pe, this.tileID.canonical, Ci.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(de).filter((Ot) => !Ot.isEmpty()), featureIndex: me, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Vi.image, imageAtlas: Ci, glyphMap: this.returnDependencies ? St : null, iconMap: this.returnDependencies ? ui : null, glyphPositions: this.returnDependencies ? Vi.positions : null };
            });
          }
        }
        function ce(oe, B, j, N) {
          const X = new T.F(B);
          for (const ie of oe) ie.setGlobalState(N), ie.recalculate(X, j);
        }
        class ve {
          constructor(B, j, N) {
            this.actor = B, this.layerIndex = j, this.availableImages = N, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(B, j) {
            return T._(this, void 0, void 0, function* () {
              const N = yield T.n(B.request, j);
              try {
                return { vectorTile: new T.cL(new T.cM(N.data)), rawData: N.data, cacheControl: N.cacheControl, expires: N.expires };
              } catch (X) {
                const ie = new Uint8Array(N.data);
                let le = `Unable to parse the tile at ${B.request.url}, `;
                throw le += ie[0] === 31 && ie[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${X.message}`, new Error(le);
              }
            });
          }
          loadTile(B) {
            return T._(this, void 0, void 0, function* () {
              const j = B.uid, N = !!(B && B.request && B.request.collectResourceTiming) && new T.cN(B.request), X = new ue(B);
              this.loading[j] = X;
              const ie = new AbortController();
              X.abort = ie;
              try {
                const le = yield this.loadVectorTile(B, ie);
                if (delete this.loading[j], !le) return null;
                const me = le.rawData, de = {};
                le.expires && (de.expires = le.expires), le.cacheControl && (de.cacheControl = le.cacheControl);
                const Pe = {};
                if (N) {
                  const Ce = N.finish();
                  Ce && (Pe.resourceTiming = JSON.parse(JSON.stringify(Ce)));
                }
                X.vectorTile = le.vectorTile;
                const ke = X.parse(le.vectorTile, this.layerIndex, this.availableImages, this.actor, B.subdivisionGranularity);
                this.loaded[j] = X, this.fetching[j] = { rawTileData: me, cacheControl: de, resourceTiming: Pe };
                try {
                  const Ce = yield ke;
                  return T.e({ rawTileData: me.slice(0) }, Ce, de, Pe);
                } finally {
                  delete this.fetching[j];
                }
              } catch (le) {
                throw delete this.loading[j], X.status = "done", this.loaded[j] = X, le;
              }
            });
          }
          reloadTile(B) {
            return T._(this, void 0, void 0, function* () {
              const j = B.uid;
              if (!this.loaded || !this.loaded[j]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const N = this.loaded[j];
              if (N.showCollisionBoxes = B.showCollisionBoxes, N.globalState = B.globalState, N.status === "parsing") {
                const X = yield N.parse(N.vectorTile, this.layerIndex, this.availableImages, this.actor, B.subdivisionGranularity);
                let ie;
                if (this.fetching[j]) {
                  const { rawTileData: le, cacheControl: me, resourceTiming: de } = this.fetching[j];
                  delete this.fetching[j], ie = T.e({ rawTileData: le.slice(0) }, X, me, de);
                } else ie = X;
                return ie;
              }
              if (N.status === "done" && N.vectorTile) return N.parse(N.vectorTile, this.layerIndex, this.availableImages, this.actor, B.subdivisionGranularity);
            });
          }
          abortTile(B) {
            return T._(this, void 0, void 0, function* () {
              const j = this.loading, N = B.uid;
              j && j[N] && j[N].abort && (j[N].abort.abort(), delete j[N]);
            });
          }
          removeTile(B) {
            return T._(this, void 0, void 0, function* () {
              this.loaded && this.loaded[B.uid] && delete this.loaded[B.uid];
            });
          }
        }
        class we {
          constructor() {
            this.loaded = {};
          }
          loadTile(B) {
            return T._(this, void 0, void 0, function* () {
              const { uid: j, encoding: N, rawImageData: X, redFactor: ie, greenFactor: le, blueFactor: me, baseShift: de } = B, Pe = X.width + 2, ke = X.height + 2, Ce = T.b(X) ? new T.R({ width: Pe, height: ke }, yield T.cO(X, -1, -1, Pe, ke)) : X, rt = new T.cP(j, Ce, N, ie, le, me, de);
              return this.loaded = this.loaded || {}, this.loaded[j] = rt, rt;
            });
          }
          removeTile(B) {
            const j = this.loaded, N = B.uid;
            j && j[N] && delete j[N];
          }
        }
        var Q, Je, it = function() {
          if (Je) return Q;
          function oe(j, N) {
            if (j.length !== 0) {
              B(j[0], N);
              for (var X = 1; X < j.length; X++) B(j[X], !N);
            }
          }
          function B(j, N) {
            for (var X = 0, ie = 0, le = 0, me = j.length, de = me - 1; le < me; de = le++) {
              var Pe = (j[le][0] - j[de][0]) * (j[de][1] + j[le][1]), ke = X + Pe;
              ie += Math.abs(X) >= Math.abs(Pe) ? X - ke + Pe : Pe - ke + X, X = ke;
            }
            X + ie >= 0 != !!N && j.reverse();
          }
          return Je = 1, Q = function j(N, X) {
            var ie, le = N && N.type;
            if (le === "FeatureCollection") for (ie = 0; ie < N.features.length; ie++) j(N.features[ie], X);
            else if (le === "GeometryCollection") for (ie = 0; ie < N.geometries.length; ie++) j(N.geometries[ie], X);
            else if (le === "Feature") j(N.geometry, X);
            else if (le === "Polygon") oe(N.coordinates, X);
            else if (le === "MultiPolygon") for (ie = 0; ie < N.coordinates.length; ie++) oe(N.coordinates[ie], X);
            return N;
          };
        }(), vt = T.cQ(it);
        class Ze extends T.cS {
          constructor(B, j) {
            super(new T.cM(), 0, j, [], []), this.feature = B, this.type = B.type, this.properties = B.tags ? B.tags : {}, "id" in B && (typeof B.id == "string" ? this.id = parseInt(B.id, 10) : typeof B.id != "number" || isNaN(B.id) || (this.id = B.id));
          }
          loadGeometry() {
            const B = [], j = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const N of j) {
              const X = [];
              for (const ie of N) X.push(new T.P(ie[0], ie[1]));
              B.push(X);
            }
            return B;
          }
        }
        class Ke extends T.cR {
          constructor(B, j) {
            super(new T.cM()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = j ? j.version : 1, this.extent = j ? j.extent : 4096, this.length = B.length, this.features = B;
          }
          feature(B) {
            return new Ze(this.features[B], this.extent);
          }
        }
        function ut(oe, B) {
          B.writeVarintField(15, oe.version || 1), B.writeStringField(1, oe.name || ""), B.writeVarintField(5, oe.extent || 4096);
          const j = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let ie = 0; ie < oe.length; ie++) j.feature = oe.feature(ie), B.writeMessage(2, Qe, j);
          const N = j.keys;
          for (const ie of N) B.writeStringField(3, ie);
          const X = j.values;
          for (const ie of X) B.writeMessage(4, _t, ie);
        }
        function Qe(oe, B) {
          if (!oe.feature) return;
          const j = oe.feature;
          j.id !== void 0 && B.writeVarintField(1, j.id), B.writeMessage(2, It, oe), B.writeVarintField(3, j.type), B.writeMessage(4, at, j);
        }
        function It(oe, B) {
          var j;
          for (const N in (j = oe.feature) == null ? void 0 : j.properties) {
            let X = oe.feature.properties[N], ie = oe.keycache[N];
            if (X === null) continue;
            ie === void 0 && (oe.keys.push(N), ie = oe.keys.length - 1, oe.keycache[N] = ie), B.writeVarint(ie), typeof X != "string" && typeof X != "boolean" && typeof X != "number" && (X = JSON.stringify(X));
            const le = typeof X + ":" + X;
            let me = oe.valuecache[le];
            me === void 0 && (oe.values.push(X), me = oe.values.length - 1, oe.valuecache[le] = me), B.writeVarint(me);
          }
        }
        function ki(oe, B) {
          return (B << 3) + (7 & oe);
        }
        function pt(oe) {
          return oe << 1 ^ oe >> 31;
        }
        function at(oe, B) {
          const j = oe.loadGeometry(), N = oe.type;
          let X = 0, ie = 0;
          for (const le of j) {
            let me = 1;
            N === 1 && (me = le.length), B.writeVarint(ki(1, me));
            const de = N === 3 ? le.length - 1 : le.length;
            for (let Pe = 0; Pe < de; Pe++) {
              Pe === 1 && N !== 1 && B.writeVarint(ki(2, de - 1));
              const ke = le[Pe].x - X, Ce = le[Pe].y - ie;
              B.writeVarint(pt(ke)), B.writeVarint(pt(Ce)), X += ke, ie += Ce;
            }
            oe.type === 3 && B.writeVarint(ki(7, 1));
          }
        }
        function _t(oe, B) {
          const j = typeof oe;
          j === "string" ? B.writeStringField(1, oe) : j === "boolean" ? B.writeBooleanField(7, oe) : j === "number" && (oe % 1 != 0 ? B.writeDoubleField(3, oe) : oe < 0 ? B.writeSVarintField(6, oe) : B.writeVarintField(5, oe));
        }
        const Et = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (oe) => oe }, Ut = Math.fround || (fi = new Float32Array(1), (oe) => (fi[0] = +oe, fi[0]));
        var fi;
        class ir {
          constructor(B) {
            this.options = Object.assign(Object.create(Et), B), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(B) {
            const { log: j, minZoom: N, maxZoom: X } = this.options;
            j && console.time("total time");
            const ie = `prepare ${B.length} points`;
            j && console.time(ie), this.points = B;
            const le = [];
            for (let de = 0; de < B.length; de++) {
              const Pe = B[de];
              if (!Pe.geometry) continue;
              const [ke, Ce] = Pe.geometry.coordinates, rt = Ut(ti(ke)), fe = Ut(At(Ce));
              le.push(rt, fe, 1 / 0, de, -1, 1), this.options.reduce && le.push(0);
            }
            let me = this.trees[X + 1] = this._createTree(le);
            j && console.timeEnd(ie);
            for (let de = X; de >= N; de--) {
              const Pe = +Date.now();
              me = this.trees[de] = this._createTree(this._cluster(me, de)), j && console.log("z%d: %d clusters in %dms", de, me.numItems, +Date.now() - Pe);
            }
            return j && console.timeEnd("total time"), this;
          }
          getClusters(B, j) {
            let N = ((B[0] + 180) % 360 + 360) % 360 - 180;
            const X = Math.max(-90, Math.min(90, B[1]));
            let ie = B[2] === 180 ? 180 : ((B[2] + 180) % 360 + 360) % 360 - 180;
            const le = Math.max(-90, Math.min(90, B[3]));
            if (B[2] - B[0] >= 360) N = -180, ie = 180;
            else if (N > ie) {
              const Ce = this.getClusters([N, X, 180, le], j), rt = this.getClusters([-180, X, ie, le], j);
              return Ce.concat(rt);
            }
            const me = this.trees[this._limitZoom(j)], de = me.range(ti(N), At(le), ti(ie), At(X)), Pe = me.data, ke = [];
            for (const Ce of de) {
              const rt = this.stride * Ce;
              ke.push(Pe[rt + 5] > 1 ? Jr(Pe, rt, this.clusterProps) : this.points[Pe[rt + 3]]);
            }
            return ke;
          }
          getChildren(B) {
            const j = this._getOriginId(B), N = this._getOriginZoom(B), X = "No cluster with the specified id.", ie = this.trees[N];
            if (!ie) throw new Error(X);
            const le = ie.data;
            if (j * this.stride >= le.length) throw new Error(X);
            const me = this.options.radius / (this.options.extent * Math.pow(2, N - 1)), de = ie.within(le[j * this.stride], le[j * this.stride + 1], me), Pe = [];
            for (const ke of de) {
              const Ce = ke * this.stride;
              le[Ce + 4] === B && Pe.push(le[Ce + 5] > 1 ? Jr(le, Ce, this.clusterProps) : this.points[le[Ce + 3]]);
            }
            if (Pe.length === 0) throw new Error(X);
            return Pe;
          }
          getLeaves(B, j, N) {
            const X = [];
            return this._appendLeaves(X, B, j = j || 10, N = N || 0, 0), X;
          }
          getTile(B, j, N) {
            const X = this.trees[this._limitZoom(B)], ie = Math.pow(2, B), { extent: le, radius: me } = this.options, de = me / le, Pe = (N - de) / ie, ke = (N + 1 + de) / ie, Ce = { features: [] };
            return this._addTileFeatures(X.range((j - de) / ie, Pe, (j + 1 + de) / ie, ke), X.data, j, N, ie, Ce), j === 0 && this._addTileFeatures(X.range(1 - de / ie, Pe, 1, ke), X.data, ie, N, ie, Ce), j === ie - 1 && this._addTileFeatures(X.range(0, Pe, de / ie, ke), X.data, -1, N, ie, Ce), Ce.features.length ? Ce : null;
          }
          getClusterExpansionZoom(B) {
            let j = this._getOriginZoom(B) - 1;
            for (; j <= this.options.maxZoom; ) {
              const N = this.getChildren(B);
              if (j++, N.length !== 1) break;
              B = N[0].properties.cluster_id;
            }
            return j;
          }
          _appendLeaves(B, j, N, X, ie) {
            const le = this.getChildren(j);
            for (const me of le) {
              const de = me.properties;
              if (de && de.cluster ? ie + de.point_count <= X ? ie += de.point_count : ie = this._appendLeaves(B, de.cluster_id, N, X, ie) : ie < X ? ie++ : B.push(me), B.length === N) break;
            }
            return ie;
          }
          _createTree(B) {
            const j = new T.aI(B.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let N = 0; N < B.length; N += this.stride) j.add(B[N], B[N + 1]);
            return j.finish(), j.data = B, j;
          }
          _addTileFeatures(B, j, N, X, ie, le) {
            for (const me of B) {
              const de = me * this.stride, Pe = j[de + 5] > 1;
              let ke, Ce, rt;
              if (Pe) ke = Gr(j, de, this.clusterProps), Ce = j[de], rt = j[de + 1];
              else {
                const Dt = this.points[j[de + 3]];
                ke = Dt.properties;
                const [ot, St] = Dt.geometry.coordinates;
                Ce = ti(ot), rt = At(St);
              }
              const fe = { type: 1, geometry: [[Math.round(this.options.extent * (Ce * ie - N)), Math.round(this.options.extent * (rt * ie - X))]], tags: ke };
              let bt;
              bt = Pe || this.options.generateId ? j[de + 3] : this.points[j[de + 3]].id, bt !== void 0 && (fe.id = bt), le.features.push(fe);
            }
          }
          _limitZoom(B) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+B), this.options.maxZoom + 1));
          }
          _cluster(B, j) {
            const { radius: N, extent: X, reduce: ie, minPoints: le } = this.options, me = N / (X * Math.pow(2, j)), de = B.data, Pe = [], ke = this.stride;
            for (let Ce = 0; Ce < de.length; Ce += ke) {
              if (de[Ce + 2] <= j) continue;
              de[Ce + 2] = j;
              const rt = de[Ce], fe = de[Ce + 1], bt = B.within(de[Ce], de[Ce + 1], me), Dt = de[Ce + 5];
              let ot = Dt;
              for (const St of bt) {
                const ui = St * ke;
                de[ui + 2] > j && (ot += de[ui + 5]);
              }
              if (ot > Dt && ot >= le) {
                let St, ui = rt * Dt, ji = fe * Dt, Vi = -1;
                const Ci = (Ce / ke << 5) + (j + 1) + this.points.length;
                for (const Ot of bt) {
                  const Gt = Ot * ke;
                  if (de[Gt + 2] <= j) continue;
                  de[Gt + 2] = j;
                  const Ri = de[Gt + 5];
                  ui += de[Gt] * Ri, ji += de[Gt + 1] * Ri, de[Gt + 4] = Ci, ie && (St || (St = this._map(de, Ce, !0), Vi = this.clusterProps.length, this.clusterProps.push(St)), ie(St, this._map(de, Gt)));
                }
                de[Ce + 4] = Ci, Pe.push(ui / ot, ji / ot, 1 / 0, Ci, -1, ot), ie && Pe.push(Vi);
              } else {
                for (let St = 0; St < ke; St++) Pe.push(de[Ce + St]);
                if (ot > 1) for (const St of bt) {
                  const ui = St * ke;
                  if (!(de[ui + 2] <= j)) {
                    de[ui + 2] = j;
                    for (let ji = 0; ji < ke; ji++) Pe.push(de[ui + ji]);
                  }
                }
              }
            }
            return Pe;
          }
          _getOriginId(B) {
            return B - this.points.length >> 5;
          }
          _getOriginZoom(B) {
            return (B - this.points.length) % 32;
          }
          _map(B, j, N) {
            if (B[j + 5] > 1) {
              const le = this.clusterProps[B[j + 6]];
              return N ? Object.assign({}, le) : le;
            }
            const X = this.points[B[j + 3]].properties, ie = this.options.map(X);
            return N && ie === X ? Object.assign({}, ie) : ie;
          }
        }
        function Jr(oe, B, j) {
          return { type: "Feature", id: oe[B + 3], properties: Gr(oe, B, j), geometry: { type: "Point", coordinates: [(N = oe[B], 360 * (N - 0.5)), Jt(oe[B + 1])] } };
          var N;
        }
        function Gr(oe, B, j) {
          const N = oe[B + 5], X = N >= 1e4 ? `${Math.round(N / 1e3)}k` : N >= 1e3 ? Math.round(N / 100) / 10 + "k" : N, ie = oe[B + 6], le = ie === -1 ? {} : Object.assign({}, j[ie]);
          return Object.assign(le, { cluster: !0, cluster_id: oe[B + 3], point_count: N, point_count_abbreviated: X });
        }
        function ti(oe) {
          return oe / 360 + 0.5;
        }
        function At(oe) {
          const B = Math.sin(oe * Math.PI / 180), j = 0.5 - 0.25 * Math.log((1 + B) / (1 - B)) / Math.PI;
          return j < 0 ? 0 : j > 1 ? 1 : j;
        }
        function Jt(oe) {
          const B = (180 - 360 * oe) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(B)) / Math.PI - 90;
        }
        function Zt(oe, B, j, N) {
          let X = N;
          const ie = B + (j - B >> 1);
          let le, me = j - B;
          const de = oe[B], Pe = oe[B + 1], ke = oe[j], Ce = oe[j + 1];
          for (let rt = B + 3; rt < j; rt += 3) {
            const fe = qr(oe[rt], oe[rt + 1], de, Pe, ke, Ce);
            if (fe > X) le = rt, X = fe;
            else if (fe === X) {
              const bt = Math.abs(rt - ie);
              bt < me && (le = rt, me = bt);
            }
          }
          X > N && (le - B > 3 && Zt(oe, B, le, N), oe[le + 2] = X, j - le > 3 && Zt(oe, le, j, N));
        }
        function qr(oe, B, j, N, X, ie) {
          let le = X - j, me = ie - N;
          if (le !== 0 || me !== 0) {
            const de = ((oe - j) * le + (B - N) * me) / (le * le + me * me);
            de > 1 ? (j = X, N = ie) : de > 0 && (j += le * de, N += me * de);
          }
          return le = oe - j, me = B - N, le * le + me * me;
        }
        function mi(oe, B, j, N) {
          const X = { id: oe ?? null, type: B, geometry: j, tags: N, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (B === "Point" || B === "MultiPoint" || B === "LineString") Gi(X, j);
          else if (B === "Polygon") Gi(X, j[0]);
          else if (B === "MultiLineString") for (const ie of j) Gi(X, ie);
          else if (B === "MultiPolygon") for (const ie of j) Gi(X, ie[0]);
          return X;
        }
        function Gi(oe, B) {
          for (let j = 0; j < B.length; j += 3) oe.minX = Math.min(oe.minX, B[j]), oe.minY = Math.min(oe.minY, B[j + 1]), oe.maxX = Math.max(oe.maxX, B[j]), oe.maxY = Math.max(oe.maxY, B[j + 1]);
        }
        function Dr(oe, B, j, N) {
          if (!B.geometry) return;
          const X = B.geometry.coordinates;
          if (X && X.length === 0) return;
          const ie = B.geometry.type, le = Math.pow(j.tolerance / ((1 << j.maxZoom) * j.extent), 2);
          let me = [], de = B.id;
          if (j.promoteId ? de = B.properties[j.promoteId] : j.generateId && (de = N || 0), ie === "Point") vn(X, me);
          else if (ie === "MultiPoint") for (const Pe of X) vn(Pe, me);
          else if (ie === "LineString") Cn(X, me, le, !1);
          else if (ie === "MultiLineString") {
            if (j.lineMetrics) {
              for (const Pe of X) me = [], Cn(Pe, me, le, !1), oe.push(mi(de, "LineString", me, B.properties));
              return;
            }
            zi(X, me, le, !1);
          } else if (ie === "Polygon") zi(X, me, le, !0);
          else {
            if (ie !== "MultiPolygon") {
              if (ie === "GeometryCollection") {
                for (const Pe of B.geometry.geometries) Dr(oe, { id: de, geometry: Pe, properties: B.properties }, j, N);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const Pe of X) {
              const ke = [];
              zi(Pe, ke, le, !0), me.push(ke);
            }
          }
          oe.push(mi(de, ie, me, B.properties));
        }
        function vn(oe, B) {
          B.push(Qr(oe[0]), ur(oe[1]), 0);
        }
        function Cn(oe, B, j, N) {
          let X, ie, le = 0;
          for (let de = 0; de < oe.length; de++) {
            const Pe = Qr(oe[de][0]), ke = ur(oe[de][1]);
            B.push(Pe, ke, 0), de > 0 && (le += N ? (X * ke - Pe * ie) / 2 : Math.sqrt(Math.pow(Pe - X, 2) + Math.pow(ke - ie, 2))), X = Pe, ie = ke;
          }
          const me = B.length - 3;
          B[2] = 1, Zt(B, 0, me, j), B[me + 2] = 1, B.size = Math.abs(le), B.start = 0, B.end = B.size;
        }
        function zi(oe, B, j, N) {
          for (let X = 0; X < oe.length; X++) {
            const ie = [];
            Cn(oe[X], ie, j, N), B.push(ie);
          }
        }
        function Qr(oe) {
          return oe / 360 + 0.5;
        }
        function ur(oe) {
          const B = Math.sin(oe * Math.PI / 180), j = 0.5 - 0.25 * Math.log((1 + B) / (1 - B)) / Math.PI;
          return j < 0 ? 0 : j > 1 ? 1 : j;
        }
        function Mr(oe, B, j, N, X, ie, le, me) {
          if (N /= B, ie >= (j /= B) && le < N) return oe;
          if (le < j || ie >= N) return null;
          const de = [];
          for (const Pe of oe) {
            const ke = Pe.geometry;
            let Ce = Pe.type;
            const rt = X === 0 ? Pe.minX : Pe.minY, fe = X === 0 ? Pe.maxX : Pe.maxY;
            if (rt >= j && fe < N) {
              de.push(Pe);
              continue;
            }
            if (fe < j || rt >= N) continue;
            let bt = [];
            if (Ce === "Point" || Ce === "MultiPoint") Hr(ke, bt, j, N, X);
            else if (Ce === "LineString") hs(ke, bt, j, N, X, !1, me.lineMetrics);
            else if (Ce === "MultiLineString") ae(ke, bt, j, N, X, !1);
            else if (Ce === "Polygon") ae(ke, bt, j, N, X, !0);
            else if (Ce === "MultiPolygon") for (const Dt of ke) {
              const ot = [];
              ae(Dt, ot, j, N, X, !0), ot.length && bt.push(ot);
            }
            if (bt.length) {
              if (me.lineMetrics && Ce === "LineString") {
                for (const Dt of bt) de.push(mi(Pe.id, Ce, Dt, Pe.tags));
                continue;
              }
              Ce !== "LineString" && Ce !== "MultiLineString" || (bt.length === 1 ? (Ce = "LineString", bt = bt[0]) : Ce = "MultiLineString"), Ce !== "Point" && Ce !== "MultiPoint" || (Ce = bt.length === 3 ? "Point" : "MultiPoint"), de.push(mi(Pe.id, Ce, bt, Pe.tags));
            }
          }
          return de.length ? de : null;
        }
        function Hr(oe, B, j, N, X) {
          for (let ie = 0; ie < oe.length; ie += 3) {
            const le = oe[ie + X];
            le >= j && le <= N && Se(B, oe[ie], oe[ie + 1], oe[ie + 2]);
          }
        }
        function hs(oe, B, j, N, X, ie, le) {
          let me = ne(oe);
          const de = X === 0 ? ze : Ae;
          let Pe, ke, Ce = oe.start;
          for (let ot = 0; ot < oe.length - 3; ot += 3) {
            const St = oe[ot], ui = oe[ot + 1], ji = oe[ot + 2], Vi = oe[ot + 3], Ci = oe[ot + 4], Ot = X === 0 ? St : ui, Gt = X === 0 ? Vi : Ci;
            let Ri = !1;
            le && (Pe = Math.sqrt(Math.pow(St - Vi, 2) + Math.pow(ui - Ci, 2))), Ot < j ? Gt > j && (ke = de(me, St, ui, Vi, Ci, j), le && (me.start = Ce + Pe * ke)) : Ot > N ? Gt < N && (ke = de(me, St, ui, Vi, Ci, N), le && (me.start = Ce + Pe * ke)) : Se(me, St, ui, ji), Gt < j && Ot >= j && (ke = de(me, St, ui, Vi, Ci, j), Ri = !0), Gt > N && Ot <= N && (ke = de(me, St, ui, Vi, Ci, N), Ri = !0), !ie && Ri && (le && (me.end = Ce + Pe * ke), B.push(me), me = ne(oe)), le && (Ce += Pe);
          }
          let rt = oe.length - 3;
          const fe = oe[rt], bt = oe[rt + 1], Dt = X === 0 ? fe : bt;
          Dt >= j && Dt <= N && Se(me, fe, bt, oe[rt + 2]), rt = me.length - 3, ie && rt >= 3 && (me[rt] !== me[0] || me[rt + 1] !== me[1]) && Se(me, me[0], me[1], me[2]), me.length && B.push(me);
        }
        function ne(oe) {
          const B = [];
          return B.size = oe.size, B.start = oe.start, B.end = oe.end, B;
        }
        function ae(oe, B, j, N, X, ie) {
          for (const le of oe) hs(le, B, j, N, X, ie, !1);
        }
        function Se(oe, B, j, N) {
          oe.push(B, j, N);
        }
        function ze(oe, B, j, N, X, ie) {
          const le = (ie - B) / (N - B);
          return Se(oe, ie, j + (X - j) * le, 1), le;
        }
        function Ae(oe, B, j, N, X, ie) {
          const le = (ie - j) / (X - j);
          return Se(oe, B + (N - B) * le, ie, 1), le;
        }
        function Re(oe, B) {
          const j = [];
          for (let N = 0; N < oe.length; N++) {
            const X = oe[N], ie = X.type;
            let le;
            if (ie === "Point" || ie === "MultiPoint" || ie === "LineString") le = He(X.geometry, B);
            else if (ie === "MultiLineString" || ie === "Polygon") {
              le = [];
              for (const me of X.geometry) le.push(He(me, B));
            } else if (ie === "MultiPolygon") {
              le = [];
              for (const me of X.geometry) {
                const de = [];
                for (const Pe of me) de.push(He(Pe, B));
                le.push(de);
              }
            }
            j.push(mi(X.id, ie, le, X.tags));
          }
          return j;
        }
        function He(oe, B) {
          const j = [];
          j.size = oe.size, oe.start !== void 0 && (j.start = oe.start, j.end = oe.end);
          for (let N = 0; N < oe.length; N += 3) j.push(oe[N] + B, oe[N + 1], oe[N + 2]);
          return j;
        }
        function Ue(oe, B) {
          if (oe.transformed) return oe;
          const j = 1 << oe.z, N = oe.x, X = oe.y;
          for (const ie of oe.features) {
            const le = ie.geometry, me = ie.type;
            if (ie.geometry = [], me === 1) for (let de = 0; de < le.length; de += 2) ie.geometry.push(Ge(le[de], le[de + 1], B, j, N, X));
            else for (let de = 0; de < le.length; de++) {
              const Pe = [];
              for (let ke = 0; ke < le[de].length; ke += 2) Pe.push(Ge(le[de][ke], le[de][ke + 1], B, j, N, X));
              ie.geometry.push(Pe);
            }
          }
          return oe.transformed = !0, oe;
        }
        function Ge(oe, B, j, N, X, ie) {
          return [Math.round(j * (oe * N - X)), Math.round(j * (B * N - ie))];
        }
        function De(oe, B, j, N, X) {
          const ie = B === X.maxZoom ? 0 : X.tolerance / ((1 << B) * X.extent), le = { features: [], numPoints: 0, numSimplified: 0, numFeatures: oe.length, source: null, x: j, y: N, z: B, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const me of oe) ht(le, me, ie, X);
          return le;
        }
        function ht(oe, B, j, N) {
          const X = B.geometry, ie = B.type, le = [];
          if (oe.minX = Math.min(oe.minX, B.minX), oe.minY = Math.min(oe.minY, B.minY), oe.maxX = Math.max(oe.maxX, B.maxX), oe.maxY = Math.max(oe.maxY, B.maxY), ie === "Point" || ie === "MultiPoint") for (let me = 0; me < X.length; me += 3) le.push(X[me], X[me + 1]), oe.numPoints++, oe.numSimplified++;
          else if (ie === "LineString") Ye(le, X, oe, j, !1, !1);
          else if (ie === "MultiLineString" || ie === "Polygon") for (let me = 0; me < X.length; me++) Ye(le, X[me], oe, j, ie === "Polygon", me === 0);
          else if (ie === "MultiPolygon") for (let me = 0; me < X.length; me++) {
            const de = X[me];
            for (let Pe = 0; Pe < de.length; Pe++) Ye(le, de[Pe], oe, j, !0, Pe === 0);
          }
          if (le.length) {
            let me = B.tags || null;
            if (ie === "LineString" && N.lineMetrics) {
              me = {};
              for (const Pe in B.tags) me[Pe] = B.tags[Pe];
              me.mapbox_clip_start = X.start / X.size, me.mapbox_clip_end = X.end / X.size;
            }
            const de = { geometry: le, type: ie === "Polygon" || ie === "MultiPolygon" ? 3 : ie === "LineString" || ie === "MultiLineString" ? 2 : 1, tags: me };
            B.id !== null && (de.id = B.id), oe.features.push(de);
          }
        }
        function Ye(oe, B, j, N, X, ie) {
          const le = N * N;
          if (N > 0 && B.size < (X ? le : N)) return void (j.numPoints += B.length / 3);
          const me = [];
          for (let de = 0; de < B.length; de += 3) (N === 0 || B[de + 2] > le) && (j.numSimplified++, me.push(B[de], B[de + 1])), j.numPoints++;
          X && function(de, Pe) {
            let ke = 0;
            for (let Ce = 0, rt = de.length, fe = rt - 2; Ce < rt; fe = Ce, Ce += 2) ke += (de[Ce] - de[fe]) * (de[Ce + 1] + de[fe + 1]);
            if (ke > 0 === Pe) for (let Ce = 0, rt = de.length; Ce < rt / 2; Ce += 2) {
              const fe = de[Ce], bt = de[Ce + 1];
              de[Ce] = de[rt - 2 - Ce], de[Ce + 1] = de[rt - 1 - Ce], de[rt - 2 - Ce] = fe, de[rt - 1 - Ce] = bt;
            }
          }(me, ie), oe.push(me);
        }
        const ct = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
        class gt {
          constructor(B, j) {
            const N = (j = this.options = function(ie, le) {
              for (const me in le) ie[me] = le[me];
              return ie;
            }(Object.create(ct), j)).debug;
            if (N && console.time("preprocess data"), j.maxZoom < 0 || j.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (j.promoteId && j.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let X = function(ie, le) {
              const me = [];
              if (ie.type === "FeatureCollection") for (let de = 0; de < ie.features.length; de++) Dr(me, ie.features[de], le, de);
              else Dr(me, ie.type === "Feature" ? ie : { geometry: ie }, le);
              return me;
            }(B, j);
            this.tiles = {}, this.tileCoords = [], N && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", j.indexMaxZoom, j.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), X = function(ie, le) {
              const me = le.buffer / le.extent;
              let de = ie;
              const Pe = Mr(ie, 1, -1 - me, me, 0, -1, 2, le), ke = Mr(ie, 1, 1 - me, 2 + me, 0, -1, 2, le);
              return (Pe || ke) && (de = Mr(ie, 1, -me, 1 + me, 0, -1, 2, le) || [], Pe && (de = Re(Pe, 1).concat(de)), ke && (de = de.concat(Re(ke, -1)))), de;
            }(X, j), X.length && this.splitTile(X, 0, 0, 0), N && (X.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(B, j, N, X, ie, le, me) {
            const de = [B, j, N, X], Pe = this.options, ke = Pe.debug;
            for (; de.length; ) {
              X = de.pop(), N = de.pop(), j = de.pop(), B = de.pop();
              const Ce = 1 << j, rt = zt(j, N, X);
              let fe = this.tiles[rt];
              if (!fe && (ke > 1 && console.time("creation"), fe = this.tiles[rt] = De(B, j, N, X, Pe), this.tileCoords.push({ z: j, x: N, y: X }), ke)) {
                ke > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", j, N, X, fe.numFeatures, fe.numPoints, fe.numSimplified), console.timeEnd("creation"));
                const Ri = `z${j}`;
                this.stats[Ri] = (this.stats[Ri] || 0) + 1, this.total++;
              }
              if (fe.source = B, ie == null) {
                if (j === Pe.indexMaxZoom || fe.numPoints <= Pe.indexMaxPoints) continue;
              } else {
                if (j === Pe.maxZoom || j === ie) continue;
                if (ie != null) {
                  const Ri = ie - j;
                  if (N !== le >> Ri || X !== me >> Ri) continue;
                }
              }
              if (fe.source = null, B.length === 0) continue;
              ke > 1 && console.time("clipping");
              const bt = 0.5 * Pe.buffer / Pe.extent, Dt = 0.5 - bt, ot = 0.5 + bt, St = 1 + bt;
              let ui = null, ji = null, Vi = null, Ci = null, Ot = Mr(B, Ce, N - bt, N + ot, 0, fe.minX, fe.maxX, Pe), Gt = Mr(B, Ce, N + Dt, N + St, 0, fe.minX, fe.maxX, Pe);
              B = null, Ot && (ui = Mr(Ot, Ce, X - bt, X + ot, 1, fe.minY, fe.maxY, Pe), ji = Mr(Ot, Ce, X + Dt, X + St, 1, fe.minY, fe.maxY, Pe), Ot = null), Gt && (Vi = Mr(Gt, Ce, X - bt, X + ot, 1, fe.minY, fe.maxY, Pe), Ci = Mr(Gt, Ce, X + Dt, X + St, 1, fe.minY, fe.maxY, Pe), Gt = null), ke > 1 && console.timeEnd("clipping"), de.push(ui || [], j + 1, 2 * N, 2 * X), de.push(ji || [], j + 1, 2 * N, 2 * X + 1), de.push(Vi || [], j + 1, 2 * N + 1, 2 * X), de.push(Ci || [], j + 1, 2 * N + 1, 2 * X + 1);
            }
          }
          getTile(B, j, N) {
            B = +B, j = +j, N = +N;
            const X = this.options, { extent: ie, debug: le } = X;
            if (B < 0 || B > 24) return null;
            const me = 1 << B, de = zt(B, j = j + me & me - 1, N);
            if (this.tiles[de]) return Ue(this.tiles[de], ie);
            le > 1 && console.log("drilling down to z%d-%d-%d", B, j, N);
            let Pe, ke = B, Ce = j, rt = N;
            for (; !Pe && ke > 0; ) ke--, Ce >>= 1, rt >>= 1, Pe = this.tiles[zt(ke, Ce, rt)];
            return Pe && Pe.source ? (le > 1 && (console.log("found parent tile z%d-%d-%d", ke, Ce, rt), console.time("drilling down")), this.splitTile(Pe.source, ke, Ce, rt, B, j, N), le > 1 && console.timeEnd("drilling down"), this.tiles[de] ? Ue(this.tiles[de], ie) : null) : null;
          }
        }
        function zt(oe, B, j) {
          return 32 * ((1 << oe) * j + B) + oe;
        }
        class Wt extends ve {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(B, j) {
            return T._(this, void 0, void 0, function* () {
              const N = B.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const X = this._geoJSONIndex.getTile(N.z, N.x, N.y);
              if (!X) return null;
              const ie = new Ke(X.features, { version: 2, extent: T.$ });
              let le = function(me) {
                const de = new T.cM();
                return function(Pe, ke) {
                  for (const Ce in Pe.layers) ke.writeMessage(3, ut, Pe.layers[Ce]);
                }(me, de), de.finish();
              }(ie);
              return le.byteOffset === 0 && le.byteLength === le.buffer.byteLength || (le = new Uint8Array(le)), { vectorTile: ie, rawData: le.buffer };
            });
          }
          loadData(B) {
            return T._(this, void 0, void 0, function* () {
              var j;
              (j = this._pendingRequest) === null || j === void 0 || j.abort();
              const N = !!(B && B.request && B.request.collectResourceTiming) && new T.cN(B.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON(B, this._pendingRequest);
                const X = yield this._pendingData;
                this._geoJSONIndex = B.cluster ? new ir(function({ superclusterOptions: le, clusterProperties: me }) {
                  if (!me || !le) return le;
                  const de = {}, Pe = {}, ke = { accumulated: null, zoom: 0 }, Ce = { properties: null }, rt = Object.keys(me);
                  for (const fe of rt) {
                    const [bt, Dt] = me[fe], ot = T.cT(Dt), St = T.cT(typeof bt == "string" ? [bt, ["accumulated"], ["get", fe]] : bt);
                    de[fe] = ot.value, Pe[fe] = St.value;
                  }
                  return le.map = (fe) => {
                    Ce.properties = fe;
                    const bt = {};
                    for (const Dt of rt) bt[Dt] = de[Dt].evaluate(ke, Ce);
                    return bt;
                  }, le.reduce = (fe, bt) => {
                    Ce.properties = bt;
                    for (const Dt of rt) ke.accumulated = fe[Dt], fe[Dt] = Pe[Dt].evaluate(ke, Ce);
                  }, le;
                }(B)).load(X.features) : function(le, me) {
                  return new gt(le, me);
                }(X, B.geojsonVtOptions), this.loaded = {};
                const ie = { data: X };
                if (N) {
                  const le = N.finish();
                  le && (ie.resourceTiming = {}, ie.resourceTiming[B.source] = JSON.parse(JSON.stringify(le)));
                }
                return ie;
              } catch (X) {
                if (delete this._pendingRequest, T.cy(X)) return { abandoned: !0 };
                throw X;
              }
            });
          }
          getData() {
            return T._(this, void 0, void 0, function* () {
              return this._pendingData;
            });
          }
          reloadTile(B) {
            const j = this.loaded;
            return j && j[B.uid] ? super.reloadTile(B) : this.loadTile(B);
          }
          loadAndProcessGeoJSON(B, j) {
            return T._(this, void 0, void 0, function* () {
              let N = yield this.loadGeoJSON(B, j);
              if (delete this._pendingRequest, typeof N != "object") throw new Error(`Input data given to '${B.source}' is not a valid GeoJSON object.`);
              if (vt(N, !0), B.filter) {
                const X = T.cT(B.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                if (X.result === "error") throw new Error(X.value.map((le) => `${le.key}: ${le.message}`).join(", "));
                N = { type: "FeatureCollection", features: N.features.filter((le) => X.value.evaluate({ zoom: 0 }, le)) };
              }
              return N;
            });
          }
          loadGeoJSON(B, j) {
            return T._(this, void 0, void 0, function* () {
              const { promoteId: N } = B;
              if (B.request) {
                const X = yield T.j(B.request, j);
                return this._dataUpdateable = T.cV(X.data, N) ? T.cU(X.data, N) : void 0, X.data;
              }
              if (typeof B.data == "string") try {
                const X = JSON.parse(B.data);
                return this._dataUpdateable = T.cV(X, N) ? T.cU(X, N) : void 0, X;
              } catch {
                throw new Error(`Input data given to '${B.source}' is not a valid GeoJSON object.`);
              }
              if (!B.dataDiff) throw new Error(`Input data given to '${B.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${B.source}`);
              return T.cW(this._dataUpdateable, B.dataDiff, N), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            });
          }
          removeSource(B) {
            return T._(this, void 0, void 0, function* () {
              this._pendingRequest && this._pendingRequest.abort();
            });
          }
          getClusterExpansionZoom(B) {
            return this._geoJSONIndex.getClusterExpansionZoom(B.clusterId);
          }
          getClusterChildren(B) {
            return this._geoJSONIndex.getChildren(B.clusterId);
          }
          getClusterLeaves(B) {
            return this._geoJSONIndex.getLeaves(B.clusterId, B.limit, B.offset);
          }
        }
        class Ht {
          constructor(B) {
            this.self = B, this.actor = new T.J(B), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (j, N) => {
              if (this.externalWorkerSourceTypes[j]) throw new Error(`Worker source with name "${j}" already registered.`);
              this.externalWorkerSourceTypes[j] = N;
            }, this.self.addProtocol = T.cA, this.self.removeProtocol = T.cB, this.self.registerRTLTextPlugin = (j) => {
              T.cX.setMethods(j);
            }, this.actor.registerMessageHandler("LDT", (j, N) => this._getDEMWorkerSource(j, N.source).loadTile(N)), this.actor.registerMessageHandler("RDT", (j, N) => T._(this, void 0, void 0, function* () {
              this._getDEMWorkerSource(j, N.source).removeTile(N);
            })), this.actor.registerMessageHandler("GCEZ", (j, N) => T._(this, void 0, void 0, function* () {
              return this._getWorkerSource(j, N.type, N.source).getClusterExpansionZoom(N);
            })), this.actor.registerMessageHandler("GCC", (j, N) => T._(this, void 0, void 0, function* () {
              return this._getWorkerSource(j, N.type, N.source).getClusterChildren(N);
            })), this.actor.registerMessageHandler("GCL", (j, N) => T._(this, void 0, void 0, function* () {
              return this._getWorkerSource(j, N.type, N.source).getClusterLeaves(N);
            })), this.actor.registerMessageHandler("LD", (j, N) => this._getWorkerSource(j, N.type, N.source).loadData(N)), this.actor.registerMessageHandler("GD", (j, N) => this._getWorkerSource(j, N.type, N.source).getData()), this.actor.registerMessageHandler("LT", (j, N) => this._getWorkerSource(j, N.type, N.source).loadTile(N)), this.actor.registerMessageHandler("RT", (j, N) => this._getWorkerSource(j, N.type, N.source).reloadTile(N)), this.actor.registerMessageHandler("AT", (j, N) => this._getWorkerSource(j, N.type, N.source).abortTile(N)), this.actor.registerMessageHandler("RMT", (j, N) => this._getWorkerSource(j, N.type, N.source).removeTile(N)), this.actor.registerMessageHandler("RS", (j, N) => T._(this, void 0, void 0, function* () {
              if (!this.workerSources[j] || !this.workerSources[j][N.type] || !this.workerSources[j][N.type][N.source]) return;
              const X = this.workerSources[j][N.type][N.source];
              delete this.workerSources[j][N.type][N.source], X.removeSource !== void 0 && X.removeSource(N);
            })), this.actor.registerMessageHandler("RM", (j) => T._(this, void 0, void 0, function* () {
              delete this.layerIndexes[j], delete this.availableImages[j], delete this.workerSources[j], delete this.demWorkerSources[j];
            })), this.actor.registerMessageHandler("SR", (j, N) => T._(this, void 0, void 0, function* () {
              this.referrer = N;
            })), this.actor.registerMessageHandler("SRPS", (j, N) => this._syncRTLPluginState(j, N)), this.actor.registerMessageHandler("IS", (j, N) => T._(this, void 0, void 0, function* () {
              this.self.importScripts(N);
            })), this.actor.registerMessageHandler("SI", (j, N) => this._setImages(j, N)), this.actor.registerMessageHandler("UL", (j, N) => T._(this, void 0, void 0, function* () {
              this._getLayerIndex(j).update(N.layers, N.removedIds);
            })), this.actor.registerMessageHandler("SL", (j, N) => T._(this, void 0, void 0, function* () {
              this._getLayerIndex(j).replace(N);
            }));
          }
          _setImages(B, j) {
            return T._(this, void 0, void 0, function* () {
              this.availableImages[B] = j;
              for (const N in this.workerSources[B]) {
                const X = this.workerSources[B][N];
                for (const ie in X) X[ie].availableImages = j;
              }
            });
          }
          _syncRTLPluginState(B, j) {
            return T._(this, void 0, void 0, function* () {
              return yield T.cX.syncState(j, this.self.importScripts);
            });
          }
          _getAvailableImages(B) {
            let j = this.availableImages[B];
            return j || (j = []), j;
          }
          _getLayerIndex(B) {
            let j = this.layerIndexes[B];
            return j || (j = this.layerIndexes[B] = new a()), j;
          }
          _getWorkerSource(B, j, N) {
            if (this.workerSources[B] || (this.workerSources[B] = {}), this.workerSources[B][j] || (this.workerSources[B][j] = {}), !this.workerSources[B][j][N]) {
              const X = { sendAsync: (ie, le) => (ie.targetMapId = B, this.actor.sendAsync(ie, le)) };
              switch (j) {
                case "vector":
                  this.workerSources[B][j][N] = new ve(X, this._getLayerIndex(B), this._getAvailableImages(B));
                  break;
                case "geojson":
                  this.workerSources[B][j][N] = new Wt(X, this._getLayerIndex(B), this._getAvailableImages(B));
                  break;
                default:
                  this.workerSources[B][j][N] = new this.externalWorkerSourceTypes[j](X, this._getLayerIndex(B), this._getAvailableImages(B));
              }
            }
            return this.workerSources[B][j][N];
          }
          _getDEMWorkerSource(B, j) {
            return this.demWorkerSources[B] || (this.demWorkerSources[B] = {}), this.demWorkerSources[B][j] || (this.demWorkerSources[B][j] = new we()), this.demWorkerSources[B][j];
          }
        }
        return T.i(self) && (self.worker = new Ht(self)), Ht;
      }), E("index", ["exports", "./shared"], function(T, a) {
        var U = "5.7.1";
        function ue() {
          var h = new a.A(4);
          return a.A != Float32Array && (h[1] = 0, h[2] = 0), h[0] = 1, h[3] = 1, h;
        }
        let ce, ve;
        const we = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(h, e, n) {
          const o = requestAnimationFrame((d) => {
            c(), e(d);
          }), { unsubscribe: c } = a.s(h.signal, "abort", () => {
            c(), cancelAnimationFrame(o), n(a.c());
          }, !1);
        }, frameAsync(h) {
          return new Promise((e, n) => {
            this.frame(h, e, n);
          });
        }, getImageData(h, e = 0) {
          return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e);
        }, getImageCanvasContext(h) {
          const e = window.document.createElement("canvas"), n = e.getContext("2d", { willReadFrequently: !0 });
          if (!n) throw new Error("failed to create canvas 2d context");
          return e.width = h.width, e.height = h.height, n.drawImage(h, 0, 0, h.width, h.height), n;
        }, resolveURL: (h) => (ce || (ce = document.createElement("a")), ce.href = h, ce.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (ve == null && (ve = matchMedia("(prefers-reduced-motion: reduce)")), ve.matches);
        } };
        class Q {
          static testProp(e) {
            if (!Q.docStyle) return e[0];
            for (let n = 0; n < e.length; n++) if (e[n] in Q.docStyle) return e[n];
            return e[0];
          }
          static create(e, n, o) {
            const c = window.document.createElement(e);
            return n !== void 0 && (c.className = n), o && o.appendChild(c), c;
          }
          static createNS(e, n) {
            return window.document.createElementNS(e, n);
          }
          static disableDrag() {
            Q.docStyle && Q.selectProp && (Q.userSelect = Q.docStyle[Q.selectProp], Q.docStyle[Q.selectProp] = "none");
          }
          static enableDrag() {
            Q.docStyle && Q.selectProp && (Q.docStyle[Q.selectProp] = Q.userSelect);
          }
          static setTransform(e, n) {
            e.style[Q.transformProp] = n;
          }
          static addEventListener(e, n, o, c = {}) {
            e.addEventListener(n, o, "passive" in c ? c : c.capture);
          }
          static removeEventListener(e, n, o, c = {}) {
            e.removeEventListener(n, o, "passive" in c ? c : c.capture);
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", Q.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", Q.suppressClickInternal, !0), window.setTimeout(() => {
              window.removeEventListener("click", Q.suppressClickInternal, !0);
            }, 0);
          }
          static getScale(e) {
            const n = e.getBoundingClientRect();
            return { x: n.width / e.offsetWidth || 1, y: n.height / e.offsetHeight || 1, boundingClientRect: n };
          }
          static getPoint(e, n, o) {
            const c = n.boundingClientRect;
            return new a.P((o.clientX - c.left) / n.x - e.clientLeft, (o.clientY - c.top) / n.y - e.clientTop);
          }
          static mousePos(e, n) {
            const o = Q.getScale(e);
            return Q.getPoint(e, o, n);
          }
          static touchPos(e, n) {
            const o = [], c = Q.getScale(e);
            for (let d = 0; d < n.length; d++) o.push(Q.getPoint(e, c, n[d]));
            return o;
          }
          static mouseButton(e) {
            return e.button;
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e);
          }
          static sanitize(e) {
            const n = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), o = n.querySelectorAll("script");
            for (const c of o) c.remove();
            return Q.clean(n), n.innerHTML;
          }
          static isPossiblyDangerous(e, n) {
            const o = n.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !o.includes("javascript:") && !o.includes("data:")) || !!e.startsWith("on") || void 0;
          }
          static clean(e) {
            const n = e.children;
            for (const o of n) Q.removeAttributes(o), Q.clean(o);
          }
          static removeAttributes(e) {
            for (const { name: n, value: o } of e.attributes) Q.isPossiblyDangerous(n, o) && e.removeAttribute(n);
          }
        }
        Q.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, Q.selectProp = Q.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), Q.transformProp = Q.testProp(["transform", "WebkitTransform"]);
        const Je = { supported: !1, testSupport: function(h) {
          !Ze && vt && (Ke ? ut(h) : it = h);
        } };
        let it, vt, Ze = !1, Ke = !1;
        function ut(h) {
          const e = h.createTexture();
          h.bindTexture(h.TEXTURE_2D, e);
          try {
            if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, vt), h.isContextLost()) return;
            Je.supported = !0;
          } catch {
          }
          h.deleteTexture(e), Ze = !0;
        }
        var Qe;
        typeof document < "u" && (vt = document.createElement("img"), vt.onload = () => {
          it && ut(it), it = null, Ke = !0;
        }, vt.onerror = () => {
          Ze = !0, it = null;
        }, vt.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(h) {
          let e, n, o, c;
          h.resetRequestQueue = () => {
            e = [], n = 0, o = 0, c = {};
          }, h.addThrottleControl = (x) => {
            const M = o++;
            return c[M] = x, M;
          }, h.removeThrottleControl = (x) => {
            delete c[x], g();
          }, h.getImage = (x, M, C = !0) => new Promise((k, A) => {
            Je.supported && (x.headers || (x.headers = {}), x.headers.accept = "image/webp,*/*"), a.e(x, { type: "image" }), e.push({ abortController: M, requestParameters: x, supportImageRefresh: C, state: "queued", onError: (R) => {
              A(R);
            }, onSuccess: (R) => {
              k(R);
            } }), g();
          });
          const d = (x) => a._(this, void 0, void 0, function* () {
            x.state = "running";
            const { requestParameters: M, supportImageRefresh: C, onError: k, onSuccess: A, abortController: R } = x, O = C === !1 && !a.i(self) && !a.g(M.url) && (!M.headers || Object.keys(M.headers).reduce((q, W) => q && W === "accept", !0));
            n++;
            const G = O ? v(M, R) : a.m(M, R);
            try {
              const q = yield G;
              delete x.abortController, x.state = "completed", q.data instanceof HTMLImageElement || a.b(q.data) ? A(q) : q.data && A({ data: yield (Z = q.data, typeof createImageBitmap == "function" ? a.f(Z) : a.h(Z)), cacheControl: q.cacheControl, expires: q.expires });
            } catch (q) {
              delete x.abortController, k(q);
            } finally {
              n--, g();
            }
            var Z;
          }), g = () => {
            const x = (() => {
              for (const M of Object.keys(c)) if (c[M]()) return !0;
              return !1;
            })() ? a.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : a.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let M = n; M < x && e.length > 0; M++) {
              const C = e.shift();
              C.abortController.signal.aborted ? M-- : d(C);
            }
          }, v = (x, M) => new Promise((C, k) => {
            const A = new Image(), R = x.url, O = x.credentials;
            O && O === "include" ? A.crossOrigin = "use-credentials" : (O && O === "same-origin" || !a.d(R)) && (A.crossOrigin = "anonymous"), M.signal.addEventListener("abort", () => {
              A.src = "", k(a.c());
            }), A.fetchPriority = "high", A.onload = () => {
              A.onerror = A.onload = null, C({ data: A });
            }, A.onerror = () => {
              A.onerror = A.onload = null, M.signal.aborted || k(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, A.src = R;
          });
        }(Qe || (Qe = {})), Qe.resetRequestQueue();
        class It {
          constructor(e) {
            this._transformRequestFn = e ?? null;
          }
          transformRequest(e, n) {
            return this._transformRequestFn && this._transformRequestFn(e, n) || { url: e };
          }
          setTransformRequest(e) {
            this._transformRequestFn = e;
          }
        }
        function ki(h) {
          const e = [];
          if (typeof h == "string") e.push({ id: "default", url: h });
          else if (h && h.length > 0) {
            const n = [];
            for (const { id: o, url: c } of h) {
              const d = `${o}${c}`;
              n.indexOf(d) === -1 && (n.push(d), e.push({ id: o, url: c }));
            }
          }
          return e;
        }
        function pt(h, e, n) {
          try {
            const o = new URL(h);
            return o.pathname += `${e}${n}`, o.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function at(h) {
          const { userImage: e } = h;
          return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)), !0);
        }
        class _t extends a.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new a.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const { ids: n, promiseResolve: o } of this.requestors) o(this._getImagesForIds(n));
              this.requestors = [];
            }
          }
          getImage(e) {
            const n = this.images[e];
            if (n && !n.data && n.spriteData) {
              const o = n.spriteData;
              n.data = new a.R({ width: o.width, height: o.height }, o.context.getImageData(o.x, o.y, o.width, o.height).data), n.spriteData = null;
            }
            return n;
          }
          addImage(e, n) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, n) && (this.images[e] = n);
          }
          _validate(e, n) {
            let o = !0;
            const c = n.data || n.spriteData;
            return this._validateStretch(n.stretchX, c && c.width) || (this.fire(new a.k(new Error(`Image "${e}" has invalid "stretchX" value`))), o = !1), this._validateStretch(n.stretchY, c && c.height) || (this.fire(new a.k(new Error(`Image "${e}" has invalid "stretchY" value`))), o = !1), this._validateContent(n.content, n) || (this.fire(new a.k(new Error(`Image "${e}" has invalid "content" value`))), o = !1), o;
          }
          _validateStretch(e, n) {
            if (!e) return !0;
            let o = 0;
            for (const c of e) {
              if (c[0] < o || c[1] < c[0] || n < c[1]) return !1;
              o = c[1];
            }
            return !0;
          }
          _validateContent(e, n) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const o = n.spriteData, c = o && o.width || n.data.width, d = o && o.height || n.data.height;
            return !(e[0] < 0 || c < e[0] || e[1] < 0 || d < e[1] || e[2] < 0 || c < e[2] || e[3] < 0 || d < e[3] || e[2] < e[0] || e[3] < e[1]);
          }
          updateImage(e, n, o = !0) {
            const c = this.getImage(e);
            if (o && (c.data.width !== n.data.width || c.data.height !== n.data.height)) throw new Error(`size mismatch between old image (${c.data.width}x${c.data.height}) and new image (${n.data.width}x${n.data.height}).`);
            n.version = c.version + 1, this.images[e] = n, this.updatedImages[e] = !0;
          }
          removeImage(e) {
            const n = this.images[e];
            delete this.images[e], delete this.patterns[e], n.userImage && n.userImage.onRemove && n.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e) {
            return new Promise((n, o) => {
              let c = !0;
              if (!this.isLoaded()) for (const d of e) this.images[d] || (c = !1);
              this.isLoaded() || c ? n(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: n });
            });
          }
          _getImagesForIds(e) {
            const n = {};
            for (const o of e) {
              let c = this.getImage(o);
              c || (this.fire(new a.l("styleimagemissing", { id: o })), c = this.getImage(o)), c ? n[o] = { data: c.data.clone(), pixelRatio: c.pixelRatio, sdf: c.sdf, version: c.version, stretchX: c.stretchX, stretchY: c.stretchY, content: c.content, textFitWidth: c.textFitWidth, textFitHeight: c.textFitHeight, hasRenderCallback: !!(c.userImage && c.userImage.render) } : a.w(`Image "${o}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return n;
          }
          getPixelSize() {
            const { width: e, height: n } = this.atlasImage;
            return { width: e, height: n };
          }
          getPattern(e) {
            const n = this.patterns[e], o = this.getImage(e);
            if (!o) return null;
            if (n && n.position.version === o.version) return n.position;
            if (n) n.position.version = o.version;
            else {
              const c = { w: o.data.width + 2, h: o.data.height + 2, x: 0, y: 0 }, d = new a.I(c, o);
              this.patterns[e] = { bin: c, position: d };
            }
            return this._updatePatternAtlas(), this.patterns[e].position;
          }
          bind(e) {
            const n = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new a.T(e, this.atlasImage, n.RGBA), this.atlasTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e = [];
            for (const d in this.patterns) e.push(this.patterns[d].bin);
            const { w: n, h: o } = a.p(e), c = this.atlasImage;
            c.resize({ width: n || 1, height: o || 1 });
            for (const d in this.patterns) {
              const { bin: g } = this.patterns[d], v = g.x + 1, x = g.y + 1, M = this.getImage(d).data, C = M.width, k = M.height;
              a.R.copy(M, c, { x: 0, y: 0 }, { x: v, y: x }, { width: C, height: k }), a.R.copy(M, c, { x: 0, y: k - 1 }, { x: v, y: x - 1 }, { width: C, height: 1 }), a.R.copy(M, c, { x: 0, y: 0 }, { x: v, y: x + k }, { width: C, height: 1 }), a.R.copy(M, c, { x: C - 1, y: 0 }, { x: v - 1, y: x }, { width: 1, height: k }), a.R.copy(M, c, { x: 0, y: 0 }, { x: v + C, y: x }, { width: 1, height: k });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e) {
            for (const n of e) {
              if (this.callbackDispatchedThisFrame[n]) continue;
              this.callbackDispatchedThisFrame[n] = !0;
              const o = this.getImage(n);
              o || a.w(`Image with ID: "${n}" was not found`), at(o) && this.updateImage(n, o);
            }
          }
        }
        const Et = 1e20;
        function Ut(h, e, n, o, c, d, g, v, x) {
          for (let M = e; M < e + o; M++) fi(h, n * d + M, d, c, g, v, x);
          for (let M = n; M < n + c; M++) fi(h, M * d + e, 1, o, g, v, x);
        }
        function fi(h, e, n, o, c, d, g) {
          d[0] = 0, g[0] = -1e20, g[1] = Et, c[0] = h[e];
          for (let v = 1, x = 0, M = 0; v < o; v++) {
            c[v] = h[e + v * n];
            const C = v * v;
            do {
              const k = d[x];
              M = (c[v] - c[k] + C - k * k) / (v - k) / 2;
            } while (M <= g[x] && --x > -1);
            x++, d[x] = v, g[x] = M, g[x + 1] = Et;
          }
          for (let v = 0, x = 0; v < o; v++) {
            for (; g[x + 1] < v; ) x++;
            const M = d[x], C = v - M;
            h[e + v * n] = c[M] + C * C;
          }
        }
        class ir {
          constructor(e, n, o) {
            this.requestManager = e, this.localIdeographFontFamily = n, this.entries = {}, this.lang = o;
          }
          setURL(e) {
            this.url = e;
          }
          getGlyphs(e) {
            return a._(this, void 0, void 0, function* () {
              const n = [];
              for (const d in e) for (const g of e[d]) n.push(this._getAndCacheGlyphsPromise(d, g));
              const o = yield Promise.all(n), c = {};
              for (const { stack: d, id: g, glyph: v } of o) c[d] || (c[d] = {}), c[d][g] = v && { id: v.id, bitmap: v.bitmap.clone(), metrics: v.metrics };
              return c;
            });
          }
          _getAndCacheGlyphsPromise(e, n) {
            return a._(this, void 0, void 0, function* () {
              let o = this.entries[e];
              o || (o = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
              let c = o.glyphs[n];
              if (c !== void 0) return { stack: e, id: n, glyph: c };
              if (c = this._tinySDF(o, e, n), c) return o.glyphs[n] = c, { stack: e, id: n, glyph: c };
              const d = Math.floor(n / 256);
              if (256 * d > 65535) throw new Error("glyphs > 65535 not supported");
              if (o.ranges[d]) return { stack: e, id: n, glyph: c };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!o.requests[d]) {
                const v = ir.loadGlyphRange(e, d, this.url, this.requestManager);
                o.requests[d] = v;
              }
              const g = yield o.requests[d];
              for (const v in g) this._doesCharSupportLocalGlyph(+v) || (o.glyphs[+v] = g[+v]);
              return o.ranges[d] = !0, { stack: e, id: n, glyph: g[n] || null };
            });
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || a.u["CJK Unified Ideographs"](e) || a.u["Hangul Syllables"](e) || a.u.Hiragana(e) || a.u.Katakana(e) || a.u["CJK Symbols and Punctuation"](e) || a.u["Halfwidth and Fullwidth Forms"](e));
          }
          _tinySDF(e, n, o) {
            const c = this.localIdeographFontFamily;
            if (!c || !this._doesCharSupportLocalGlyph(o)) return;
            let d = e.tinySDF;
            if (!d) {
              let v = "400";
              /bold/i.test(n) ? v = "900" : /medium/i.test(n) ? v = "500" : /light/i.test(n) && (v = "200"), d = e.tinySDF = new ir.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, lang: this.lang, fontFamily: c, fontWeight: v });
            }
            const g = d.draw(String.fromCharCode(o));
            return { id: o, bitmap: new a.q({ width: g.width || 60, height: g.height || 60 }, g.data), metrics: { width: g.glyphWidth / 2 || 24, height: g.glyphHeight / 2 || 24, left: g.glyphLeft / 2 + 0.5 || 0, top: g.glyphTop / 2 - 27.5 || -8, advance: g.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
          }
        }
        ir.loadGlyphRange = function(h, e, n, o) {
          return a._(this, void 0, void 0, function* () {
            const c = 256 * e, d = c + 255, g = o.transformRequest(n.replace("{fontstack}", h).replace("{range}", `${c}-${d}`), "Glyphs"), v = yield a.n(g, new AbortController());
            if (!v || !v.data) throw new Error(`Could not load glyph range. range: ${e}, ${c}-${d}`);
            const x = {};
            for (const M of a.o(v.data)) x[M.id] = M;
            return x;
          });
        }, ir.TinySDF = class {
          constructor({ fontSize: h = 24, buffer: e = 3, radius: n = 8, cutoff: o = 0.25, fontFamily: c = "sans-serif", fontWeight: d = "normal", fontStyle: g = "normal", lang: v = null } = {}) {
            this.buffer = e, this.cutoff = o, this.radius = n, this.lang = v;
            const x = this.size = h + 4 * e, M = this._createCanvas(x), C = this.ctx = M.getContext("2d", { willReadFrequently: !0 });
            C.font = `${g} ${d} ${h}px ${c}`, C.textBaseline = "alphabetic", C.textAlign = "left", C.fillStyle = "black", this.gridOuter = new Float64Array(x * x), this.gridInner = new Float64Array(x * x), this.f = new Float64Array(x), this.z = new Float64Array(x + 1), this.v = new Uint16Array(x);
          }
          _createCanvas(h) {
            const e = document.createElement("canvas");
            return e.width = e.height = h, e;
          }
          draw(h) {
            const { width: e, actualBoundingBoxAscent: n, actualBoundingBoxDescent: o, actualBoundingBoxLeft: c, actualBoundingBoxRight: d } = this.ctx.measureText(h), g = Math.ceil(n), v = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(d - c))), x = Math.min(this.size - this.buffer, g + Math.ceil(o)), M = v + 2 * this.buffer, C = x + 2 * this.buffer, k = Math.max(M * C, 0), A = new Uint8ClampedArray(k), R = { data: A, width: M, height: C, glyphWidth: v, glyphHeight: x, glyphTop: g, glyphLeft: 0, glyphAdvance: e };
            if (v === 0 || x === 0) return R;
            const { ctx: O, buffer: G, gridInner: Z, gridOuter: q } = this;
            this.lang && (O.lang = this.lang), O.clearRect(G, G, v, x), O.fillText(h, G, G + g);
            const W = O.getImageData(G, G, v, x);
            q.fill(Et, 0, k), Z.fill(0, 0, k);
            for (let J = 0; J < x; J++) for (let K = 0; K < v; K++) {
              const te = W.data[4 * (J * v + K) + 3] / 255;
              if (te === 0) continue;
              const se = (J + G) * M + K + G;
              if (te === 1) q[se] = 0, Z[se] = Et;
              else {
                const Y = 0.5 - te;
                q[se] = Y > 0 ? Y * Y : 0, Z[se] = Y < 0 ? Y * Y : 0;
              }
            }
            Ut(q, 0, 0, M, C, M, this.f, this.v, this.z), Ut(Z, G, G, v, x, M, this.f, this.v, this.z);
            for (let J = 0; J < k; J++) {
              const K = Math.sqrt(q[J]) - Math.sqrt(Z[J]);
              A[J] = Math.round(255 - 255 * (K / this.radius + this.cutoff));
            }
            return R;
          }
        };
        class Jr {
          constructor() {
            this.specification = a.v.light.position;
          }
          possiblyEvaluate(e, n) {
            return a.B(e.expression.evaluate(n));
          }
          interpolate(e, n, o) {
            return { x: a.C.number(e.x, n.x, o), y: a.C.number(e.y, n.y, o), z: a.C.number(e.z, n.z, o) };
          }
        }
        let Gr;
        class ti extends a.E {
          constructor(e) {
            super(), Gr = Gr || new a.r({ anchor: new a.D(a.v.light.anchor), position: new Jr(), color: new a.D(a.v.light.color), intensity: new a.D(a.v.light.intensity) }), this._transitionable = new a.t(Gr), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e, n = {}) {
            if (!this._validate(a.x, e, n)) for (const o in e) {
              const c = e[o];
              o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), c) : this._transitionable.setValue(o, c);
            }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, n, o) {
            return (!o || o.validate !== !1) && a.y(this, e.call(a.z, { value: n, style: { glyphs: !0, sprite: !0 }, styleSpec: a.v }));
          }
        }
        const At = new a.r({ "sky-color": new a.D(a.v.sky["sky-color"]), "horizon-color": new a.D(a.v.sky["horizon-color"]), "fog-color": new a.D(a.v.sky["fog-color"]), "fog-ground-blend": new a.D(a.v.sky["fog-ground-blend"]), "horizon-fog-blend": new a.D(a.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new a.D(a.v.sky["sky-horizon-blend"]), "atmosphere-blend": new a.D(a.v.sky["atmosphere-blend"]) });
        class Jt extends a.E {
          constructor(e) {
            super(), this._transitionable = new a.t(At), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new a.F(0));
          }
          setSky(e, n = {}) {
            if (!this._validate(a.G, e, n)) {
              e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const o in e) {
                const c = e[o];
                o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), c) : this._transitionable.setValue(o, c);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, n, o = {}) {
            return (o == null ? void 0 : o.validate) !== !1 && a.y(this, e.call(a.z, a.e({ value: n, style: { glyphs: !0, sprite: !0 }, styleSpec: a.v })));
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
          }
        }
        class Zt {
          constructor(e, n) {
            this.width = e, this.height = n, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e, n) {
            const o = e.join(",") + String(n);
            return this.dashEntry[o] || (this.dashEntry[o] = this.addDash(e, n)), this.dashEntry[o];
          }
          getDashRanges(e, n, o) {
            const c = [];
            let d = e.length % 2 == 1 ? -e[e.length - 1] * o : 0, g = e[0] * o, v = !0;
            c.push({ left: d, right: g, isDash: v, zeroLength: e[0] === 0 });
            let x = e[0];
            for (let M = 1; M < e.length; M++) {
              v = !v;
              const C = e[M];
              d = x * o, x += C, g = x * o, c.push({ left: d, right: g, isDash: v, zeroLength: C === 0 });
            }
            return c;
          }
          addRoundDash(e, n, o) {
            const c = n / 2;
            for (let d = -o; d <= o; d++) {
              const g = this.width * (this.nextRow + o + d);
              let v = 0, x = e[v];
              for (let M = 0; M < this.width; M++) {
                M / x.right > 1 && (x = e[++v]);
                const C = Math.abs(M - x.left), k = Math.abs(M - x.right), A = Math.min(C, k);
                let R;
                const O = d / o * (c + 1);
                if (x.isDash) {
                  const G = c - Math.abs(O);
                  R = Math.sqrt(A * A + G * G);
                } else R = c - Math.sqrt(A * A + O * O);
                this.data[g + M] = Math.max(0, Math.min(255, R + 128));
              }
            }
          }
          addRegularDash(e) {
            for (let v = e.length - 1; v >= 0; --v) {
              const x = e[v], M = e[v + 1];
              x.zeroLength ? e.splice(v, 1) : M && M.isDash === x.isDash && (M.left = x.left, e.splice(v, 1));
            }
            const n = e[0], o = e[e.length - 1];
            n.isDash === o.isDash && (n.left = o.left - this.width, o.right = n.right + this.width);
            const c = this.width * this.nextRow;
            let d = 0, g = e[d];
            for (let v = 0; v < this.width; v++) {
              v / g.right > 1 && (g = e[++d]);
              const x = Math.abs(v - g.left), M = Math.abs(v - g.right), C = Math.min(x, M);
              this.data[c + v] = Math.max(0, Math.min(255, (g.isDash ? C : -C) + 128));
            }
          }
          addDash(e, n) {
            const o = n ? 7 : 0, c = 2 * o + 1;
            if (this.nextRow + c > this.height) return a.w("LineAtlas out of space"), null;
            let d = 0;
            for (let v = 0; v < e.length; v++) d += e[v];
            if (d !== 0) {
              const v = this.width / d, x = this.getDashRanges(e, this.width, v);
              n ? this.addRoundDash(x, v, o) : this.addRegularDash(x);
            }
            const g = { y: (this.nextRow + o + 0.5) / this.height, height: 2 * o / this.height, width: d };
            return this.nextRow += c, this.dirty = !0, g;
          }
          bind(e) {
            const n = e.gl;
            this.texture ? (n.bindTexture(n.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, this.width, this.height, n.ALPHA, n.UNSIGNED_BYTE, this.data))) : (this.texture = n.createTexture(), n.bindTexture(n.TEXTURE_2D, this.texture), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.REPEAT), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.REPEAT), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR), n.texImage2D(n.TEXTURE_2D, 0, n.ALPHA, this.width, this.height, 0, n.ALPHA, n.UNSIGNED_BYTE, this.data));
          }
        }
        const qr = "maplibre_preloaded_worker_pool";
        class mi {
          constructor() {
            this.active = {};
          }
          acquire(e) {
            if (!this.workers) for (this.workers = []; this.workers.length < mi.workerCount; ) this.workers.push(new Worker(a.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice();
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((n) => {
              n.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[qr];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const Gi = Math.floor(we.hardwareConcurrency / 2);
        let Dr, vn;
        function Cn() {
          return Dr || (Dr = new mi()), Dr;
        }
        mi.workerCount = a.H(globalThis) ? Math.max(Math.min(Gi, 3), 1) : 1;
        class zi {
          constructor(e, n) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = n;
            const o = this.workerPool.acquire(n);
            for (let c = 0; c < o.length; c++) {
              const d = new a.J(o[c], n);
              d.name = `Worker ${c}`, this.actors.push(d);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e, n) {
            const o = [];
            for (const c of this.actors) o.push(c.sendAsync({ type: e, data: n }));
            return Promise.all(o);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e = !0) {
            this.actors.forEach((n) => {
              n.remove();
            }), this.actors = [], e && this.workerPool.release(this.id);
          }
          registerMessageHandler(e, n) {
            for (const o of this.actors) o.registerMessageHandler(e, n);
          }
        }
        function Qr() {
          return vn || (vn = new zi(Cn(), a.K), vn.registerMessageHandler("GR", (h, e, n) => a.m(e, n))), vn;
        }
        function ur(h, e) {
          const n = a.L();
          return a.M(n, n, [1, 1, 0]), a.N(n, n, [0.5 * h.width, 0.5 * h.height, 1]), h.calculatePosMatrix ? a.O(n, n, h.calculatePosMatrix(e.toUnwrapped())) : n;
        }
        function Mr(h, e, n, o, c, d, g) {
          var v;
          const x = function(A, R, O) {
            if (A) for (const G of A) {
              const Z = R[G];
              if (Z && Z.source === O && Z.type === "fill-extrusion") return !0;
            }
            else for (const G in R) {
              const Z = R[G];
              if (Z.source === O && Z.type === "fill-extrusion") return !0;
            }
            return !1;
          }((v = c == null ? void 0 : c.layers) !== null && v !== void 0 ? v : null, e, h.id), M = d.maxPitchScaleFactor(), C = h.tilesIn(o, M, x);
          C.sort(Hr);
          const k = [];
          for (const A of C) k.push({ wrappedTileID: A.tileID.wrapped().key, queryResults: A.tile.queryRenderedFeatures(e, n, h._state, A.queryGeometry, A.cameraQueryGeometry, A.scale, c, d, M, ur(h.transform, A.tileID), g ? (R, O) => g(A.tileID, R, O) : void 0) });
          return function(A, R) {
            for (const O in A) for (const G of A[O]) hs(G, R);
            return A;
          }(function(A) {
            const R = {}, O = {};
            for (const G of A) {
              const Z = G.queryResults, q = G.wrappedTileID, W = O[q] = O[q] || {};
              for (const J in Z) {
                const K = Z[J], te = W[J] = W[J] || {}, se = R[J] = R[J] || [];
                for (const Y of K) te[Y.featureIndex] || (te[Y.featureIndex] = !0, se.push(Y));
              }
            }
            return R;
          }(k), h);
        }
        function Hr(h, e) {
          const n = h.tileID, o = e.tileID;
          return n.overscaledZ - o.overscaledZ || n.canonical.y - o.canonical.y || n.wrap - o.wrap || n.canonical.x - o.canonical.x;
        }
        function hs(h, e) {
          const n = h.feature, o = e.getFeatureState(n.layer["source-layer"], n.id);
          n.source = n.layer.source, n.layer["source-layer"] && (n.sourceLayer = n.layer["source-layer"]), n.state = o;
        }
        function ne(h, e, n) {
          return a._(this, void 0, void 0, function* () {
            let o = h;
            if (h.url ? o = (yield a.j(e.transformRequest(h.url, "Source"), n)).data : yield we.frameAsync(n), !o) return null;
            const c = a.Q(a.e(o, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in o && o.vector_layers && (c.vectorLayerIds = o.vector_layers.map((d) => d.id)), c;
          });
        }
        class ae {
          constructor(e, n) {
            e && (n ? this.setSouthWest(e).setNorthEast(n) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
          }
          setNorthEast(e) {
            return this._ne = e instanceof a.S ? new a.S(e.lng, e.lat) : a.S.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof a.S ? new a.S(e.lng, e.lat) : a.S.convert(e), this;
          }
          extend(e) {
            const n = this._sw, o = this._ne;
            let c, d;
            if (e instanceof a.S) c = e, d = e;
            else {
              if (!(e instanceof ae)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(ae.convert(e)) : this.extend(a.S.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(a.S.convert(e)) : this;
              if (c = e._sw, d = e._ne, !c || !d) return this;
            }
            return n || o ? (n.lng = Math.min(c.lng, n.lng), n.lat = Math.min(c.lat, n.lat), o.lng = Math.max(d.lng, o.lng), o.lat = Math.max(d.lat, o.lat)) : (this._sw = new a.S(c.lng, c.lat), this._ne = new a.S(d.lng, d.lat)), this;
          }
          getCenter() {
            return new a.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new a.S(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new a.S(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: n, lat: o } = a.S.convert(e);
            let c = this._sw.lng <= n && n <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (c = this._sw.lng >= n && n >= this._ne.lng), this._sw.lat <= o && o <= this._ne.lat && c;
          }
          static convert(e) {
            return e instanceof ae ? e : e && new ae(e);
          }
          static fromLngLat(e, n = 0) {
            const o = 360 * n / 40075017, c = o / Math.cos(Math.PI / 180 * e.lat);
            return new ae(new a.S(e.lng - c, e.lat - o), new a.S(e.lng + c, e.lat + o));
          }
          adjustAntiMeridian() {
            const e = new a.S(this._sw.lng, this._sw.lat), n = new a.S(this._ne.lng, this._ne.lat);
            return new ae(e, e.lng > n.lng ? new a.S(n.lng + 360, n.lat) : n);
          }
        }
        class Se {
          constructor(e, n, o) {
            this.bounds = ae.convert(this.validateBounds(e)), this.minzoom = n || 0, this.maxzoom = o || 24;
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
          }
          contains(e) {
            const n = Math.pow(2, e.z), o = Math.floor(a.V(this.bounds.getWest()) * n), c = Math.floor(a.U(this.bounds.getNorth()) * n), d = Math.ceil(a.V(this.bounds.getEast()) * n), g = Math.ceil(a.U(this.bounds.getSouth()) * n);
            return e.x >= o && e.x < d && e.y >= c && e.y < g;
          }
        }
        class ze extends a.E {
          constructor(e, n, o, c) {
            if (super(), this.id = e, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, a.e(this, a.Q(n, ["url", "scheme", "tileSize", "promoteId"])), this._options = a.e({ type: "vector" }, n), this._collectResourceTiming = n.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(c);
          }
          load() {
            return a._(this, void 0, void 0, function* () {
              this._loaded = !1, this.fire(new a.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const e = yield ne(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (a.e(this, e), e.bounds && (this.tileBounds = new Se(e.bounds, this.minzoom, this.maxzoom)), this.fire(new a.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new a.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (e) {
                this._tileJSONRequest = null, this.fire(new a.k(e));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
          }
          setTiles(e) {
            return this.setSourceProperty(() => {
              this._options.tiles = e;
            }), this;
          }
          setUrl(e) {
            return this.setSourceProperty(() => {
              this.url = e, this._options.url = e;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return a.e({}, this._options);
          }
          loadTile(e) {
            return a._(this, void 0, void 0, function* () {
              const n = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), o = { request: this.map._requestManager.transformRequest(n, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              o.request.collectResourceTiming = this._collectResourceTiming;
              let c = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise((d, g) => {
                  e.reloadPromise = { resolve: d, reject: g };
                });
              } else e.actor = this.dispatcher.getActor(), c = "LT";
              e.abortController = new AbortController();
              try {
                const d = yield e.actor.sendAsync({ type: c, data: o }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, d);
              } catch (d) {
                if (delete e.abortController, e.aborted) return;
                if (d && d.status !== 404) throw d;
                this._afterTileLoadWorkerResponse(e, null);
              }
            });
          }
          _afterTileLoadWorkerResponse(e, n) {
            if (n && n.resourceTiming && (e.resourceTiming = n.resourceTiming), n && this.map._refreshExpiredTiles && e.setExpiryData(n), e.loadVectorData(n, this.map.painter), e.reloadPromise) {
              const o = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(o.resolve).catch(o.reject);
            }
          }
          abortTile(e) {
            return a._(this, void 0, void 0, function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
            });
          }
          unloadTile(e) {
            return a._(this, void 0, void 0, function* () {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class Ae extends a.E {
          constructor(e, n, o, c) {
            super(), this.id = e, this.dispatcher = o, this.setEventedParent(c), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = a.e({ type: "raster" }, n), a.e(this, a.Q(n, ["url", "scheme", "tileSize"]));
          }
          load() {
            return a._(this, arguments, void 0, function* (e = !1) {
              this._loaded = !1, this.fire(new a.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const n = yield ne(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, n && (a.e(this, n), n.bounds && (this.tileBounds = new Se(n.bounds, this.minzoom, this.maxzoom)), this.fire(new a.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new a.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e })));
              } catch (n) {
                this._tileJSONRequest = null, this.fire(new a.k(n));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0);
          }
          setTiles(e) {
            return this.setSourceProperty(() => {
              this._options.tiles = e;
            }), this;
          }
          setUrl(e) {
            return this.setSourceProperty(() => {
              this.url = e, this._options.url = e;
            }), this;
          }
          serialize() {
            return a.e({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(e) {
            return a._(this, void 0, void 0, function* () {
              const n = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController();
              try {
                const o = yield Qe.getImage(this.map._requestManager.transformRequest(n, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (o && o.data) {
                  this.map._refreshExpiredTiles && (o.cacheControl || o.expires) && e.setExpiryData({ cacheControl: o.cacheControl, expires: o.expires });
                  const c = this.map.painter.context, d = c.gl, g = o.data;
                  e.texture = this.map.painter.getTileTexture(g.width), e.texture ? e.texture.update(g, { useMipmap: !0 }) : (e.texture = new a.T(c, g, d.RGBA, { useMipmap: !0 }), e.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
                }
              } catch (o) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (o) throw e.state = "errored", o;
              }
            });
          }
          abortTile(e) {
            return a._(this, void 0, void 0, function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController);
            });
          }
          unloadTile(e) {
            return a._(this, void 0, void 0, function* () {
              e.texture && this.map.painter.saveTileTexture(e.texture);
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class Re extends Ae {
          constructor(e, n, o, c) {
            super(e, n, o, c), this.type = "raster-dem", this.maxzoom = 22, this._options = a.e({ type: "raster-dem" }, n), this.encoding = n.encoding || "mapbox", this.redFactor = n.redFactor, this.greenFactor = n.greenFactor, this.blueFactor = n.blueFactor, this.baseShift = n.baseShift;
          }
          loadTile(e) {
            return a._(this, void 0, void 0, function* () {
              const n = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), o = this.map._requestManager.transformRequest(n, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
              try {
                const c = yield Qe.getImage(o, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (c && c.data) {
                  const d = c.data;
                  this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({ cacheControl: c.cacheControl, expires: c.expires });
                  const g = a.b(d) && a.W() ? d : yield this.readImageNow(d), v = { type: this.type, uid: e.uid, source: this.id, rawImageData: g, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const x = yield e.actor.sendAsync({ type: "LDT", data: v });
                    e.dem = x, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded";
                  }
                }
              } catch (c) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (c) throw e.state = "errored", c;
              }
            });
          }
          readImageNow(e) {
            return a._(this, void 0, void 0, function* () {
              if (typeof VideoFrame < "u" && a.X()) {
                const n = e.width + 2, o = e.height + 2;
                try {
                  return new a.R({ width: n, height: o }, yield a.Y(e, -1, -1, n, o));
                } catch {
                }
              }
              return we.getImageData(e, 1);
            });
          }
          _getNeighboringTiles(e) {
            const n = e.canonical, o = Math.pow(2, n.z), c = (n.x - 1 + o) % o, d = n.x === 0 ? e.wrap - 1 : e.wrap, g = (n.x + 1 + o) % o, v = n.x + 1 === o ? e.wrap + 1 : e.wrap, x = {};
            return x[new a.Z(e.overscaledZ, d, n.z, c, n.y).key] = { backfilled: !1 }, x[new a.Z(e.overscaledZ, v, n.z, g, n.y).key] = { backfilled: !1 }, n.y > 0 && (x[new a.Z(e.overscaledZ, d, n.z, c, n.y - 1).key] = { backfilled: !1 }, x[new a.Z(e.overscaledZ, e.wrap, n.z, n.x, n.y - 1).key] = { backfilled: !1 }, x[new a.Z(e.overscaledZ, v, n.z, g, n.y - 1).key] = { backfilled: !1 }), n.y + 1 < o && (x[new a.Z(e.overscaledZ, d, n.z, c, n.y + 1).key] = { backfilled: !1 }, x[new a.Z(e.overscaledZ, e.wrap, n.z, n.x, n.y + 1).key] = { backfilled: !1 }, x[new a.Z(e.overscaledZ, v, n.z, g, n.y + 1).key] = { backfilled: !1 }), x;
          }
          unloadTile(e) {
            return a._(this, void 0, void 0, function* () {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
            });
          }
        }
        class He extends a.E {
          constructor(e, n, o, c) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: n.data }, this.actor = o.getActor(), this.setEventedParent(c), this._data = n.data, this._options = a.e({}, n), this._collectResourceTiming = n.collectResourceTiming, n.maxzoom !== void 0 && (this.maxzoom = n.maxzoom), n.type && (this.type = n.type), n.attribution && (this.attribution = n.attribution), this.promoteId = n.promoteId, n.clusterMaxZoom !== void 0 && this.maxzoom <= n.clusterMaxZoom && a.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${n.clusterMaxZoom}".`), this.workerOptions = a.e({ source: this.id, cluster: n.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(n.buffer !== void 0 ? n.buffer : 128), tolerance: this._pixelsToTileUnits(n.tolerance !== void 0 ? n.tolerance : 0.375), extent: a.$, maxZoom: this.maxzoom, lineMetrics: n.lineMetrics || !1, generateId: n.generateId || !1 }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(n.clusterMaxZoom), minPoints: Math.max(2, n.clusterMinPoints || 2), extent: a.$, radius: this._pixelsToTileUnits(n.clusterRadius || 50), log: !1, generateId: n.generateId || !1 }, clusterProperties: n.clusterProperties, filter: n.filter }, n.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _pixelsToTileUnits(e) {
            return e * (a.$ / this.tileSize);
          }
          _getClusterMaxZoom(e) {
            const n = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || a.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${n}"`), n;
          }
          load() {
            return a._(this, void 0, void 0, function* () {
              yield this._updateWorkerData();
            });
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = { data: e }, this._updateWorkerData(), this;
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = a.a0(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this;
          }
          getData() {
            return a._(this, void 0, void 0, function* () {
              const e = a.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e });
            });
          }
          getCoordinatesFromGeometry(e) {
            return e.type === "GeometryCollection" ? e.geometries.map((n) => n.coordinates).flat(1 / 0) : e.coordinates.flat(1 / 0);
          }
          getBounds() {
            return a._(this, void 0, void 0, function* () {
              const e = new ae(), n = yield this.getData();
              let o;
              switch (n.type) {
                case "FeatureCollection":
                  o = n.features.map((c) => this.getCoordinatesFromGeometry(c.geometry)).flat(1 / 0);
                  break;
                case "Feature":
                  o = this.getCoordinatesFromGeometry(n.geometry);
                  break;
                default:
                  o = this.getCoordinatesFromGeometry(n);
              }
              if (o.length == 0) return e;
              for (let c = 0; c < o.length - 1; c += 2) e.extend([o[c], o[c + 1]]);
              return e;
            });
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterLeaves(e, n, o) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: n, offset: o } });
          }
          _updateWorkerData() {
            return a._(this, void 0, void 0, function* () {
              if (this._isUpdatingWorker) return;
              const { data: e, diff: n } = this._pendingWorkerUpdate;
              if (!e && !n) return void a.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
              const o = a.e({ type: this.type }, this.workerOptions);
              e ? (typeof e == "string" ? (o.request = this.map._requestManager.transformRequest(we.resolveURL(e), "Source"), o.request.collectResourceTiming = this._collectResourceTiming) : o.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : n && (o.dataDiff = n, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = !0, this.fire(new a.l("dataloading", { dataType: "source" }));
              try {
                const c = yield this.actor.sendAsync({ type: "LD", data: o });
                if (this._isUpdatingWorker = !1, this._removed || c.abandoned) return void this.fire(new a.l("dataabort", { dataType: "source" }));
                this._data = c.data;
                let d = null;
                c.resourceTiming && c.resourceTiming[this.id] && (d = c.resourceTiming[this.id].slice(0));
                const g = { dataType: "source" };
                this._collectResourceTiming && d && d.length > 0 && a.e(g, { resourceTiming: d }), this.fire(new a.l("data", Object.assign(Object.assign({}, g), { sourceDataType: "metadata" }))), this.fire(new a.l("data", Object.assign(Object.assign({}, g), { sourceDataType: "content" })));
              } catch (c) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new a.l("dataabort", { dataType: "source" }));
                this.fire(new a.k(c));
              } finally {
                (this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData();
              }
            });
          }
          loaded() {
            return !this._isUpdatingWorker && this._pendingWorkerUpdate.data === void 0 && this._pendingWorkerUpdate.diff === void 0;
          }
          loadTile(e) {
            return a._(this, void 0, void 0, function* () {
              const n = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const o = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              e.abortController = new AbortController();
              const c = yield this.actor.sendAsync({ type: n, data: o }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(c, this.map.painter, n === "RT");
            });
          }
          abortTile(e) {
            return a._(this, void 0, void 0, function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0;
            });
          }
          unloadTile(e) {
            return a._(this, void 0, void 0, function* () {
              e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
            });
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return a.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return !1;
          }
        }
        class Ue extends a.E {
          constructor(e, n, o, c) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = o, this.coordinates = n.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(c), this.options = n;
          }
          load(e) {
            return a._(this, void 0, void 0, function* () {
              this._loaded = !1, this.fire(new a.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const n = yield Qe.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, n && n.data && (this.image = n.data, e && (this.coordinates = e), this._finishLoading());
              } catch (n) {
                this._request = null, this._loaded = !0, this.fire(new a.k(n));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally(() => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new a.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(e) {
            this.coordinates = e;
            const n = e.map(a.a1.fromLngLat);
            var o;
            return this.tileID = function(c) {
              const d = a.a2.fromPoints(c), g = d.width(), v = d.height(), x = Math.max(g, v), M = Math.max(0, Math.floor(-Math.log(x) / Math.LN2)), C = Math.pow(2, M);
              return new a.a4(M, Math.floor((d.minX + d.maxX) / 2 * C), Math.floor((d.minY + d.maxY) / 2 * C));
            }(n), this.terrainTileRanges = this._getOverlappingTileRanges(n), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = n.map((c) => this.tileID.getTilePoint(c)._round()), this.flippedWindingOrder = ((o = this.tileCoords)[1].x - o[0].x) * (o[2].y - o[0].y) - (o[1].y - o[0].y) * (o[2].x - o[0].x) < 0, this.fire(new a.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context, n = e.gl;
            this.texture || (this.texture = new a.T(e, this.image, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
            let o = !1;
            for (const c in this.tiles) {
              const d = this.tiles[c];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, o = !0);
            }
            o && this.fire(new a.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(e) {
            return a._(this, void 0, void 0, function* () {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
            });
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
          _getOverlappingTileRanges(e) {
            const { minX: n, minY: o, maxX: c, maxY: d } = a.a2.fromPoints(e), g = {};
            for (let v = 0; v <= a.a3; v++) {
              const x = Math.pow(2, v), M = Math.floor(n * x), C = Math.floor(o * x), k = Math.floor(c * x), A = Math.floor(d * x);
              g[v] = { minTileX: M, minTileY: C, maxTileX: k, maxTileY: A };
            }
            return g;
          }
        }
        class Ge extends Ue {
          constructor(e, n, o, c) {
            super(e, n, o, c), this.roundZoom = !0, this.type = "video", this.options = n;
          }
          load() {
            return a._(this, void 0, void 0, function* () {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const n of e.urls) this.urls.push(this.map._requestManager.transformRequest(n, "Source").url);
              try {
                const n = yield a.a5(this.urls);
                if (this._loaded = !0, !n) return;
                this.video = n, this.video.loop = !0, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading();
              } catch (n) {
                this.fire(new a.k(n));
              }
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e) {
            if (this.video) {
              const n = this.video.seekable;
              e < n.start(0) || e > n.end(0) ? this.fire(new a.k(new a.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${n.start(0)} and ${n.end(0)}-second mark.`))) : this.video.currentTime = e;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context, n = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, this.video)) : (this.texture = new a.T(e, this.video, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
            let o = !1;
            for (const c in this.tiles) {
              const d = this.tiles[c];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, o = !0);
            }
            o && this.fire(new a.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class De extends Ue {
          constructor(e, n, o, c) {
            super(e, n, o, c), n.coordinates ? Array.isArray(n.coordinates) && n.coordinates.length === 4 && !n.coordinates.some((d) => !Array.isArray(d) || d.length !== 2 || d.some((g) => typeof g != "number")) || this.fire(new a.k(new a.a6(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new a.k(new a.a6(`sources.${e}`, null, 'missing required property "coordinates"'))), n.animate && typeof n.animate != "boolean" && this.fire(new a.k(new a.a6(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), n.canvas ? typeof n.canvas == "string" || n.canvas instanceof HTMLCanvasElement || this.fire(new a.k(new a.a6(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new a.k(new a.a6(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = n, this.animate = n.animate === void 0 || n.animate;
          }
          load() {
            return a._(this, void 0, void 0, function* () {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new a.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1);
              }, this._finishLoading());
            });
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const n = this.map.painter.context, o = n.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new a.T(n, this.canvas, o.RGBA, { premultiply: !0 });
            let c = !1;
            for (const d in this.tiles) {
              const g = this.tiles[d];
              g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, c = !0);
            }
            c && this.fire(new a.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
            return !1;
          }
        }
        const ht = {}, Ye = (h) => {
          switch (h) {
            case "geojson":
              return He;
            case "image":
              return Ue;
            case "raster":
              return Ae;
            case "raster-dem":
              return Re;
            case "vector":
              return ze;
            case "video":
              return Ge;
            case "canvas":
              return De;
          }
          return ht[h];
        }, ct = "RTLPluginLoaded";
        class gt extends a.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Qr();
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch((n) => {
              throw this.status = "error", n;
            });
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(e) {
            return a._(this, arguments, void 0, function* (n, o = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = we.resolveURL(n), !this.url) throw new Error(`requested url ${n} is invalid`);
              if (this.status === "unavailable") {
                if (!o) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            });
          }
          _requestImport() {
            return a._(this, void 0, void 0, function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new a.l(ct));
            });
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let zt = null;
        function Wt() {
          return zt || (zt = new gt()), zt;
        }
        class Ht {
          constructor(e, n) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = a.a7(), this.uses = 0, this.tileSize = n, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(e) {
            const n = e + this.timeAdded;
            n < this.fadeEndTime || (this.fadeEndTime = n);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e, n, o) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function(c, d) {
                const g = {};
                if (!d) return g;
                for (const v of c) {
                  const x = v.layerIds.map((M) => d.getLayer(M)).filter(Boolean);
                  if (x.length !== 0) {
                    v.layers = x, v.stateDependentLayerIds && (v.stateDependentLayers = v.stateDependentLayerIds.map((M) => x.filter((C) => C.id === M)[0]));
                    for (const M of x) g[M.id] = v;
                  }
                }
                return g;
              }(e.buckets, n == null ? void 0 : n.style), this.hasSymbolBuckets = !1;
              for (const c in this.buckets) {
                const d = this.buckets[c];
                if (d instanceof a.a9) {
                  if (this.hasSymbolBuckets = !0, !o) break;
                  d.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const c in this.buckets) {
                const d = this.buckets[c];
                if (d instanceof a.a9 && d.hasRTLText) {
                  this.hasRTLText = !0, Wt().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const c in this.buckets) {
                const d = this.buckets[c];
                this.queryPadding = Math.max(this.queryPadding, n.style.getLayer(c).queryRadius(d));
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
            } else this.collisionBoxArray = new a.a8();
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e) {
            return this.buckets[e.id];
          }
          upload(e) {
            for (const o in this.buckets) {
              const c = this.buckets[o];
              c.uploadPending() && c.upload(e);
            }
            const n = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new a.T(e, this.imageAtlas.image, n.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new a.T(e, this.glyphAtlasImage, n.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e, n, o, c, d, g, v, x, M, C, k) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: c, cameraQueryGeometry: d, scale: g, tileSize: this.tileSize, pixelPosMatrix: C, transform: x, params: v, queryPadding: this.queryPadding * M, getElevation: k }, e, n, o) : {};
          }
          querySourceFeatures(e, n) {
            const o = this.latestFeatureIndex;
            if (!o || !o.rawTileData) return;
            const c = o.loadVTLayers(), d = n && n.sourceLayer ? n.sourceLayer : "", g = c._geojsonTileLayer || c[d];
            if (!g) return;
            const v = a.aa(n && n.filter), { z: x, x: M, y: C } = this.tileID.canonical, k = { z: x, x: M, y: C };
            for (let A = 0; A < g.length; A++) {
              const R = g.feature(A);
              if (v.needGeometry) {
                const Z = a.ab(R, !0);
                if (!v.filter(new a.F(this.tileID.overscaledZ), Z, this.tileID.canonical)) continue;
              } else if (!v.filter(new a.F(this.tileID.overscaledZ), R)) continue;
              const O = o.getId(R, d), G = new a.ac(R, x, M, C, O);
              G.tile = k, e.push(G);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e) {
            const n = this.expirationTime;
            if (e.cacheControl) {
              const o = a.ad(e.cacheControl);
              o["max-age"] && (this.expirationTime = Date.now() + 1e3 * o["max-age"]);
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const o = Date.now();
              let c = !1;
              if (this.expirationTime > o) c = !1;
              else if (n) if (this.expirationTime < n) c = !0;
              else {
                const d = this.expirationTime - n;
                d ? this.expirationTime = o + Math.max(d, 3e4) : c = !0;
              }
              else c = !0;
              c ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e, n) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const o = this.latestFeatureIndex.loadVTLayers();
            for (const c in this.buckets) {
              if (!n.style.hasLayer(c)) continue;
              const d = this.buckets[c], g = d.layers[0].sourceLayer || "_geojsonTileLayer", v = o[g], x = e[g];
              if (!v || !x || Object.keys(x).length === 0) continue;
              d.update(x, v, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const M = n && n.style && n.style.getLayer(c);
              M && (this.queryPadding = Math.max(this.queryPadding, M.queryRadius(d)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < we.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = we.now() + e;
          }
          setDependencies(e, n) {
            const o = {};
            for (const c of n) o[c] = !0;
            this.dependencies[e] = o;
          }
          hasDependency(e, n) {
            for (const o of e) {
              const c = this.dependencies[o];
              if (c) {
                for (const d of n) if (c[d]) return !0;
              }
            }
            return !1;
          }
        }
        class oe {
          constructor(e, n) {
            this.max = e, this.onRemove = n, this.reset();
          }
          reset() {
            for (const e in this.data) for (const n of this.data[e]) n.timeout && clearTimeout(n.timeout), this.onRemove(n.value);
            return this.data = {}, this.order = [], this;
          }
          add(e, n, o) {
            const c = e.wrapped().key;
            this.data[c] === void 0 && (this.data[c] = []);
            const d = { value: n, timeout: void 0 };
            if (o !== void 0 && (d.timeout = setTimeout(() => {
              this.remove(e, d);
            }, o)), this.data[c].push(d), this.order.push(c), this.order.length > this.max) {
              const g = this._getAndRemoveByKey(this.order[0]);
              g && this.onRemove(g);
            }
            return this;
          }
          has(e) {
            return e.wrapped().key in this.data;
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
          }
          _getAndRemoveByKey(e) {
            const n = this.data[e].shift();
            return n.timeout && clearTimeout(n.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), n.value;
          }
          getByKey(e) {
            const n = this.data[e];
            return n ? n[0].value : null;
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null;
          }
          remove(e, n) {
            if (!this.has(e)) return this;
            const o = e.wrapped().key, c = n === void 0 ? 0 : this.data[o].indexOf(n), d = this.data[o][c];
            return this.data[o].splice(c, 1), d.timeout && clearTimeout(d.timeout), this.data[o].length === 0 && delete this.data[o], this.onRemove(d.value), this.order.splice(this.order.indexOf(o), 1), this;
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max; ) {
              const n = this._getAndRemoveByKey(this.order[0]);
              n && this.onRemove(n);
            }
            return this;
          }
          filter(e) {
            const n = [];
            for (const o in this.data) for (const c of this.data[o]) e(c.value) || n.push(c);
            for (const o of n) this.remove(o.value.tileID, o);
          }
        }
        class B {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e, n, o) {
            const c = String(n);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][c] = this.stateChanges[e][c] || {}, a.e(this.stateChanges[e][c], o), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const d in this.state[e]) d !== c && (this.deletedStates[e][d] = null);
            } else if (this.deletedStates[e] && this.deletedStates[e][c] === null) {
              this.deletedStates[e][c] = {};
              for (const d in this.state[e][c]) o[d] || (this.deletedStates[e][c][d] = null);
            } else for (const d in o) this.deletedStates[e] && this.deletedStates[e][c] && this.deletedStates[e][c][d] === null && delete this.deletedStates[e][c][d];
          }
          removeFeatureState(e, n, o) {
            if (this.deletedStates[e] === null) return;
            const c = String(n);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, o && n !== void 0) this.deletedStates[e][c] !== null && (this.deletedStates[e][c] = this.deletedStates[e][c] || {}, this.deletedStates[e][c][o] = null);
            else if (n !== void 0) if (this.stateChanges[e] && this.stateChanges[e][c]) for (o in this.deletedStates[e][c] = {}, this.stateChanges[e][c]) this.deletedStates[e][c][o] = null;
            else this.deletedStates[e][c] = null;
            else this.deletedStates[e] = null;
          }
          getState(e, n) {
            const o = String(n), c = a.e({}, (this.state[e] || {})[o], (this.stateChanges[e] || {})[o]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const d = this.deletedStates[e][n];
              if (d === null) return {};
              for (const g in d) delete c[g];
            }
            return c;
          }
          initializeTileState(e, n) {
            e.setFeatureState(this.state, n);
          }
          coalesceChanges(e, n) {
            const o = {};
            for (const c in this.stateChanges) {
              this.state[c] = this.state[c] || {};
              const d = {};
              for (const g in this.stateChanges[c]) this.state[c][g] || (this.state[c][g] = {}), a.e(this.state[c][g], this.stateChanges[c][g]), d[g] = this.state[c][g];
              o[c] = d;
            }
            for (const c in this.deletedStates) {
              this.state[c] = this.state[c] || {};
              const d = {};
              if (this.deletedStates[c] === null) for (const g in this.state[c]) d[g] = {}, this.state[c][g] = {};
              else for (const g in this.deletedStates[c]) {
                if (this.deletedStates[c][g] === null) this.state[c][g] = {};
                else for (const v of Object.keys(this.deletedStates[c][g])) delete this.state[c][g][v];
                d[g] = this.state[c][g];
              }
              o[c] = o[c] || {}, a.e(o[c], d);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(o).length !== 0) for (const c in e) e[c].setFeatureState(o, n);
          }
        }
        const j = 89.25;
        function N(h, e) {
          const n = a.ah(e.lat, -a.ai, a.ai);
          return new a.P(a.V(e.lng) * h, a.U(n) * h);
        }
        function X(h, e) {
          return new a.a1(e.x / h, e.y / h).toLngLat();
        }
        function ie(h) {
          return h.cameraToCenterDistance * Math.min(0.85 * Math.tan(a.ae(90 - h.pitch)), Math.tan(a.ae(j - h.pitch)));
        }
        function le(h, e) {
          const n = h.canonical, o = e / a.af(n.z), c = n.x + Math.pow(2, n.z) * h.wrap, d = a.ag(new Float64Array(16));
          return a.M(d, d, [c * o, n.y * o, 0]), a.N(d, d, [o / a.$, o / a.$, 1]), d;
        }
        function me(h, e, n, o, c) {
          const d = a.a1.fromLngLat(h, e), g = c * a.aj(1, h.lat), v = g * Math.cos(a.ae(n)), x = Math.sqrt(g * g - v * v), M = x * Math.sin(a.ae(-o)), C = x * Math.cos(a.ae(-o));
          return new a.a1(d.x + M, d.y + C, d.z + v);
        }
        function de(h, e, n) {
          const o = e.intersectsFrustum(h);
          if (!n || o === 0) return o;
          const c = e.intersectsPlane(n);
          return c === 0 ? 0 : o === 2 && c === 2 ? 2 : 1;
        }
        function Pe(h, e, n) {
          let o = 0;
          const c = (n - e) / 10;
          for (let d = 0; d < 10; d++) o += c * Math.pow(Math.cos(e + (d + 0.5) / 10 * (n - e)), h);
          return o;
        }
        function ke(h, e) {
          return function(n, o, c, d, g) {
            const v = 2 * ((h - 1) / a.ak(Math.cos(a.ae(j - g)) / Math.cos(a.ae(j))) - 1), x = Math.acos(c / d), M = 2 * Pe(v - 1, 0, a.ae(g / 2)), C = Math.min(a.ae(j), x + a.ae(g / 2)), k = Pe(v - 1, Math.min(C, x - a.ae(g / 2)), C), A = Math.atan(o / c), R = Math.hypot(o, c);
            let O = n;
            return O += a.ak(d / R / Math.max(0.5, Math.cos(a.ae(g / 2)))), O += v * a.ak(Math.cos(A)) / 2, O -= a.ak(Math.max(1, k / M / e)) / 2, O;
          };
        }
        const Ce = ke(9.314, 3);
        function rt(h, e) {
          const n = (e.roundZoom ? Math.round : Math.floor)(h.zoom + a.ak(h.tileSize / e.tileSize));
          return Math.max(0, n);
        }
        function fe(h, e) {
          const n = h.getCameraFrustum(), o = h.getClippingPlane(), c = h.screenPointToMercatorCoordinate(h.getCameraPoint()), d = a.a1.fromLngLat(h.center, h.elevation);
          c.z = d.z + Math.cos(h.pitchInRadians) * h.cameraToCenterDistance / h.worldSize;
          const g = h.getCoveringTilesDetailsProvider(), v = g.allowVariableZoom(h, e), x = rt(h, e), M = e.minzoom || 0, C = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom, k = Math.min(Math.max(0, x), C), A = Math.pow(2, k), R = [A * c.x, A * c.y, 0], O = [A * d.x, A * d.y, 0], G = Math.hypot(d.x - c.x, d.y - c.y), Z = Math.abs(d.z - c.z), q = Math.hypot(G, Z), W = (te) => ({ zoom: 0, x: 0, y: 0, wrap: te, fullyVisible: !1 }), J = [], K = [];
          if (h.renderWorldCopies && g.allowWorldCopies()) for (let te = 1; te <= 3; te++) J.push(W(-te)), J.push(W(te));
          for (J.push(W(0)); J.length > 0; ) {
            const te = J.pop(), se = te.x, Y = te.y;
            let pe = te.fullyVisible;
            const be = { x: se, y: Y, z: te.zoom }, ge = g.getTileBoundingVolume(be, te.wrap, h.elevation, e);
            if (!pe) {
              const Oe = de(n, ge, o);
              if (Oe === 0) continue;
              pe = Oe === 2;
            }
            const _e = g.distanceToTile2d(c.x, c.y, be, ge);
            let xe = x;
            v && (xe = (e.calculateTileZoom || Ce)(h.zoom + a.ak(h.tileSize / e.tileSize), _e, Z, q, h.fov)), xe = (e.roundZoom ? Math.round : Math.floor)(xe), xe = Math.max(0, xe);
            const Le = Math.min(xe, C);
            if (te.wrap = g.getWrap(d, be, te.wrap), te.zoom >= Le) {
              if (te.zoom < M) continue;
              const Oe = k - te.zoom, Ie = R[0] - 0.5 - (se << Oe), et = R[1] - 0.5 - (Y << Oe), Ct = e.reparseOverscaled ? Math.max(te.zoom, xe) : te.zoom;
              K.push({ tileID: new a.Z(te.zoom === C ? Ct : te.zoom, te.wrap, te.zoom, se, Y), distanceSq: a.al([O[0] - 0.5 - se, O[1] - 0.5 - Y]), tileDistanceToCamera: Math.sqrt(Ie * Ie + et * et) });
            } else for (let Oe = 0; Oe < 4; Oe++) J.push({ zoom: te.zoom + 1, x: (se << 1) + Oe % 2, y: (Y << 1) + (Oe >> 1), wrap: te.wrap, fullyVisible: pe });
          }
          return K.sort((te, se) => te.distanceSq - se.distanceSq).map((te) => te.tileID);
        }
        const bt = a.a2.fromPoints([new a.P(0, 0), new a.P(a.$, a.$)]);
        class Dt extends a.E {
          constructor(e, n, o) {
            super(), this.id = e, this.dispatcher = o, this.on("data", (c) => this._dataHandler(c)), this.on("dataloading", () => {
              this._sourceErrored = !1;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ((c, d, g, v) => {
              const x = new (Ye(d.type))(c, d, g, v);
              if (x.id !== c) throw new Error(`Expected Source id to be ${c} instead of ${x.id}`);
              return x;
            })(e, n, o, this), this._tiles = {}, this._cache = new oe(0, (c) => this._unloadTile(c)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new B(), this._didEmitContent = !1, this._updated = !1;
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const n = this._tiles[e];
              if (n.state !== "loaded" && n.state !== "errored") return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(e, n, o) {
            return a._(this, void 0, void 0, function* () {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, n, o);
              } catch (c) {
                e.state = "errored", c.status !== 404 ? this._source.fire(new a.k(c, { tile: e })) : this.update(this.transform, this.terrain);
              }
            });
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e);
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new a.l("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const n in this._tiles) {
              const o = this._tiles[n];
              o.upload(e), o.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e) => e.tileID).sort(ot).map((e) => e.key);
          }
          getRenderableIds(e) {
            const n = [];
            for (const o in this._tiles) this._isIdRenderable(o, e) && n.push(this._tiles[o]);
            return e ? n.sort((o, c) => {
              const d = o.tileID, g = c.tileID, v = new a.P(d.canonical.x, d.canonical.y)._rotate(-this.transform.bearingInRadians), x = new a.P(g.canonical.x, g.canonical.y)._rotate(-this.transform.bearingInRadians);
              return d.overscaledZ - g.overscaledZ || x.y - v.y || x.x - v.x;
            }).map((o) => o.tileID.key) : n.map((o) => o.tileID).sort(ot).map((o) => o.key);
          }
          hasRenderableParent(e) {
            const n = this.findLoadedParent(e, 0);
            return !!n && this._isIdRenderable(n.tileID.key);
          }
          _isIdRenderable(e, n) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (n || !this._tiles[e].holdingForFade());
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const n in this._tiles) e ? this._reloadTile(n, "expired") : this._tiles[n].state !== "errored" && this._reloadTile(n, "reloading");
            }
          }
          _reloadTile(e, n) {
            return a._(this, void 0, void 0, function* () {
              const o = this._tiles[e];
              o && (o.state !== "loading" && (o.state = n), yield this._loadTile(o, e, n));
            });
          }
          _tileLoaded(e, n, o) {
            e.timeAdded = we.now(), o === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(n, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new a.l("data", { dataType: "source", tile: e, coord: e.tileID }));
          }
          _backfillDEM(e) {
            const n = this.getRenderableIds();
            for (let c = 0; c < n.length; c++) {
              const d = n[c];
              if (e.neighboringTiles && e.neighboringTiles[d]) {
                const g = this.getTileByID(d);
                o(e, g), o(g, e);
              }
            }
            function o(c, d) {
              c.needsHillshadePrepare = !0, c.needsTerrainPrepare = !0;
              let g = d.tileID.canonical.x - c.tileID.canonical.x;
              const v = d.tileID.canonical.y - c.tileID.canonical.y, x = Math.pow(2, c.tileID.canonical.z), M = d.tileID.key;
              g === 0 && v === 0 || Math.abs(v) > 1 || (Math.abs(g) > 1 && (Math.abs(g + x) === 1 ? g += x : Math.abs(g - x) === 1 && (g -= x)), d.dem && c.dem && (c.dem.backfillBorder(d.dem, g, v), c.neighboringTiles && c.neighboringTiles[M] && (c.neighboringTiles[M].backfilled = !0)));
            }
          }
          getTile(e) {
            return this.getTileByID(e.key);
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          _retainLoadedChildren(e, n, o, c) {
            for (const d in this._tiles) {
              let g = this._tiles[d];
              if (c[d] || !g.hasData() || g.tileID.overscaledZ <= n || g.tileID.overscaledZ > o) continue;
              let v = g.tileID;
              for (; g && g.tileID.overscaledZ > n + 1; ) {
                const M = g.tileID.scaledTo(g.tileID.overscaledZ - 1);
                g = this._tiles[M.key], g && g.hasData() && (v = M);
              }
              let x = v;
              for (; x.overscaledZ > n; ) if (x = x.scaledTo(x.overscaledZ - 1), e[x.key] || e[x.canonical.key]) {
                c[v.key] = v;
                break;
              }
            }
          }
          findLoadedParent(e, n) {
            if (e.key in this._loadedParentTiles) {
              const o = this._loadedParentTiles[e.key];
              return o && o.tileID.overscaledZ >= n ? o : null;
            }
            for (let o = e.overscaledZ - 1; o >= n; o--) {
              const c = e.scaledTo(o), d = this._getLoadedTile(c);
              if (d) return d;
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e);
          }
          _getLoadedTile(e) {
            const n = this._tiles[e.key];
            return n && n.hasData() ? n : this._cache.getByKey(e.wrapped().key);
          }
          updateCacheSize(e) {
            const n = Math.ceil(e.width / this._source.tileSize) + 1, o = Math.ceil(e.height / this._source.tileSize) + 1, c = Math.floor(n * o * (this._maxTileCacheZoomLevels === null ? a.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), d = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, c) : c;
            this._cache.setMaxSize(d);
          }
          handleWrapJump(e) {
            const n = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, n) {
              const o = {};
              for (const c in this._tiles) {
                const d = this._tiles[c];
                d.tileID = d.tileID.unwrapTo(d.tileID.wrap + n), o[d.tileID.key] = d;
              }
              this._tiles = o;
              for (const c in this._timers) clearTimeout(this._timers[c]), delete this._timers[c];
              for (const c in this._tiles) this._setTileReloadTimer(c, this._tiles[c]);
            }
          }
          _updateCoveredAndRetainedTiles(e, n, o, c, d, g) {
            const v = {}, x = {}, M = Object.keys(e), C = we.now();
            for (const k of M) {
              const A = e[k], R = this._tiles[k];
              if (!R || R.fadeEndTime !== 0 && R.fadeEndTime <= C) continue;
              const O = this.findLoadedParent(A, n), G = this.findLoadedSibling(A), Z = O || G || null;
              Z && (this._addTile(Z.tileID), v[Z.tileID.key] = Z.tileID), x[k] = A;
            }
            this._retainLoadedChildren(x, c, o, e);
            for (const k in v) e[k] || (this._coveredTiles[k] = !0, e[k] = v[k]);
            if (g) {
              const k = {}, A = {};
              for (const R of d) this._tiles[R.key].hasData() ? k[R.key] = R : A[R.key] = R;
              for (const R in A) {
                const O = A[R].children(this._source.maxzoom);
                this._tiles[O[0].key] && this._tiles[O[1].key] && this._tiles[O[2].key] && this._tiles[O[3].key] && (k[O[0].key] = e[O[0].key] = O[0], k[O[1].key] = e[O[1].key] = O[1], k[O[2].key] = e[O[2].key] = O[2], k[O[3].key] = e[O[3].key] = O[3], delete A[R]);
              }
              for (const R in A) {
                const O = A[R], G = this.findLoadedParent(O, this._source.minzoom), Z = this.findLoadedSibling(O), q = G || Z || null;
                if (q) {
                  k[q.tileID.key] = e[q.tileID.key] = q.tileID;
                  for (const W in k) k[W].isChildOf(q.tileID) && delete k[W];
                }
              }
              for (const R in this._tiles) k[R] || (this._coveredTiles[R] = !0);
            }
          }
          update(e, n) {
            if (!this._sourceLoaded || this._paused) return;
            let o;
            this.transform = e, this.terrain = n, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? o = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((C) => new a.Z(C.canonical.z, C.wrap, C.canonical.z, C.canonical.x, C.canonical.y)) : (o = fe(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: n, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (o = o.filter((C) => this._source.hasTile(C)))) : o = [];
            const c = rt(e, this._source), d = Math.max(c - Dt.maxOverzooming, this._source.minzoom), g = Math.max(c + Dt.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const C = {};
              for (const k of o) if (k.canonical.z > this._source.minzoom) {
                const A = k.scaledTo(k.canonical.z - 1);
                C[A.key] = A;
                const R = k.scaledTo(Math.max(this._source.minzoom, Math.min(k.canonical.z, 5)));
                C[R.key] = R;
              }
              o = o.concat(Object.values(C));
            }
            const v = o.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, v && this.fire(new a.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const x = this._updateRetainedTiles(o, c);
            St(this._source.type) && this._updateCoveredAndRetainedTiles(x, d, g, c, o, n);
            for (const C in x) this._tiles[C].clearFadeHold();
            const M = a.am(this._tiles, x);
            for (const C of M) {
              const k = this._tiles[C];
              k.hasSymbolBuckets && !k.holdingForFade() ? k.setHoldDuration(this.map._fadeDuration) : k.hasSymbolBuckets && !k.symbolFadeFinished() || this._removeTile(C);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
          }
          _updateRetainedTiles(e, n) {
            var o;
            const c = {}, d = {}, g = Math.max(n - Dt.maxOverzooming, this._source.minzoom), v = Math.max(n + Dt.maxUnderzooming, this._source.minzoom), x = {};
            for (const M of e) {
              const C = this._addTile(M);
              c[M.key] = M, C.hasData() || n < this._source.maxzoom && (x[M.key] = M);
            }
            this._retainLoadedChildren(x, n, v, c);
            for (const M of e) {
              let C = this._tiles[M.key];
              if (C.hasData()) continue;
              if (n + 1 > this._source.maxzoom) {
                const A = M.children(this._source.maxzoom)[0], R = this.getTile(A);
                if (R && R.hasData()) {
                  c[A.key] = A;
                  continue;
                }
              } else {
                const A = M.children(this._source.maxzoom);
                if (c[A[0].key] && c[A[1].key] && c[A[2].key] && c[A[3].key]) continue;
              }
              let k = C.wasRequested();
              for (let A = M.overscaledZ - 1; A >= g; --A) {
                const R = M.scaledTo(A);
                if (d[R.key]) break;
                if (d[R.key] = !0, C = this.getTile(R), !C && k && (C = this._addTile(R)), C) {
                  const O = C.hasData();
                  if ((O || !(!((o = this.map) === null || o === void 0) && o.cancelPendingTileRequestsWhileZooming) || k) && (c[R.key] = R), k = C.wasRequested(), O) break;
                }
              }
            }
            return c;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const n = [];
              let o, c = this._tiles[e].tileID;
              for (; c.overscaledZ > 0; ) {
                if (c.key in this._loadedParentTiles) {
                  o = this._loadedParentTiles[c.key];
                  break;
                }
                n.push(c.key);
                const d = c.scaledTo(c.overscaledZ - 1);
                if (o = this._getLoadedTile(d), o) break;
                c = d;
              }
              for (const d of n) this._loadedParentTiles[d] = o;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const n = this._tiles[e].tileID, o = this._getLoadedTile(n);
              this._loadedSiblingTiles[n.key] = o;
            }
          }
          _addTile(e) {
            let n = this._tiles[e.key];
            if (n) return n;
            n = this._cache.getAndRemove(e), n && (this._setTileReloadTimer(e.key, n), n.tileID = e, this._state.initializeTileState(n, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, n)));
            const o = n;
            return n || (n = new Ht(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(n, e.key, n.state)), n.uses++, this._tiles[e.key] = n, o || this._source.fire(new a.l("dataloading", { tile: n, coord: n.tileID, dataType: "source" })), n;
          }
          _setTileReloadTimer(e, n) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            const o = n.getExpiryTimeout();
            o && (this._timers[e] = setTimeout(() => {
              this._reloadTile(e, "expired"), delete this._timers[e];
            }, o));
          }
          refreshTiles(e) {
            for (const n in this._tiles) (this._isIdRenderable(n) || this._tiles[n].state == "errored") && e.some((o) => o.equals(this._tiles[n].tileID.canonical)) && this._reloadTile(n, "expired");
          }
          _removeTile(e) {
            const n = this._tiles[e];
            n && (n.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), n.uses > 0 || (n.hasData() && n.state !== "reloading" ? this._cache.add(n.tileID, n, n.getExpiryTimeout()) : (n.aborted = !0, this._abortTile(n), this._unloadTile(n))));
          }
          _dataHandler(e) {
            const n = e.sourceDataType;
            e.dataType === "source" && n === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && n === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset();
          }
          tilesIn(e, n, o) {
            const c = [], d = this.transform;
            if (!d) return c;
            const g = d.getCoveringTilesDetailsProvider().allowWorldCopies(), v = o ? d.getCameraQueryGeometry(e) : e, x = (R) => d.screenPointToMercatorCoordinate(R, this.terrain), M = this.transformBbox(e, x, !g), C = this.transformBbox(v, x, !g), k = this.getIds(), A = a.a2.fromPoints(C);
            for (let R = 0; R < k.length; R++) {
              const O = this._tiles[k[R]];
              if (O.holdingForFade()) continue;
              const G = g ? [O.tileID] : [O.tileID.unwrapTo(-1), O.tileID.unwrapTo(0)], Z = Math.pow(2, d.zoom - O.tileID.overscaledZ), q = n * O.queryPadding * a.$ / O.tileSize / Z;
              for (const W of G) {
                const J = A.map((K) => W.getTilePoint(new a.a1(K.x, K.y)));
                if (J.expandBy(q), J.intersects(bt)) {
                  const K = M.map((se) => W.getTilePoint(se)), te = C.map((se) => W.getTilePoint(se));
                  c.push({ tile: O, tileID: g ? W : W.unwrapTo(0), queryGeometry: K, cameraQueryGeometry: te, scale: Z });
                }
              }
            }
            return c;
          }
          transformBbox(e, n, o) {
            let c = e.map(n);
            if (o) {
              const d = a.a2.fromPoints(e);
              d.shrinkBy(1e-3 * Math.min(d.width(), d.height()));
              const g = d.map(n);
              a.a2.fromPoints(c).covers(g) || (c = c.map((v) => v.x > 0.5 ? new a.a1(v.x - 1, v.y, v.z) : v));
            }
            return c;
          }
          getVisibleCoordinates(e) {
            const n = this.getRenderableIds(e).map((o) => this._tiles[o].tileID);
            return this.transform && this.transform.populateCache(n), n;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (St(this._source.type)) {
              const e = we.now();
              for (const n in this._tiles) if (this._tiles[n].fadeEndTime >= e) return !0;
            }
            return !1;
          }
          setFeatureState(e, n, o) {
            this._state.updateState(e = e || "_geojsonTileLayer", n, o);
          }
          removeFeatureState(e, n, o) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", n, o);
          }
          getFeatureState(e, n) {
            return this._state.getState(e = e || "_geojsonTileLayer", n);
          }
          setDependencies(e, n, o) {
            const c = this._tiles[e];
            c && c.setDependencies(n, o);
          }
          reloadTilesForDependencies(e, n) {
            for (const o in this._tiles) this._tiles[o].hasDependency(e, n) && this._reloadTile(o, "reloading");
            this._cache.filter((o) => !o.hasDependency(e, n));
          }
        }
        function ot(h, e) {
          const n = Math.abs(2 * h.wrap) - +(h.wrap < 0), o = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return h.overscaledZ - e.overscaledZ || o - n || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x;
        }
        function St(h) {
          return h === "raster" || h === "image" || h === "video";
        }
        Dt.maxOverzooming = 10, Dt.maxUnderzooming = 3;
        class ui {
          constructor(e, n) {
            this.reset(e, n);
          }
          reset(e, n) {
            this.points = e || [], this._distances = [0];
            for (let o = 1; o < this.points.length; o++) this._distances[o] = this._distances[o - 1] + this.points[o].dist(this.points[o - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(n || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = a.ah(e, 0, 1);
            let n = 1, o = this._distances[n];
            const c = e * this.paddedLength + this.padding;
            for (; o < c && n < this._distances.length; ) o = this._distances[++n];
            const d = n - 1, g = this._distances[d], v = o - g, x = v > 0 ? (c - g) / v : 0;
            return this.points[d].mult(1 - x).add(this.points[n].mult(x));
          }
        }
        function ji(h, e) {
          let n = !0;
          return h === "always" || h !== "never" && e !== "never" || (n = !1), n;
        }
        class Vi {
          constructor(e, n, o) {
            const c = this.boxCells = [], d = this.circleCells = [];
            this.xCellCount = Math.ceil(e / o), this.yCellCount = Math.ceil(n / o);
            for (let g = 0; g < this.xCellCount * this.yCellCount; g++) c.push([]), d.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = n, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / n, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e, n, o, c, d) {
            this._forEachCell(n, o, c, d, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(n), this.bboxes.push(o), this.bboxes.push(c), this.bboxes.push(d);
          }
          insertCircle(e, n, o, c) {
            this._forEachCell(n - c, o - c, n + c, o + c, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(n), this.circles.push(o), this.circles.push(c);
          }
          _insertBoxCell(e, n, o, c, d, g) {
            this.boxCells[d].push(g);
          }
          _insertCircleCell(e, n, o, c, d, g) {
            this.circleCells[d].push(g);
          }
          _query(e, n, o, c, d, g, v) {
            if (o < 0 || e > this.width || c < 0 || n > this.height) return [];
            const x = [];
            if (e <= 0 && n <= 0 && this.width <= o && this.height <= c) {
              if (d) return [{ key: null, x1: e, y1: n, x2: o, y2: c }];
              for (let M = 0; M < this.boxKeys.length; M++) x.push({ key: this.boxKeys[M], x1: this.bboxes[4 * M], y1: this.bboxes[4 * M + 1], x2: this.bboxes[4 * M + 2], y2: this.bboxes[4 * M + 3] });
              for (let M = 0; M < this.circleKeys.length; M++) {
                const C = this.circles[3 * M], k = this.circles[3 * M + 1], A = this.circles[3 * M + 2];
                x.push({ key: this.circleKeys[M], x1: C - A, y1: k - A, x2: C + A, y2: k + A });
              }
            } else this._forEachCell(e, n, o, c, this._queryCell, x, { hitTest: d, overlapMode: g, seenUids: { box: {}, circle: {} } }, v);
            return x;
          }
          query(e, n, o, c) {
            return this._query(e, n, o, c, !1, null);
          }
          hitTest(e, n, o, c, d, g) {
            return this._query(e, n, o, c, !0, d, g).length > 0;
          }
          hitTestCircle(e, n, o, c, d) {
            const g = e - o, v = e + o, x = n - o, M = n + o;
            if (v < 0 || g > this.width || M < 0 || x > this.height) return !1;
            const C = [];
            return this._forEachCell(g, x, v, M, this._queryCellCircle, C, { hitTest: !0, overlapMode: c, circle: { x: e, y: n, radius: o }, seenUids: { box: {}, circle: {} } }, d), C.length > 0;
          }
          _queryCell(e, n, o, c, d, g, v, x) {
            const { seenUids: M, hitTest: C, overlapMode: k } = v, A = this.boxCells[d];
            if (A !== null) {
              const O = this.bboxes;
              for (const G of A) if (!M.box[G]) {
                M.box[G] = !0;
                const Z = 4 * G, q = this.boxKeys[G];
                if (e <= O[Z + 2] && n <= O[Z + 3] && o >= O[Z + 0] && c >= O[Z + 1] && (!x || x(q)) && (!C || !ji(k, q.overlapMode)) && (g.push({ key: q, x1: O[Z], y1: O[Z + 1], x2: O[Z + 2], y2: O[Z + 3] }), C)) return !0;
              }
            }
            const R = this.circleCells[d];
            if (R !== null) {
              const O = this.circles;
              for (const G of R) if (!M.circle[G]) {
                M.circle[G] = !0;
                const Z = 3 * G, q = this.circleKeys[G];
                if (this._circleAndRectCollide(O[Z], O[Z + 1], O[Z + 2], e, n, o, c) && (!x || x(q)) && (!C || !ji(k, q.overlapMode))) {
                  const W = O[Z], J = O[Z + 1], K = O[Z + 2];
                  if (g.push({ key: q, x1: W - K, y1: J - K, x2: W + K, y2: J + K }), C) return !0;
                }
              }
            }
            return !1;
          }
          _queryCellCircle(e, n, o, c, d, g, v, x) {
            const { circle: M, seenUids: C, overlapMode: k } = v, A = this.boxCells[d];
            if (A !== null) {
              const O = this.bboxes;
              for (const G of A) if (!C.box[G]) {
                C.box[G] = !0;
                const Z = 4 * G, q = this.boxKeys[G];
                if (this._circleAndRectCollide(M.x, M.y, M.radius, O[Z + 0], O[Z + 1], O[Z + 2], O[Z + 3]) && (!x || x(q)) && !ji(k, q.overlapMode)) return g.push(!0), !0;
              }
            }
            const R = this.circleCells[d];
            if (R !== null) {
              const O = this.circles;
              for (const G of R) if (!C.circle[G]) {
                C.circle[G] = !0;
                const Z = 3 * G, q = this.circleKeys[G];
                if (this._circlesCollide(O[Z], O[Z + 1], O[Z + 2], M.x, M.y, M.radius) && (!x || x(q)) && !ji(k, q.overlapMode)) return g.push(!0), !0;
              }
            }
          }
          _forEachCell(e, n, o, c, d, g, v, x) {
            const M = this._convertToXCellCoord(e), C = this._convertToYCellCoord(n), k = this._convertToXCellCoord(o), A = this._convertToYCellCoord(c);
            for (let R = M; R <= k; R++) for (let O = C; O <= A; O++) if (d.call(this, e, n, o, c, this.xCellCount * O + R, g, v, x)) return;
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
          }
          _circlesCollide(e, n, o, c, d, g) {
            const v = c - e, x = d - n, M = o + g;
            return M * M > v * v + x * x;
          }
          _circleAndRectCollide(e, n, o, c, d, g, v) {
            const x = (g - c) / 2, M = Math.abs(e - (c + x));
            if (M > x + o) return !1;
            const C = (v - d) / 2, k = Math.abs(n - (d + C));
            if (k > C + o) return !1;
            if (M <= x || k <= C) return !0;
            const A = M - x, R = k - C;
            return A * A + R * R <= o * o;
          }
        }
        function Ci(h, e, n) {
          const o = a.L();
          if (!h) {
            const { vecSouth: k, vecEast: A } = Gt(e), R = ue();
            R[0] = A[0], R[1] = A[1], R[2] = k[0], R[3] = k[1], c = R, (C = (g = (d = R)[0]) * (M = d[3]) - (x = d[2]) * (v = d[1])) && (c[0] = M * (C = 1 / C), c[1] = -v * C, c[2] = -x * C, c[3] = g * C), o[0] = R[0], o[1] = R[1], o[4] = R[2], o[5] = R[3];
          }
          var c, d, g, v, x, M, C;
          return a.N(o, o, [1 / n, 1 / n, 1]), o;
        }
        function Ot(h, e, n, o) {
          if (h) {
            const c = a.L();
            if (!e) {
              const { vecSouth: d, vecEast: g } = Gt(n);
              c[0] = g[0], c[1] = g[1], c[4] = d[0], c[5] = d[1];
            }
            return a.N(c, c, [o, o, 1]), c;
          }
          return n.pixelsToClipSpaceMatrix;
        }
        function Gt(h) {
          const e = Math.cos(h.rollInRadians), n = Math.sin(h.rollInRadians), o = Math.cos(h.pitchInRadians), c = Math.cos(h.bearingInRadians), d = Math.sin(h.bearingInRadians), g = a.ar();
          g[0] = -c * o * n - d * e, g[1] = -d * o * n + c * e;
          const v = a.as(g);
          v < 1e-9 ? a.at(g) : a.au(g, g, 1 / v);
          const x = a.ar();
          x[0] = c * o * e - d * n, x[1] = d * o * e + c * n;
          const M = a.as(x);
          return M < 1e-9 ? a.at(x) : a.au(x, x, 1 / M), { vecEast: x, vecSouth: g };
        }
        function Ri(h, e, n, o) {
          let c;
          o ? (c = [h, e, o(h, e), 1], a.aw(c, c, n)) : (c = [h, e, 0, 1], Us(c, c, n));
          const d = c[3];
          return { point: new a.P(c[0] / d, c[1] / d), signedDistanceFromCamera: d, isOccluded: !1 };
        }
        function Fe(h, e) {
          return 0.5 + h / e * 0.5;
        }
        function hr(h, e) {
          return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1];
        }
        function vi(h, e, n, o, c, d, g, v, x, M, C, k, A) {
          const R = n ? h.textSizeData : h.iconSizeData, O = a.an(R, e.transform.zoom), G = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], Z = n ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
          Z.clear();
          const q = h.lineVertexArray, W = n ? h.text.placedSymbolArray : h.icon.placedSymbolArray, J = e.transform.width / e.transform.height;
          let K = !1;
          for (let te = 0; te < W.length; te++) {
            const se = W.get(te);
            if (se.hidden || se.writingMode === a.ao.vertical && !K) {
              xn(se.numGlyphs, Z);
              continue;
            }
            K = !1;
            const Y = new a.P(se.anchorX, se.anchorY), pe = { getElevation: A, pitchedLabelPlaneMatrix: o, lineVertexArray: q, pitchWithMap: d, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: e.transform, tileAnchorPoint: Y, unwrappedTileID: x, width: M, height: C, translation: k }, be = Un(se.anchorX, se.anchorY, pe);
            if (!hr(be.point, G)) {
              xn(se.numGlyphs, Z);
              continue;
            }
            const ge = Fe(e.transform.cameraToCenterDistance, be.signedDistanceFromCamera), _e = a.ap(R, O, se), xe = d ? _e * e.transform.getPitchedTextCorrection(se.anchorX, se.anchorY, x) / ge : _e * ge, Le = qe({ projectionContext: pe, pitchedLabelPlaneMatrixInverse: c, symbol: se, fontSize: xe, flip: !1, keepUpright: g, glyphOffsetArray: h.glyphOffsetArray, dynamicLayoutVertexArray: Z, aspectRatio: J, rotateToLine: v });
            K = Le.useVertical, (Le.notEnoughRoom || K || Le.needsFlipping && qe({ projectionContext: pe, pitchedLabelPlaneMatrixInverse: c, symbol: se, fontSize: xe, flip: !0, keepUpright: g, glyphOffsetArray: h.glyphOffsetArray, dynamicLayoutVertexArray: Z, aspectRatio: J, rotateToLine: v }).notEnoughRoom) && xn(se.numGlyphs, Z);
          }
          n ? h.text.dynamicLayoutVertexBuffer.updateData(Z) : h.icon.dynamicLayoutVertexBuffer.updateData(Z);
        }
        function $n(h, e, n, o, c, d, g, v) {
          const x = d.glyphStartIndex + d.numGlyphs, M = d.lineStartIndex, C = d.lineStartIndex + d.lineLength, k = e.getoffsetX(d.glyphStartIndex), A = e.getoffsetX(x - 1), R = Zn(h * k, n, o, c, d.segment, M, C, v, g);
          if (!R) return null;
          const O = Zn(h * A, n, o, c, d.segment, M, C, v, g);
          return O ? v.projectionCache.anyProjectionOccluded ? null : { first: R, last: O } : null;
        }
        function $s(h, e, n, o) {
          return h === a.ao.horizontal && Math.abs(n.y - e.y) > Math.abs(n.x - e.x) * o ? { useVertical: !0 } : (h === a.ao.vertical ? e.y < n.y : e.x > n.x) ? { needsFlipping: !0 } : null;
        }
        function qe(h) {
          const { projectionContext: e, pitchedLabelPlaneMatrixInverse: n, symbol: o, fontSize: c, flip: d, keepUpright: g, glyphOffsetArray: v, dynamicLayoutVertexArray: x, aspectRatio: M, rotateToLine: C } = h, k = c / 24, A = o.lineOffsetX * k, R = o.lineOffsetY * k;
          let O;
          if (o.numGlyphs > 1) {
            const G = o.glyphStartIndex + o.numGlyphs, Z = o.lineStartIndex, q = o.lineStartIndex + o.lineLength, W = $n(k, v, A, R, d, o, C, e);
            if (!W) return { notEnoughRoom: !0 };
            const J = ds(W.first.point.x, W.first.point.y, e, n), K = ds(W.last.point.x, W.last.point.y, e, n);
            if (g && !d) {
              const te = $s(o.writingMode, J, K, M);
              if (te) return te;
            }
            O = [W.first];
            for (let te = o.glyphStartIndex + 1; te < G - 1; te++) {
              const se = Zn(k * v.getoffsetX(te), A, R, d, o.segment, Z, q, e, C);
              if (!se) return { notEnoughRoom: !0 };
              O.push(se);
            }
            O.push(W.last);
          } else {
            if (g && !d) {
              const Z = rr(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, q = o.lineStartIndex + o.segment + 1, W = new a.P(e.lineVertexArray.getx(q), e.lineVertexArray.gety(q)), J = rr(W.x, W.y, e), K = J.signedDistanceFromCamera > 0 ? J.point : Lt(e.tileAnchorPoint, W, Z, 1, e), te = ds(Z.x, Z.y, e, n), se = ds(K.x, K.y, e, n), Y = $s(o.writingMode, te, se, M);
              if (Y) return Y;
            }
            const G = Zn(k * v.getoffsetX(o.glyphStartIndex), A, R, d, o.segment, o.lineStartIndex, o.lineStartIndex + o.lineLength, e, C);
            if (!G || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
            O = [G];
          }
          for (const G of O) a.av(x, G.point, G.angle);
          return {};
        }
        function Lt(h, e, n, o, c) {
          const d = h.add(h.sub(e)._unit()), g = rr(d.x, d.y, c).point, v = n.sub(g);
          return n.add(v._mult(o / v.mag()));
        }
        function kt(h, e, n) {
          const o = e.projectionCache;
          if (o.projections[h]) return o.projections[h];
          const c = new a.P(e.lineVertexArray.getx(h), e.lineVertexArray.gety(h)), d = rr(c.x, c.y, e);
          if (d.signedDistanceFromCamera > 0) return o.projections[h] = d.point, o.anyProjectionOccluded = o.anyProjectionOccluded || d.isOccluded, d.point;
          const g = h - n.direction;
          return Lt(n.distanceFromAnchor === 0 ? e.tileAnchorPoint : new a.P(e.lineVertexArray.getx(g), e.lineVertexArray.gety(g)), c, n.previousVertex, n.absOffsetX - n.distanceFromAnchor + 1, e);
        }
        function rr(h, e, n) {
          const o = h + n.translation[0], c = e + n.translation[1];
          let d;
          return n.pitchWithMap ? (d = Ri(o, c, n.pitchedLabelPlaneMatrix, n.getElevation), d.isOccluded = !1) : (d = n.transform.projectTileCoordinates(o, c, n.unwrappedTileID, n.getElevation), d.point.x = (0.5 * d.point.x + 0.5) * n.width, d.point.y = (0.5 * -d.point.y + 0.5) * n.height), d;
        }
        function ds(h, e, n, o) {
          if (n.pitchWithMap) {
            const c = [h, e, 0, 1];
            return a.aw(c, c, o), n.transform.projectTileCoordinates(c[0] / c[3], c[1] / c[3], n.unwrappedTileID, n.getElevation).point;
          }
          return { x: h / n.width * 2 - 1, y: 1 - e / n.height * 2 };
        }
        function Un(h, e, n) {
          return n.transform.projectTileCoordinates(h, e, n.unwrappedTileID, n.getElevation);
        }
        function Mt(h, e, n) {
          return h._unit()._perp()._mult(e * n);
        }
        function va(h, e, n, o, c, d, g, v, x) {
          if (v.projectionCache.offsets[h]) return v.projectionCache.offsets[h];
          const M = n.add(e);
          if (h + x.direction < o || h + x.direction >= c) return v.projectionCache.offsets[h] = M, M;
          const C = kt(h + x.direction, v, x), k = Mt(C.sub(n), g, x.direction), A = n.add(k), R = C.add(k);
          return v.projectionCache.offsets[h] = a.ax(d, M, A, R) || M, v.projectionCache.offsets[h];
        }
        function Zn(h, e, n, o, c, d, g, v, x) {
          const M = o ? h - e : h + e;
          let C = M > 0 ? 1 : -1, k = 0;
          o && (C *= -1, k = Math.PI), C < 0 && (k += Math.PI);
          let A, R = C > 0 ? d + c : d + c + 1;
          v.projectionCache.cachedAnchorPoint ? A = v.projectionCache.cachedAnchorPoint : (A = rr(v.tileAnchorPoint.x, v.tileAnchorPoint.y, v).point, v.projectionCache.cachedAnchorPoint = A);
          let O, G, Z = A, q = A, W = 0, J = 0;
          const K = Math.abs(M), te = [];
          let se;
          for (; W + J <= K; ) {
            if (R += C, R < d || R >= g) return null;
            W += J, q = Z, G = O;
            const be = { absOffsetX: K, direction: C, distanceFromAnchor: W, previousVertex: q };
            if (Z = kt(R, v, be), n === 0) te.push(q), se = Z.sub(q);
            else {
              let ge;
              const _e = Z.sub(q);
              ge = _e.mag() === 0 ? Mt(kt(R + C, v, be).sub(Z), n, C) : Mt(_e, n, C), G || (G = q.add(ge)), O = va(R, ge, Z, d, g, G, n, v, be), te.push(G), se = O.sub(G);
            }
            J = se.mag();
          }
          const Y = se._mult((K - W) / J)._add(G || q), pe = k + Math.atan2(Z.y - q.y, Z.x - q.x);
          return te.push(Y), { point: Y, angle: x ? pe : 0, path: te };
        }
        const xa = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function xn(h, e) {
          for (let n = 0; n < h; n++) {
            const o = e.length;
            e.resize(o + 4), e.float32.set(xa, 3 * o);
          }
        }
        function Us(h, e, n) {
          const o = e[0], c = e[1];
          return h[0] = n[0] * o + n[4] * c + n[12], h[1] = n[1] * o + n[5] * c + n[13], h[3] = n[3] * o + n[7] * c + n[15], h;
        }
        const Ti = 100;
        class ba {
          constructor(e, n = new Vi(e.width + 200, e.height + 200, 25), o = new Vi(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = n, this.ignoredGrid = o, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Ti, this.screenBottomBoundary = e.height + Ti, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(e, n, o, c, d, g, v, x, M, C, k, A) {
            const R = this.projectAndGetPerspectiveRatio(e.anchorPointX + x[0], e.anchorPointY + x[1], d, C, A), O = o * R.perspectiveRatio;
            let G;
            if (g || v) G = this._projectCollisionBox(e, O, c, d, g, v, x, R, C, k, A);
            else {
              const se = R.x + (k ? k.x * O : 0), Y = R.y + (k ? k.y * O : 0);
              G = { allPointsOccluded: !1, box: [se + e.x1 * O, Y + e.y1 * O, se + e.x2 * O, Y + e.y2 * O] };
            }
            const [Z, q, W, J] = G.box, K = g ? G.allPointsOccluded : R.isOccluded;
            let te = K;
            return te || (te = R.perspectiveRatio < this.perspectiveRatioCutoff), te || (te = !this.isInsideGrid(Z, q, W, J)), te || n !== "always" && this.grid.hitTest(Z, q, W, J, n, M) ? { box: [Z, q, W, J], placeable: !1, offscreen: !1, occluded: K } : { box: [Z, q, W, J], placeable: !0, offscreen: this.isOffscreen(Z, q, W, J), occluded: K };
          }
          placeCollisionCircles(e, n, o, c, d, g, v, x, M, C, k, A, R, O) {
            const G = [], Z = new a.P(n.anchorX, n.anchorY), q = this.getPerspectiveRatio(Z.x, Z.y, g, O), W = (M ? d * this.transform.getPitchedTextCorrection(n.anchorX, n.anchorY, g) / q : d * q) / a.aB, J = { getElevation: O, pitchedLabelPlaneMatrix: v, lineVertexArray: o, pitchWithMap: M, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: Z, unwrappedTileID: g, width: this.transform.width, height: this.transform.height, translation: R }, K = $n(W, c, n.lineOffsetX * W, n.lineOffsetY * W, !1, n, !1, J);
            let te = !1, se = !1, Y = !0;
            if (K) {
              const pe = 0.5 * k * q + A, be = new a.P(-100, -100), ge = new a.P(this.screenRightBoundary, this.screenBottomBoundary), _e = new ui(), xe = K.first, Le = K.last;
              let Oe = [];
              for (let Ct = xe.path.length - 1; Ct >= 1; Ct--) Oe.push(xe.path[Ct]);
              for (let Ct = 1; Ct < Le.path.length; Ct++) Oe.push(Le.path[Ct]);
              const Ie = 2.5 * pe;
              if (M) {
                const Ct = this.projectPathToScreenSpace(Oe, J);
                Oe = Ct.some((Kt) => Kt.signedDistanceFromCamera <= 0) ? [] : Ct.map((Kt) => Kt.point);
              }
              let et = [];
              if (Oe.length > 0) {
                const Ct = Oe[0].clone(), Kt = Oe[0].clone();
                for (let ri = 1; ri < Oe.length; ri++) Ct.x = Math.min(Ct.x, Oe[ri].x), Ct.y = Math.min(Ct.y, Oe[ri].y), Kt.x = Math.max(Kt.x, Oe[ri].x), Kt.y = Math.max(Kt.y, Oe[ri].y);
                et = Ct.x >= be.x && Kt.x <= ge.x && Ct.y >= be.y && Kt.y <= ge.y ? [Oe] : Kt.x < be.x || Ct.x > ge.x || Kt.y < be.y || Ct.y > ge.y ? [] : a.ay([Oe], be.x, be.y, ge.x, ge.y);
              }
              for (const Ct of et) {
                _e.reset(Ct, 0.25 * pe);
                let Kt = 0;
                Kt = _e.length <= 0.5 * pe ? 1 : Math.ceil(_e.paddedLength / Ie) + 1;
                for (let ri = 0; ri < Kt; ri++) {
                  const ei = ri / Math.max(Kt - 1, 1), gi = _e.lerp(ei), bi = gi.x + Ti, Pt = gi.y + Ti;
                  G.push(bi, Pt, pe, 0);
                  const ni = bi - pe, Li = Pt - pe, Ni = bi + pe, Wi = Pt + pe;
                  if (Y = Y && this.isOffscreen(ni, Li, Ni, Wi), se = se || this.isInsideGrid(ni, Li, Ni, Wi), e !== "always" && this.grid.hitTestCircle(bi, Pt, pe, e, C) && (te = !0, !x)) return { circles: [], offscreen: !1, collisionDetected: te };
                }
              }
            }
            return { circles: !x && te || !se || q < this.perspectiveRatioCutoff ? [] : G, offscreen: Y, collisionDetected: te };
          }
          projectPathToScreenSpace(e, n) {
            const o = function(c, d) {
              const g = a.L();
              return a.aq(g, d.pitchedLabelPlaneMatrix), c.map((v) => {
                const x = Ri(v.x, v.y, g, d.getElevation), M = d.transform.projectTileCoordinates(x.point.x, x.point.y, d.unwrappedTileID, d.getElevation);
                return M.point.x = (0.5 * M.point.x + 0.5) * d.width, M.point.y = (0.5 * -M.point.y + 0.5) * d.height, M;
              });
            }(e, n);
            return function(c) {
              let d = 0, g = 0, v = 0, x = 0;
              for (let M = 0; M < c.length; M++) c[M].isOccluded ? (v = M + 1, x = 0) : (x++, x > g && (g = x, d = v));
              return c.slice(d, d + g);
            }(o);
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const n = [], o = new a.a2();
            for (const k of e) {
              const A = new a.P(k.x + Ti, k.y + Ti);
              o.extend(A), n.push(A);
            }
            const { minX: c, minY: d, maxX: g, maxY: v } = o, x = this.grid.query(c, d, g, v).concat(this.ignoredGrid.query(c, d, g, v)), M = {}, C = {};
            for (const k of x) {
              const A = k.key;
              if (M[A.bucketInstanceId] === void 0 && (M[A.bucketInstanceId] = {}), M[A.bucketInstanceId][A.featureIndex]) continue;
              const R = [new a.P(k.x1, k.y1), new a.P(k.x2, k.y1), new a.P(k.x2, k.y2), new a.P(k.x1, k.y2)];
              a.az(n, R) && (M[A.bucketInstanceId][A.featureIndex] = !0, C[A.bucketInstanceId] === void 0 && (C[A.bucketInstanceId] = []), C[A.bucketInstanceId].push(A.featureIndex));
            }
            return C;
          }
          insertCollisionBox(e, n, o, c, d, g) {
            (o ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: c, featureIndex: d, collisionGroupID: g, overlapMode: n }, e[0], e[1], e[2], e[3]);
          }
          insertCollisionCircles(e, n, o, c, d, g) {
            const v = o ? this.ignoredGrid : this.grid, x = { bucketInstanceId: c, featureIndex: d, collisionGroupID: g, overlapMode: n };
            for (let M = 0; M < e.length; M += 4) v.insertCircle(x, e[M], e[M + 1], e[M + 2]);
          }
          projectAndGetPerspectiveRatio(e, n, o, c, d) {
            if (d) {
              let g;
              c ? (g = [e, n, c(e, n), 1], a.aw(g, g, d)) : (g = [e, n, 0, 1], Us(g, g, d));
              const v = g[3];
              return { x: (g[0] / v + 1) / 2 * this.transform.width + Ti, y: (-g[1] / v + 1) / 2 * this.transform.height + Ti, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / v * 0.5, isOccluded: !1, signedDistanceFromCamera: v };
            }
            {
              const g = this.transform.projectTileCoordinates(e, n, o, c);
              return { x: (g.point.x + 1) / 2 * this.transform.width + Ti, y: (1 - g.point.y) / 2 * this.transform.height + Ti, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / g.signedDistanceFromCamera * 0.5, isOccluded: g.isOccluded, signedDistanceFromCamera: g.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(e, n, o, c) {
            const d = this.transform.projectTileCoordinates(e, n, o, c);
            return 0.5 + this.transform.cameraToCenterDistance / d.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(e, n, o, c) {
            return o < Ti || e >= this.screenRightBoundary || c < Ti || n > this.screenBottomBoundary;
          }
          isInsideGrid(e, n, o, c) {
            return o >= 0 && e < this.gridRightBoundary && c >= 0 && n < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e = a.ag([]);
            return a.M(e, e, [-100, -100, 0]), e;
          }
          _projectCollisionBox(e, n, o, c, d, g, v, x, M, C, k) {
            let A = 1, R = 0, O = 0, G = 1;
            const Z = e.anchorPointX + v[0], q = e.anchorPointY + v[1];
            if (g && !d) {
              const Oe = this.projectAndGetPerspectiveRatio(Z + 1, q, c, M, k), Ie = Oe.x - x.x, et = Math.atan((Oe.y - x.y) / Ie) + (Ie < 0 ? Math.PI : 0), Ct = Math.sin(et), Kt = Math.cos(et);
              A = Kt, R = Ct, O = -Ct, G = Kt;
            } else if (!g && d) {
              const Oe = Gt(this.transform);
              A = Oe.vecEast[0], R = Oe.vecEast[1], O = Oe.vecSouth[0], G = Oe.vecSouth[1];
            }
            let W = x.x, J = x.y, K = n;
            d && (W = Z, J = q, K = Math.pow(2, -(this.transform.zoom - o.overscaledZ)), K *= this.transform.getPitchedTextCorrection(Z, q, c), C || (K *= a.ah(0.5 + x.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), C && (W += A * C.x * K + O * C.y * K, J += R * C.x * K + G * C.y * K);
            const te = e.x1 * K, se = e.x2 * K, Y = (te + se) / 2, pe = e.y1 * K, be = e.y2 * K, ge = (pe + be) / 2, _e = [{ offsetX: te, offsetY: pe }, { offsetX: Y, offsetY: pe }, { offsetX: se, offsetY: pe }, { offsetX: se, offsetY: ge }, { offsetX: se, offsetY: be }, { offsetX: Y, offsetY: be }, { offsetX: te, offsetY: be }, { offsetX: te, offsetY: ge }];
            let xe = [];
            for (const { offsetX: Oe, offsetY: Ie } of _e) xe.push(new a.P(W + A * Oe + O * Ie, J + R * Oe + G * Ie));
            let Le = !1;
            if (d) {
              const Oe = xe.map((Ie) => this.projectAndGetPerspectiveRatio(Ie.x, Ie.y, c, M, k));
              Le = Oe.some((Ie) => !Ie.isOccluded), xe = Oe.map((Ie) => new a.P(Ie.x, Ie.y));
            } else Le = !0;
            return { box: a.aA(xe), allPointsOccluded: !Le };
          }
        }
        class Cr {
          constructor(e, n, o, c) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? n : -n))) : c && o ? 1 : 0, this.placed = o;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class si {
          constructor(e, n, o, c, d) {
            this.text = new Cr(e ? e.text : null, n, o, d), this.icon = new Cr(e ? e.icon : null, n, c, d);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class lu {
          constructor(e, n, o) {
            this.text = e, this.icon = n, this.skipFade = o;
          }
        }
        class Co {
          constructor(e, n, o, c, d) {
            this.bucketInstanceId = e, this.featureIndex = n, this.sourceLayerIndex = o, this.bucketIndex = c, this.tileID = d;
          }
        }
        class Rl {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e]) {
              const n = ++this.maxGroupID;
              this.collisionGroups[e] = { ID: n, predicate: (o) => o.collisionGroupID === n };
            }
            return this.collisionGroups[e];
          }
        }
        function Gn(h, e, n, o, c) {
          const { horizontalAlign: d, verticalAlign: g } = a.aH(h);
          return new a.P(-(d - 0.5) * e + o[0] * c, -(g - 0.5) * n + o[1] * c);
        }
        class qn {
          constructor(e, n, o, c, d) {
            this.transform = e.clone(), this.terrain = n, this.collisionIndex = new ba(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = o, this.retainedQueryData = {}, this.collisionGroups = new Rl(c), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(e) {
            const n = this.terrain;
            return n ? (o, c) => n.getElevation(e, o, c) : null;
          }
          getBucketParts(e, n, o, c) {
            const d = o.getBucket(n), g = o.latestFeatureIndex;
            if (!d || !g || n.id !== d.layerIds[0]) return;
            const v = o.collisionBoxArray, x = d.layers[0].layout, M = d.layers[0].paint, C = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), k = o.tileSize / a.$, A = o.tileID.toUnwrapped(), R = x.get("text-rotation-alignment") === "map", O = a.aC(o, 1, this.transform.zoom), G = a.aD(this.collisionIndex.transform, o, M.get("text-translate"), M.get("text-translate-anchor")), Z = a.aD(this.collisionIndex.transform, o, M.get("icon-translate"), M.get("icon-translate-anchor")), q = Ci(R, this.transform, O);
            this.retainedQueryData[d.bucketInstanceId] = new Co(d.bucketInstanceId, g, d.sourceLayerIndex, d.index, o.tileID);
            const W = { bucket: d, layout: x, translationText: G, translationIcon: Z, unwrappedTileID: A, pitchedLabelPlaneMatrix: q, scale: C, textPixelRatio: k, holdingForFade: o.holdingForFade(), collisionBoxArray: v, partiallyEvaluatedTextSize: a.an(d.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(d.sourceID) };
            if (c) for (const J of d.sortKeyRanges) {
              const { sortKey: K, symbolInstanceStart: te, symbolInstanceEnd: se } = J;
              e.push({ sortKey: K, symbolInstanceStart: te, symbolInstanceEnd: se, parameters: W });
            }
            else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: d.symbolInstances.length, parameters: W });
          }
          attemptAnchorPlacement(e, n, o, c, d, g, v, x, M, C, k, A, R, O, G, Z, q, W, J, K) {
            const te = a.aE[e.textAnchor], se = [e.textOffset0, e.textOffset1], Y = Gn(te, o, c, se, d), pe = this.collisionIndex.placeCollisionBox(n, A, x, M, C, v, g, Z, k.predicate, J, Y, K);
            if ((!W || this.collisionIndex.placeCollisionBox(W, A, x, M, C, v, g, q, k.predicate, J, Y, K).placeable) && pe.placeable) {
              let be;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[R.crossTileID] && this.prevPlacement.placements[R.crossTileID] && this.prevPlacement.placements[R.crossTileID].text && (be = this.prevPlacement.variableOffsets[R.crossTileID].anchor), R.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[R.crossTileID] = { textOffset: se, width: o, height: c, anchor: te, textBoxScale: d, prevAnchor: be }, this.markUsedJustification(O, te, R, G), O.allowVerticalPlacement && (this.markUsedOrientation(O, G, R), this.placedOrientations[R.crossTileID] = G), { shift: Y, placedGlyphBoxes: pe };
            }
          }
          placeLayerBucketPart(e, n, o) {
            const { bucket: c, layout: d, translationText: g, translationIcon: v, unwrappedTileID: x, pitchedLabelPlaneMatrix: M, textPixelRatio: C, holdingForFade: k, collisionBoxArray: A, partiallyEvaluatedTextSize: R, collisionGroup: O } = e.parameters, G = d.get("text-optional"), Z = d.get("icon-optional"), q = a.aF(d, "text-overlap", "text-allow-overlap"), W = q === "always", J = a.aF(d, "icon-overlap", "icon-allow-overlap"), K = J === "always", te = d.get("text-rotation-alignment") === "map", se = d.get("text-pitch-alignment") === "map", Y = d.get("icon-text-fit") !== "none", pe = d.get("symbol-z-order") === "viewport-y", be = W && (K || !c.hasIconData() || Z), ge = K && (W || !c.hasTextData() || G);
            !c.collisionArrays && A && c.deserializeCollisionBoxes(A);
            const _e = this.retainedQueryData[c.bucketInstanceId].tileID, xe = this._getTerrainElevationFunc(_e), Le = this.transform.getFastPathSimpleProjectionMatrix(_e), Oe = (Ie, et, Ct) => {
              var Kt, ri;
              if (n[Ie.crossTileID]) return;
              if (k) return void (this.placements[Ie.crossTileID] = new lu(!1, !1, !1));
              let ei = !1, gi = !1, bi = !0, Pt = null, ni = { box: null, placeable: !1, offscreen: null, occluded: !1 }, Li = { placeable: !1 }, Ni = null, Wi = null, wr = null, cn = 0, Yn = 0, Jn = 0;
              et.textFeatureIndex ? cn = et.textFeatureIndex : Ie.useRuntimeCollisionCircles && (cn = Ie.featureIndex), et.verticalTextFeatureIndex && (Yn = et.verticalTextFeatureIndex);
              const uo = et.textBox;
              if (uo) {
                const Ar = (Fi) => {
                  let $i = a.ao.horizontal;
                  if (c.allowVerticalPlacement && !Fi && this.prevPlacement) {
                    const Yr = this.prevPlacement.placedOrientations[Ie.crossTileID];
                    Yr && (this.placedOrientations[Ie.crossTileID] = Yr, $i = Yr, this.markUsedOrientation(c, $i, Ie));
                  }
                  return $i;
                }, un = (Fi, $i) => {
                  if (c.allowVerticalPlacement && Ie.numVerticalGlyphVertices > 0 && et.verticalTextBox) {
                    for (const Yr of c.writingModes) if (Yr === a.ao.vertical ? (ni = $i(), Li = ni) : ni = Fi(), ni && ni.placeable) break;
                  } else ni = Fi();
                }, Tr = Ie.textAnchorOffsetStartIndex, Qn = Ie.textAnchorOffsetEndIndex;
                if (Qn === Tr) {
                  const Fi = ($i, Yr) => {
                    const Bi = this.collisionIndex.placeCollisionBox($i, q, C, _e, x, se, te, g, O.predicate, xe, void 0, Le);
                    return Bi && Bi.placeable && (this.markUsedOrientation(c, Yr, Ie), this.placedOrientations[Ie.crossTileID] = Yr), Bi;
                  };
                  un(() => Fi(uo, a.ao.horizontal), () => {
                    const $i = et.verticalTextBox;
                    return c.allowVerticalPlacement && Ie.numVerticalGlyphVertices > 0 && $i ? Fi($i, a.ao.vertical) : { box: null, offscreen: null };
                  }), Ar(ni && ni.placeable);
                } else {
                  let Fi = a.aE[(ri = (Kt = this.prevPlacement) === null || Kt === void 0 ? void 0 : Kt.variableOffsets[Ie.crossTileID]) === null || ri === void 0 ? void 0 : ri.anchor];
                  const $i = (Bi, ea, po) => {
                    const zn = Bi.x2 - Bi.x1, hn = Bi.y2 - Bi.y1, es = Ie.textBoxScale, eh = Y && J === "never" ? ea : null;
                    let Br = null, th = q === "never" ? 1 : 2, Mc = "never";
                    Fi && th++;
                    for (let rl = 0; rl < th; rl++) {
                      for (let nl = Tr; nl < Qn; nl++) {
                        const ts = c.textAnchorOffsets.get(nl);
                        if (Fi && ts.textAnchor !== Fi) continue;
                        const Rn = this.attemptAnchorPlacement(ts, Bi, zn, hn, es, te, se, C, _e, x, O, Mc, Ie, c, po, g, v, eh, xe);
                        if (Rn && (Br = Rn.placedGlyphBoxes, Br && Br.placeable)) return ei = !0, Pt = Rn.shift, Br;
                      }
                      Fi ? Fi = null : Mc = q;
                    }
                    return o && !Br && (Br = { box: this.collisionIndex.placeCollisionBox(uo, "always", C, _e, x, se, te, g, O.predicate, xe, void 0, Le).box, offscreen: !1, placeable: !1, occluded: !1 }), Br;
                  };
                  un(() => $i(uo, et.iconBox, a.ao.horizontal), () => {
                    const Bi = et.verticalTextBox;
                    return c.allowVerticalPlacement && (!ni || !ni.placeable) && Ie.numVerticalGlyphVertices > 0 && Bi ? $i(Bi, et.verticalIconBox, a.ao.vertical) : { box: null, occluded: !0, offscreen: null };
                  }), ni && (ei = ni.placeable, bi = ni.offscreen);
                  const Yr = Ar(ni && ni.placeable);
                  if (!ei && this.prevPlacement) {
                    const Bi = this.prevPlacement.variableOffsets[Ie.crossTileID];
                    Bi && (this.variableOffsets[Ie.crossTileID] = Bi, this.markUsedJustification(c, Bi.anchor, Ie, Yr));
                  }
                }
              }
              if (Ni = ni, ei = Ni && Ni.placeable, bi = Ni && Ni.offscreen, Ie.useRuntimeCollisionCircles) {
                const Ar = c.text.placedSymbolArray.get(Ie.centerJustifiedTextSymbolIndex), un = a.ap(c.textSizeData, R, Ar), Tr = d.get("text-padding");
                Wi = this.collisionIndex.placeCollisionCircles(q, Ar, c.lineVertexArray, c.glyphOffsetArray, un, x, M, o, se, O.predicate, Ie.collisionCircleDiameter, Tr, g, xe), Wi.circles.length && Wi.collisionDetected && !o && a.w("Collisions detected, but collision boxes are not shown"), ei = W || Wi.circles.length > 0 && !Wi.collisionDetected, bi = bi && Wi.offscreen;
              }
              if (et.iconFeatureIndex && (Jn = et.iconFeatureIndex), et.iconBox) {
                const Ar = (un) => this.collisionIndex.placeCollisionBox(un, J, C, _e, x, se, te, v, O.predicate, xe, Y && Pt ? Pt : void 0, Le);
                Li && Li.placeable && et.verticalIconBox ? (wr = Ar(et.verticalIconBox), gi = wr.placeable) : (wr = Ar(et.iconBox), gi = wr.placeable), bi = bi && wr.offscreen;
              }
              const ho = G || Ie.numHorizontalGlyphVertices === 0 && Ie.numVerticalGlyphVertices === 0, As = Z || Ie.numIconVertices === 0;
              ho || As ? As ? ho || (gi = gi && ei) : ei = gi && ei : gi = ei = gi && ei;
              const ks = gi && wr.placeable;
              if (ei && Ni.placeable && this.collisionIndex.insertCollisionBox(Ni.box, q, d.get("text-ignore-placement"), c.bucketInstanceId, Li && Li.placeable && Yn ? Yn : cn, O.ID), ks && this.collisionIndex.insertCollisionBox(wr.box, J, d.get("icon-ignore-placement"), c.bucketInstanceId, Jn, O.ID), Wi && ei && this.collisionIndex.insertCollisionCircles(Wi.circles, q, d.get("text-ignore-placement"), c.bucketInstanceId, cn, O.ID), o && this.storeCollisionData(c.bucketInstanceId, Ct, et, Ni, wr, Wi), Ie.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (c.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[Ie.crossTileID] = new lu((ei || be) && !(Ni != null && Ni.occluded), (gi || ge) && !(wr != null && wr.occluded), bi || c.justReloaded), n[Ie.crossTileID] = !0;
            };
            if (pe) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Ie = c.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let et = Ie.length - 1; et >= 0; --et) {
                const Ct = Ie[et];
                Oe(c.symbolInstances.get(Ct), c.collisionArrays[Ct], Ct);
              }
            } else for (let Ie = e.symbolInstanceStart; Ie < e.symbolInstanceEnd; Ie++) Oe(c.symbolInstances.get(Ie), c.collisionArrays[Ie], Ie);
            c.justReloaded = !1;
          }
          storeCollisionData(e, n, o, c, d, g) {
            if (o.textBox || o.iconBox) {
              let v, x;
              this.collisionBoxArrays.has(e) ? v = this.collisionBoxArrays.get(e) : (v = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, v)), v.has(n) ? x = v.get(n) : (x = { text: null, icon: null }, v.set(n, x)), o.textBox && (x.text = c.box), o.iconBox && (x.icon = d.box);
            }
            if (g) {
              let v = this.collisionCircleArrays[e];
              v === void 0 && (v = this.collisionCircleArrays[e] = []);
              for (let x = 0; x < g.circles.length; x += 4) v.push(g.circles[x + 0] - Ti), v.push(g.circles[x + 1] - Ti), v.push(g.circles[x + 2]), v.push(g.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(e, n, o, c) {
            let d;
            d = c === a.ao.vertical ? o.verticalPlacedTextSymbolIndex : { left: o.leftJustifiedTextSymbolIndex, center: o.centerJustifiedTextSymbolIndex, right: o.rightJustifiedTextSymbolIndex }[a.aG(n)];
            const g = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex];
            for (const v of g) v >= 0 && (e.text.placedSymbolArray.get(v).crossTileID = d >= 0 && v !== d ? 0 : o.crossTileID);
          }
          markUsedOrientation(e, n, o) {
            const c = n === a.ao.horizontal || n === a.ao.horizontalOnly ? n : 0, d = n === a.ao.vertical ? n : 0, g = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex];
            for (const v of g) e.text.placedSymbolArray.get(v).placedOrientation = c;
            o.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = d);
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const n = this.prevPlacement;
            let o = !1;
            this.prevZoomAdjustment = n ? n.zoomAdjustment(this.transform.zoom) : 0;
            const c = n ? n.symbolFadeChange(e) : 1, d = n ? n.opacities : {}, g = n ? n.variableOffsets : {}, v = n ? n.placedOrientations : {};
            for (const x in this.placements) {
              const M = this.placements[x], C = d[x];
              C ? (this.opacities[x] = new si(C, c, M.text, M.icon), o = o || M.text !== C.text.placed || M.icon !== C.icon.placed) : (this.opacities[x] = new si(null, c, M.text, M.icon, M.skipFade), o = o || M.text || M.icon);
            }
            for (const x in d) {
              const M = d[x];
              if (!this.opacities[x]) {
                const C = new si(M, c, !1, !1);
                C.isHidden() || (this.opacities[x] = C, o = o || M.text.placed || M.icon.placed);
              }
            }
            for (const x in g) this.variableOffsets[x] || !this.opacities[x] || this.opacities[x].isHidden() || (this.variableOffsets[x] = g[x]);
            for (const x in v) this.placedOrientations[x] || !this.opacities[x] || this.opacities[x].isHidden() || (this.placedOrientations[x] = v[x]);
            if (n && n.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            o ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = n ? n.lastPlacementChangeTime : e);
          }
          updateLayerOpacities(e, n) {
            const o = {};
            for (const c of n) {
              const d = c.getBucket(e);
              d && c.latestFeatureIndex && e.id === d.layerIds[0] && this.updateBucketOpacities(d, c.tileID, o, c.collisionBoxArray);
            }
          }
          updateBucketOpacities(e, n, o, c) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const d = e.layers[0], g = d.layout, v = new si(null, 0, !1, !1, !0), x = g.get("text-allow-overlap"), M = g.get("icon-allow-overlap"), C = d._unevaluatedLayout.hasValue("text-variable-anchor") || d._unevaluatedLayout.hasValue("text-variable-anchor-offset"), k = g.get("text-rotation-alignment") === "map", A = g.get("text-pitch-alignment") === "map", R = g.get("icon-text-fit") !== "none", O = new si(null, 0, x && (M || !e.hasIconData() || g.get("icon-optional")), M && (x || !e.hasTextData() || g.get("text-optional")), !0);
            !e.collisionArrays && c && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(c);
            const G = (q, W, J) => {
              for (let K = 0; K < W / 4; K++) q.opacityVertexArray.emplaceBack(J);
              q.hasVisibleVertices = q.hasVisibleVertices || J !== Gs;
            }, Z = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let q = 0; q < e.symbolInstances.length; q++) {
              const W = e.symbolInstances.get(q), { numHorizontalGlyphVertices: J, numVerticalGlyphVertices: K, crossTileID: te } = W;
              let se = this.opacities[te];
              o[te] ? se = v : se || (se = O, this.opacities[te] = se), o[te] = !0;
              const Y = W.numIconVertices > 0, pe = this.placedOrientations[W.crossTileID], be = pe === a.ao.vertical, ge = pe === a.ao.horizontal || pe === a.ao.horizontalOnly;
              if (J > 0 || K > 0) {
                const xe = Ll(se.text);
                G(e.text, J, be ? Gs : xe), G(e.text, K, ge ? Gs : xe);
                const Le = se.text.isHidden();
                [W.rightJustifiedTextSymbolIndex, W.centerJustifiedTextSymbolIndex, W.leftJustifiedTextSymbolIndex].forEach((et) => {
                  et >= 0 && (e.text.placedSymbolArray.get(et).hidden = Le || be ? 1 : 0);
                }), W.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(W.verticalPlacedTextSymbolIndex).hidden = Le || ge ? 1 : 0);
                const Oe = this.variableOffsets[W.crossTileID];
                Oe && this.markUsedJustification(e, Oe.anchor, W, pe);
                const Ie = this.placedOrientations[W.crossTileID];
                Ie && (this.markUsedJustification(e, "left", W, Ie), this.markUsedOrientation(e, Ie, W));
              }
              if (Y) {
                const xe = Ll(se.icon), Le = !(R && W.verticalPlacedIconSymbolIndex && be);
                W.placedIconSymbolIndex >= 0 && (G(e.icon, W.numIconVertices, Le ? xe : Gs), e.icon.placedSymbolArray.get(W.placedIconSymbolIndex).hidden = se.icon.isHidden()), W.verticalPlacedIconSymbolIndex >= 0 && (G(e.icon, W.numVerticalIconVertices, Le ? Gs : xe), e.icon.placedSymbolArray.get(W.verticalPlacedIconSymbolIndex).hidden = se.icon.isHidden());
              }
              const _e = Z && Z.has(q) ? Z.get(q) : { text: null, icon: null };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const xe = e.collisionArrays[q];
                if (xe) {
                  let Le = new a.P(0, 0);
                  if (xe.textBox || xe.verticalTextBox) {
                    let Oe = !0;
                    if (C) {
                      const Ie = this.variableOffsets[te];
                      Ie ? (Le = Gn(Ie.anchor, Ie.width, Ie.height, Ie.textOffset, Ie.textBoxScale), k && Le._rotate(A ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Oe = !1;
                    }
                    if (xe.textBox || xe.verticalTextBox) {
                      let Ie;
                      xe.textBox && (Ie = be), xe.verticalTextBox && (Ie = ge), Dl(e.textCollisionBox.collisionVertexArray, se.text.placed, !Oe || Ie, _e.text, Le.x, Le.y);
                    }
                  }
                  if (xe.iconBox || xe.verticalIconBox) {
                    const Oe = !!(!ge && xe.verticalIconBox);
                    let Ie;
                    xe.iconBox && (Ie = Oe), xe.verticalIconBox && (Ie = !Oe), Dl(e.iconCollisionBox.collisionVertexArray, se.icon.placed, Ie, _e.icon, R ? Le.x : 0, R ? Le.y : 0);
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5);
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e, n) {
            const o = this.zoomAtLastRecencyCheck === n ? 1 - this.zoomAdjustment(n) : 1;
            return this.zoomAtLastRecencyCheck = n, this.commitTime + this.fadeDuration * o > e;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function Dl(h, e, n, o, c, d) {
          o && o.length !== 0 || (o = [0, 0, 0, 0]);
          const g = o[0] - Ti, v = o[1] - Ti, x = o[2] - Ti, M = o[3] - Ti;
          h.emplaceBack(e ? 1 : 0, n ? 1 : 0, c || 0, d || 0, g, v), h.emplaceBack(e ? 1 : 0, n ? 1 : 0, c || 0, d || 0, x, v), h.emplaceBack(e ? 1 : 0, n ? 1 : 0, c || 0, d || 0, x, M), h.emplaceBack(e ? 1 : 0, n ? 1 : 0, c || 0, d || 0, g, M);
        }
        const cu = Math.pow(2, 25), uu = Math.pow(2, 24), Zs = Math.pow(2, 17), hu = Math.pow(2, 16), id = Math.pow(2, 9), rd = Math.pow(2, 8), nd = Math.pow(2, 1);
        function Ll(h) {
          if (h.opacity === 0 && !h.placed) return 0;
          if (h.opacity === 1 && h.placed) return 4294967295;
          const e = h.placed ? 1 : 0, n = Math.floor(127 * h.opacity);
          return n * cu + e * uu + n * Zs + e * hu + n * id + e * rd + n * nd + e;
        }
        const Gs = 0;
        class Fl {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e, n, o, c, d) {
            const g = this._bucketParts;
            for (; this._currentTileIndex < e.length; ) if (n.getBucketParts(g, c, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, d()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, g.sort((v, x) => v.sortKey - x.sortKey)); this._currentPartIndex < g.length; ) if (n.placeLayerBucketPart(g[this._currentPartIndex], this._seenCrossTileIDs, o), this._currentPartIndex++, d()) return !0;
            return !1;
          }
        }
        class Bl {
          constructor(e, n, o, c, d, g, v, x) {
            this.placement = new qn(e, n, g, v, x), this._currentPlacementIndex = o.length - 1, this._forceFullPlacement = c, this._showCollisionBoxes = d, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e, n, o) {
            const c = we.now(), d = () => !this._forceFullPlacement && we.now() - c > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const g = n[e[this._currentPlacementIndex]], v = this.placement.collisionIndex.transform.zoom;
              if (g.type === "symbol" && (!g.minzoom || g.minzoom <= v) && (!g.maxzoom || g.maxzoom > v)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Fl(g)), this._inProgressLayer.continuePlacement(o[g.source], this.placement, this._showCollisionBoxes, g, d)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(e) {
            return this.placement.commit(e), this.placement;
          }
        }
        const qs = 512 / a.$ / 2;
        class Ol {
          constructor(e, n, o) {
            this.tileID = e, this.bucketInstanceId = o, this._symbolsByKey = {};
            const c = /* @__PURE__ */ new Map();
            for (let d = 0; d < n.length; d++) {
              const g = n.get(d), v = g.key, x = c.get(v);
              x ? x.push(g) : c.set(v, [g]);
            }
            for (const [d, g] of c) {
              const v = { positions: g.map((x) => ({ x: Math.floor(x.anchorX * qs), y: Math.floor(x.anchorY * qs) })), crossTileIDs: g.map((x) => x.crossTileID) };
              if (v.positions.length > 128) {
                const x = new a.aI(v.positions.length, 16, Uint16Array);
                for (const { x: M, y: C } of v.positions) x.add(M, C);
                x.finish(), delete v.positions, v.index = x;
              }
              this._symbolsByKey[d] = v;
            }
          }
          getScaledCoordinates(e, n) {
            const { x: o, y: c, z: d } = this.tileID.canonical, { x: g, y: v, z: x } = n.canonical, M = qs / Math.pow(2, x - d), C = (v * a.$ + e.anchorY) * M, k = c * a.$ * qs;
            return { x: Math.floor((g * a.$ + e.anchorX) * M - o * a.$ * qs), y: Math.floor(C - k) };
          }
          findMatches(e, n, o) {
            const c = this.tileID.canonical.z < n.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - n.canonical.z);
            for (let d = 0; d < e.length; d++) {
              const g = e.get(d);
              if (g.crossTileID) continue;
              const v = this._symbolsByKey[g.key];
              if (!v) continue;
              const x = this.getScaledCoordinates(g, n);
              if (v.index) {
                const M = v.index.range(x.x - c, x.y - c, x.x + c, x.y + c).sort();
                for (const C of M) {
                  const k = v.crossTileIDs[C];
                  if (!o[k]) {
                    o[k] = !0, g.crossTileID = k;
                    break;
                  }
                }
              } else if (v.positions) for (let M = 0; M < v.positions.length; M++) {
                const C = v.positions[M], k = v.crossTileIDs[M];
                if (Math.abs(C.x - x.x) <= c && Math.abs(C.y - x.y) <= c && !o[k]) {
                  o[k] = !0, g.crossTileID = k;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(({ crossTileIDs: e }) => e);
          }
        }
        class jl {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class sd {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e) {
            const n = Math.round((e - this.lng) / 360);
            if (n !== 0) for (const o in this.indexes) {
              const c = this.indexes[o], d = {};
              for (const g in c) {
                const v = c[g];
                v.tileID = v.tileID.unwrapTo(v.tileID.wrap + n), d[v.tileID.key] = v;
              }
              this.indexes[o] = d;
            }
            this.lng = e;
          }
          addBucket(e, n, o) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === n.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
            }
            for (let d = 0; d < n.symbolInstances.length; d++) n.symbolInstances.get(d).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const c = this.usedCrossTileIDs[e.overscaledZ];
            for (const d in this.indexes) {
              const g = this.indexes[d];
              if (Number(d) > e.overscaledZ) for (const v in g) {
                const x = g[v];
                x.tileID.isChildOf(e) && x.findMatches(n.symbolInstances, e, c);
              }
              else {
                const v = g[e.scaledTo(Number(d)).key];
                v && v.findMatches(n.symbolInstances, e, c);
              }
            }
            for (let d = 0; d < n.symbolInstances.length; d++) {
              const g = n.symbolInstances.get(d);
              g.crossTileID || (g.crossTileID = o.generate(), c[g.crossTileID] = !0);
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Ol(e, n.symbolInstances, n.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(e, n) {
            for (const o of n.getCrossTileIDsLists()) for (const c of o) delete this.usedCrossTileIDs[e][c];
          }
          removeStaleBuckets(e) {
            let n = !1;
            for (const o in this.indexes) {
              const c = this.indexes[o];
              for (const d in c) e[c[d].bucketInstanceId] || (this.removeBucketCrossTileIDs(o, c[d]), delete c[d], n = !0);
            }
            return n;
          }
        }
        class Hs {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new jl(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e, n, o) {
            let c = this.layerIndexes[e.id];
            c === void 0 && (c = this.layerIndexes[e.id] = new sd());
            let d = !1;
            const g = {};
            c.handleWrapJump(o);
            for (const v of n) {
              const x = v.getBucket(e);
              x && e.id === x.layerIds[0] && (x.bucketInstanceId || (x.bucketInstanceId = ++this.maxBucketInstanceId), c.addBucket(v.tileID, x, this.crossTileIDs) && (d = !0), g[x.bucketInstanceId] = !0);
            }
            return c.removeStaleBuckets(g) && (d = !0), d;
          }
          pruneUnusedLayers(e) {
            const n = {};
            e.forEach((o) => {
              n[o] = !0;
            });
            for (const o in this.layerIndexes) n[o] || delete this.layerIndexes[o];
          }
        }
        var Io = "void main() {fragColor=vec4(1.0);}";
        const en = { prelude: Ft(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Ft("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Ft("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Ft(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Ft(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Ft(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Ft(Io, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Ft(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Ft(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Ft("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Ft("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: Ft(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: Ft("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Ft(Io, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Ft(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Ft(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Ft(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Ft(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Ft(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Ft(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Ft(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ft(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Ft(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Ft(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Ft(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Ft(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Ft(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Ft(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Ft(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Ft(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Ft("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Ft("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Ft("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Ft("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Ft(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Ft("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function Ft(h, e) {
          const n = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o = e.match(/in ([\w]+) ([\w]+)/g), c = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), d = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), g = d ? d.concat(c) : c, v = {};
          return { fragmentSource: h = h.replace(n, (x, M, C, k, A) => (v[A] = !0, M === "define" ? `
#ifndef HAS_UNIFORM_u_${A}
in ${C} ${k} ${A};
#else
uniform ${C} ${k} u_${A};
#endif
` : `
#ifdef HAS_UNIFORM_u_${A}
    ${C} ${k} ${A} = u_${A};
#endif
`)), vertexSource: e = e.replace(n, (x, M, C, k, A) => {
            const R = k === "float" ? "vec2" : "vec4", O = A.match(/color/) ? "color" : R;
            return v[A] ? M === "define" ? `
#ifndef HAS_UNIFORM_u_${A}
uniform lowp float u_${A}_t;
in ${C} ${R} a_${A};
out ${C} ${k} ${A};
#else
uniform ${C} ${k} u_${A};
#endif
` : O === "vec4" ? `
#ifndef HAS_UNIFORM_u_${A}
    ${A} = a_${A};
#else
    ${C} ${k} ${A} = u_${A};
#endif
` : `
#ifndef HAS_UNIFORM_u_${A}
    ${A} = unpack_mix_${O}(a_${A}, u_${A}_t);
#else
    ${C} ${k} ${A} = u_${A};
#endif
` : M === "define" ? `
#ifndef HAS_UNIFORM_u_${A}
uniform lowp float u_${A}_t;
in ${C} ${R} a_${A};
#else
uniform ${C} ${k} u_${A};
#endif
` : O === "vec4" ? `
#ifndef HAS_UNIFORM_u_${A}
    ${C} ${k} ${A} = a_${A};
#else
    ${C} ${k} ${A} = u_${A};
#endif
` : `
#ifndef HAS_UNIFORM_u_${A}
    ${C} ${k} ${A} = unpack_mix_${O}(a_${A}, u_${A}_t);
#else
    ${C} ${k} ${A} = u_${A};
#endif
`;
          }), staticAttributes: o, staticUniforms: g };
        }
        class ps {
          constructor(e, n, o) {
            this.vertexBuffer = e, this.indexBuffer = n, this.segments = o;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var Hn = a.aJ([{ name: "a_pos", type: "Int16", components: 2 }]);
        const In = "#define PROJECTION_MERCATOR", fs = "mercator";
        class Bt {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return fs;
          }
          get shaderDefine() {
            return In;
          }
          get shaderPreludeCode() {
            return en.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return en.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return a.aK.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(e) {
          }
          getMeshFromTileID(e, n, o, c, d) {
            if (this._cachedMesh) return this._cachedMesh;
            const g = new a.aL();
            g.emplaceBack(0, 0), g.emplaceBack(a.$, 0), g.emplaceBack(0, a.$), g.emplaceBack(a.$, a.$);
            const v = e.createVertexBuffer(g, Hn.members), x = a.aM.simpleSegment(0, 0, 4, 2), M = new a.aN();
            M.emplaceBack(1, 0, 2), M.emplaceBack(1, 2, 3);
            const C = e.createIndexBuffer(M);
            return this._cachedMesh = new ps(v, C, x), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(e) {
          }
        }
        class ms {
          constructor(e = 0, n = 0, o = 0, c = 0) {
            if (isNaN(e) || e < 0 || isNaN(n) || n < 0 || isNaN(o) || o < 0 || isNaN(c) || c < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = n, this.left = o, this.right = c;
          }
          interpolate(e, n, o) {
            return n.top != null && e.top != null && (this.top = a.C.number(e.top, n.top, o)), n.bottom != null && e.bottom != null && (this.bottom = a.C.number(e.bottom, n.bottom, o)), n.left != null && e.left != null && (this.left = a.C.number(e.left, n.left, o)), n.right != null && e.right != null && (this.right = a.C.number(e.right, n.right, o)), this;
          }
          getCenter(e, n) {
            const o = a.ah((this.left + e - this.right) / 2, 0, e), c = a.ah((this.top + n - this.bottom) / 2, 0, n);
            return new a.P(o, c);
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
          }
          clone() {
            return new ms(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function wa(h, e) {
          if (!h.renderWorldCopies || h.lngRange) return;
          const n = e.lng - h.center.lng;
          e.lng += n > 180 ? -360 : n < -180 ? 360 : 0;
        }
        function Ta(h) {
          return Math.max(0, Math.floor(h));
        }
        class yr {
          constructor(e, n, o, c, d, g) {
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = g === void 0 || !!g, this._minZoom = n || 0, this._maxZoom = o || 22, this._minPitch = c ?? 0, this._maxPitch = d ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new a.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Ta(this._zoom), this._scale = a.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new ms(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
          }
          apply(e, n, o) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = Ta(this._zoom), this._scale = a.af(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new ms(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !o && e.autoCalculateNearFarZ, n && this._constrain(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e;
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new a.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(e) {
            const n = a.aO(e, -180, 180) * Math.PI / 180;
            var o, c, d, g, v, x, M, C, k;
            this._bearingInRadians !== n && (this._unmodified = !1, this._bearingInRadians = n, this._calcMatrices(), this._rotationMatrix = ue(), o = this._rotationMatrix, d = -this._bearingInRadians, g = (c = this._rotationMatrix)[0], v = c[1], x = c[2], M = c[3], C = Math.sin(d), k = Math.cos(d), o[0] = g * k + x * C, o[1] = v * k + M * C, o[2] = g * -C + x * k, o[3] = v * -C + M * k);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(e) {
            const n = a.ah(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== n && (this._unmodified = !1, this._pitchInRadians = n, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(e) {
            const n = e / 180 * Math.PI;
            this._rollInRadians !== n && (this._unmodified = !1, this._rollInRadians = n, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return a.aP(this._fovInRadians);
          }
          setFov(e) {
            e = a.ah(e, 0.1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = a.ae(e), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e) {
            const n = this.getConstrained(this._center, e).zoom;
            this._zoom !== n && (this._unmodified = !1, this._zoom = n, this._tileZoom = Math.max(0, Math.floor(n)), this._scale = a.af(n), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e, n) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = n, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices();
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e);
          }
          interpolatePadding(e, n, o) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, n, o), this._constrain(), this._calcMatrices();
          }
          resize(e, n, o = !0) {
            this._width = e, this._height = n, o && this._constrain(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new ae([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-a.ai, a.ai]);
          }
          getConstrained(e, n) {
            return this._callbacks.getConstrained(e, n);
          }
          getCameraQueryGeometry(e, n) {
            if (n.length === 1) return [n[0], e];
            {
              const { minX: o, minY: c, maxX: d, maxY: g } = a.a2.fromPoints(n).extend(e);
              return [new a.P(o, c), new a.P(d, c), new a.P(d, g), new a.P(o, g), new a.P(o, c)];
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified, { center: n, zoom: o } = this.getConstrained(this.center, this.zoom);
            this.setCenter(n), this.setZoom(o), this._unmodified = e, this._constraining = !1;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = a.ag(new Float64Array(16));
              a.N(e, e, [this._width / 2, -this._height / 2, 1]), a.M(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = a.ag(new Float64Array(16)), a.N(e, e, [1, -1, 1]), a.M(e, e, [-1, -1, 0]), a.N(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e, n, o, c) {
            const d = o !== void 0 ? o : this.bearing, g = c = c !== void 0 ? c : this.pitch, v = a.a1.fromLngLat(e, n), x = -Math.cos(a.ae(g)), M = Math.sin(a.ae(g)), C = M * Math.sin(a.ae(d)), k = -M * Math.cos(a.ae(d));
            let A = this.elevation;
            const R = n - A;
            let O;
            x * R >= 0 || Math.abs(x) < 0.1 ? (O = 1e4, A = n + O * x) : O = -R / x;
            let G, Z, q = a.aQ(1, v.y), W = 0;
            do {
              if (W += 1, W > 10) break;
              Z = O / q, G = new a.a1(v.x + C * Z, v.y + k * Z), q = 1 / G.meterInMercatorCoordinateUnits();
            } while (Math.abs(O - Z * q) > 1e-12);
            return { center: G.toLngLat(), elevation: A, zoom: a.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / Z / this.tileSize) };
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const n = a.aj(1, this.center.lat) * this.worldSize, o = this.cameraToCenterDistance / n, c = a.a1.fromLngLat(this.center, this.elevation), d = me(this.center, this.elevation, this.pitch, this.bearing, o);
            this._elevation = e;
            const g = this.calculateCenterFromCameraLngLatAlt(d.toLngLat(), a.aQ(d.z, c.y), this.bearing, this.pitch);
            this._elevation = g.elevation, this._center = g.center, this.setZoom(g.zoom);
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new a.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const e = a.aj(1, this.center.lat) * this.worldSize;
            return me(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat();
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const n = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / n, e.canonical.y / n, 1 / n / a.$, 1 / n / a.$];
          }
        }
        class qi {
          constructor(e, n) {
            this.min = e, this.max = n, this.center = a.aR([], a.aS([], this.min, this.max), 0.5);
          }
          quadrant(e) {
            const n = [e % 2 == 0, e < 2], o = a.aT(this.min), c = a.aT(this.max);
            for (let d = 0; d < n.length; d++) o[d] = n[d] ? this.min[d] : this.center[d], c[d] = n[d] ? this.center[d] : this.max[d];
            return c[2] = this.max[2], new qi(o, c);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          intersectsFrustum(e) {
            let n = !0;
            for (let o = 0; o < e.planes.length; o++) {
              const c = this.intersectsPlane(e.planes[o]);
              if (c === 0) return 0;
              c === 1 && (n = !1);
            }
            return n ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(e) {
            let n = e[3], o = e[3];
            for (let c = 0; c < 3; c++) e[c] > 0 ? (n += e[c] * this.min[c], o += e[c] * this.max[c]) : (o += e[c] * this.min[c], n += e[c] * this.max[c]);
            return n >= 0 ? 2 : o < 0 ? 0 : 1;
          }
        }
        class vr {
          distanceToTile2d(e, n, o, c) {
            const d = c.distanceX([e, n]), g = c.distanceY([e, n]);
            return Math.hypot(d, g);
          }
          getWrap(e, n, o) {
            return o;
          }
          getTileBoundingVolume(e, n, o, c) {
            var d, g;
            let v = 0, x = 0;
            if (c != null && c.terrain) {
              const C = new a.Z(e.z, n, e.z, e.x, e.y), k = c.terrain.getMinMaxElevation(C);
              v = (d = k.minElevation) !== null && d !== void 0 ? d : Math.min(0, o), x = (g = k.maxElevation) !== null && g !== void 0 ? g : Math.max(0, o);
            }
            const M = 1 << e.z;
            return new qi([n + e.x / M, e.y / M, v], [n + (e.x + 1) / M, (e.y + 1) / M, x]);
          }
          allowVariableZoom(e, n) {
            const o = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, c = a.ah(78.5 - o / 2, 0, 60);
            return !!n.terrain || e.pitch > c;
          }
          allowWorldCopies() {
            return !0;
          }
          prepareNextFrame() {
          }
        }
        class Di {
          constructor(e, n, o) {
            this.points = e, this.planes = n, this.aabb = o;
          }
          static fromInvProjectionMatrix(e, n = 1, o = 0, c, d) {
            const g = d ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], v = Math.pow(2, o), x = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((A) => function(R, O, G, Z) {
              const q = a.aw([], R, O), W = 1 / q[3] / G * Z;
              return a.aY(q, q, [W, W, 1 / q[3], W]);
            }(A, e, n, v));
            c && function(A, R, O, G) {
              const Z = G ? 4 : 0, q = G ? 0 : 4;
              let W = 0;
              const J = [], K = [];
              for (let Y = 0; Y < 4; Y++) {
                const pe = a.aU([], A[Y + q], A[Y + Z]), be = a.aZ(pe);
                a.aR(pe, pe, 1 / be), J.push(be), K.push(pe);
              }
              for (let Y = 0; Y < 4; Y++) {
                const pe = a.a_(A[Y + Z], K[Y], O);
                W = pe !== null && pe >= 0 ? Math.max(W, pe) : Math.max(W, J[Y]);
              }
              const te = function(Y, pe) {
                const be = a.aU([], Y[pe[0]], Y[pe[1]]), ge = a.aU([], Y[pe[2]], Y[pe[1]]), _e = [0, 0, 0, 0];
                return a.aV(_e, a.aW([], be, ge)), _e[3] = -a.aX(_e, Y[pe[0]]), _e;
              }(A, R), se = function(Y, pe) {
                const be = a.a$(Y), ge = a.b0([], Y, 1 / be), _e = a.aU([], pe, a.aR([], ge, a.aX(pe, ge))), xe = a.a$(_e);
                if (xe > 0) {
                  const Le = Math.sqrt(1 - ge[3] * ge[3]), Oe = a.aR([], ge, -ge[3]), Ie = a.aS([], Oe, a.aR([], _e, Le / xe));
                  return a.b1(pe, Ie);
                }
                return null;
              }(O, te);
              if (se !== null) {
                const Y = se / a.aX(K[0], te);
                W = Math.min(W, Y);
              }
              for (let Y = 0; Y < 4; Y++) {
                const pe = Math.min(W, J[Y]);
                A[Y + q] = [A[Y + Z][0] + K[Y][0] * pe, A[Y + Z][1] + K[Y][1] * pe, A[Y + Z][2] + K[Y][2] * pe, 1];
              }
            }(x, g[0], c, d);
            const M = g.map((A) => {
              const R = a.aU([], x[A[0]], x[A[1]]), O = a.aU([], x[A[2]], x[A[1]]), G = a.aV([], a.aW([], R, O)), Z = -a.aX(G, x[A[1]]);
              return G.concat(Z);
            }), C = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], k = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const A of x) for (let R = 0; R < 3; R++) C[R] = Math.min(C[R], A[R]), k[R] = Math.max(k[R], A[R]);
            return new Di(x, M, new qi(C, k));
          }
        }
        class oi {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, n, o) {
            return this._helper.interpolatePadding(e, n, o);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, n, o = !0) {
            this._helper.resize(e, n, o);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, n) {
            this._helper.overrideNearFarZ(e, n);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e, n) {
          }
          constructor(e, n, o, c, d) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new yr({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (g, v) => this.getConstrained(g, v) }, e, n, o, c, d), this._coveringTilesDetailsProvider = new vr();
          }
          clone() {
            const e = new oi();
            return e.apply(this), e;
          }
          apply(e, n, o) {
            this._helper.apply(e, n, o);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e) {
            const n = [new a.b2(0, e)];
            if (this._helper._renderWorldCopies) {
              const o = this.screenPointToMercatorCoordinate(new a.P(0, 0)), c = this.screenPointToMercatorCoordinate(new a.P(this._helper._width, 0)), d = this.screenPointToMercatorCoordinate(new a.P(this._helper._width, this._helper._height)), g = this.screenPointToMercatorCoordinate(new a.P(0, this._helper._height)), v = Math.floor(Math.min(o.x, c.x, d.x, g.x)), x = Math.floor(Math.max(o.x, c.x, d.x, g.x)), M = 1;
              for (let C = v - M; C <= x + M; C++) C !== 0 && n.push(new a.b2(C, e));
            }
            return n;
          }
          getCameraFrustum() {
            return Di.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            const n = this.screenPointToLocation(this.centerPoint, e), o = e ? e.getElevationForLngLatZoom(n, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(o);
          }
          setLocationAtPoint(e, n) {
            const o = a.aj(this.elevation, this.center.lat), c = this.screenPointToMercatorCoordinateAtZ(n, o), d = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, o), g = a.a1.fromLngLat(e), v = new a.a1(g.x - (c.x - d.x), g.y - (c.y - d.y));
            this.setCenter(v == null ? void 0 : v.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(e, n) {
            return n ? this.coordinatePoint(a.a1.fromLngLat(e), n.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(a.a1.fromLngLat(e));
          }
          screenPointToLocation(e, n) {
            var o;
            return (o = this.screenPointToMercatorCoordinate(e, n)) === null || o === void 0 ? void 0 : o.toLngLat();
          }
          screenPointToMercatorCoordinate(e, n) {
            if (n) {
              const o = n.pointCoordinate(e);
              if (o != null) return o;
            }
            return this.screenPointToMercatorCoordinateAtZ(e);
          }
          screenPointToMercatorCoordinateAtZ(e, n) {
            const o = n || 0, c = [e.x, e.y, 0, 1], d = [e.x, e.y, 1, 1];
            a.aw(c, c, this._pixelMatrixInverse), a.aw(d, d, this._pixelMatrixInverse);
            const g = c[3], v = d[3], x = c[1] / g, M = d[1] / v, C = c[2] / g, k = d[2] / v, A = C === k ? 0 : (o - C) / (k - C);
            return new a.a1(a.C.number(c[0] / g, d[0] / v, A) / this.worldSize, a.C.number(x, M, A) / this.worldSize, o);
          }
          coordinatePoint(e, n = 0, o = this._pixelMatrix) {
            const c = [e.x * this.worldSize, e.y * this.worldSize, n, 1];
            return a.aw(c, c, o), new a.P(c[0] / c[3], c[1] / c[3]);
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - ie(this));
            return new ae().extend(this.screenPointToLocation(new a.P(0, e))).extend(this.screenPointToLocation(new a.P(this._helper._width, e))).extend(this.screenPointToLocation(new a.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new a.P(0, this._helper._height)));
          }
          isPointOnMapSurface(e, n) {
            return n ? n.pointCoordinate(e) != null : e.y > this.height / 2 - ie(this);
          }
          calculatePosMatrix(e, n = !1, o) {
            var c;
            const d = (c = e.key) !== null && c !== void 0 ? c : a.b3(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), g = n ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (g.has(d)) {
              const M = g.get(d);
              return o ? M.f32 : M.f64;
            }
            const v = le(e, this.worldSize);
            a.O(v, n ? this._alignedProjMatrix : this._viewProjMatrix, v);
            const x = { f64: v, f32: new Float32Array(v) };
            return g.set(d, x), o ? x.f32 : x.f64;
          }
          calculateFogMatrix(e) {
            const n = e.key, o = this._fogMatrixCacheF32;
            if (o.has(n)) return o.get(n);
            const c = le(e, this.worldSize);
            return a.O(c, this._fogMatrix, c), o.set(n, new Float32Array(c)), o.get(n);
          }
          getConstrained(e, n) {
            n = a.ah(+n, this.minZoom, this.maxZoom);
            const o = { center: new a.S(e.lng, e.lat), zoom: n };
            let c = this._helper._lngRange;
            !this._helper._renderWorldCopies && c === null && (c = [-179.9999999999, 179.9999999999]);
            const d = this.tileSize * a.af(o.zoom);
            let g = 0, v = d, x = 0, M = d, C = 0, k = 0;
            const { x: A, y: R } = this.size;
            if (this._helper._latRange) {
              const J = this._helper._latRange;
              g = a.U(J[1]) * d, v = a.U(J[0]) * d, v - g < R && (C = R / (v - g));
            }
            c && (x = a.aO(a.V(c[0]) * d, 0, d), M = a.aO(a.V(c[1]) * d, 0, d), M < x && (M += d), M - x < A && (k = A / (M - x)));
            const { x: O, y: G } = N(d, e);
            let Z, q;
            const W = Math.max(k || 0, C || 0);
            if (W) {
              const J = new a.P(k ? (M + x) / 2 : O, C ? (v + g) / 2 : G);
              return o.center = X(d, J).wrap(), o.zoom += a.ak(W), o;
            }
            if (this._helper._latRange) {
              const J = R / 2;
              G - J < g && (q = g + J), G + J > v && (q = v - J);
            }
            if (c) {
              const J = (x + M) / 2;
              let K = O;
              this._helper._renderWorldCopies && (K = a.aO(O, J - d / 2, J + d / 2));
              const te = A / 2;
              K - te < x && (Z = x + te), K + te > M && (Z = M - te);
            }
            if (Z !== void 0 || q !== void 0) {
              const J = new a.P(Z ?? O, q ?? G);
              o.center = X(d, J).wrap();
            }
            return o;
          }
          calculateCenterFromCameraLngLatAlt(e, n, o, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, n, o, c);
          }
          _calculateNearFarZIfNeeded(e, n, o) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const c = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), d = e - c * this._helper._pixelPerMeter / Math.cos(n), g = c < 0 ? d : e, v = Math.PI / 2 + this.pitchInRadians, x = a.ae(this.fov) * (Math.abs(Math.cos(a.ae(this.roll))) * this.height + Math.abs(Math.sin(a.ae(this.roll))) * this.width) / this.height * (0.5 + o.y / this.height), M = Math.sin(x) * g / Math.sin(a.ah(Math.PI - v - x, 0.01, Math.PI - 0.01)), C = ie(this), k = Math.atan(C / this._helper.cameraToCenterDistance), A = a.ae(0.75), R = k > A ? 2 * k * (0.5 + o.y / (2 * C)) : A, O = Math.sin(R) * g / Math.sin(a.ah(Math.PI - v - R, 0.01, Math.PI - 0.01)), G = Math.min(M, O);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - n) * G + g), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset, n = N(this.worldSize, this.center), o = n.x, c = n.y;
            this._helper._pixelPerMeter = a.aj(1, this.center.lat) * this.worldSize;
            const d = a.ae(Math.min(this.pitch, j)), g = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(d));
            let v;
            this._calculateNearFarZIfNeeded(g, d, e), v = new Float64Array(16), a.b4(v, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), a.aq(this._invProjMatrix, v), v[8] = 2 * -e.x / this._helper._width, v[9] = 2 * e.y / this._helper._height, this._projectionMatrix = a.b5(v), a.N(v, v, [1, -1, 1]), a.M(v, v, [0, 0, -this._helper.cameraToCenterDistance]), a.b6(v, v, -this.rollInRadians), a.b7(v, v, this.pitchInRadians), a.b6(v, v, -this.bearingInRadians), a.M(v, v, [-o, -c, 0]), this._mercatorMatrix = a.N([], v, [this.worldSize, this.worldSize, this.worldSize]), a.N(v, v, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = a.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, v), a.M(v, v, [0, 0, -this.elevation]), this._viewProjMatrix = v, this._invViewProjMatrix = a.aq([], v);
            const x = [0, 0, -1, 1];
            a.aw(x, x, this._invViewProjMatrix), this._cameraPosition = [x[0] / x[3], x[1] / x[3], x[2] / x[3]], this._fogMatrix = new Float64Array(16), a.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, g, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, a.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), a.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), a.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), a.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), a.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), a.M(this._fogMatrix, this._fogMatrix, [-o, -c, 0]), a.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), a.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = a.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, v);
            const M = this._helper._width % 2 / 2, C = this._helper._height % 2 / 2, k = Math.cos(this.bearingInRadians), A = Math.sin(-this.bearingInRadians), R = o - Math.round(o) + k * M + A * C, O = c - Math.round(c) + k * C + A * M, G = new Float64Array(v);
            if (a.M(G, G, [R > 0.5 ? R - 1 : R, O > 0.5 ? O - 1 : O, 0]), this._alignedProjMatrix = G, v = a.aq(new Float64Array(16), this._pixelMatrix), !v) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = v, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new a.P(0, 0)), n = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return a.aw(n, n, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e = a.aj(1, this.center.lat) * this.worldSize;
            return me(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat();
          }
          lngLatToCameraDepth(e, n) {
            const o = a.a1.fromLngLat(e), c = [o.x * this.worldSize, o.y * this.worldSize, n, 1];
            return a.aw(c, c, this._viewProjMatrix), c[2] / c[3];
          }
          getProjectionData(e) {
            const { overscaledTileID: n, aligned: o, applyTerrainMatrix: c } = e, d = this._helper.getMercatorTileCoordinates(n), g = n ? this.calculatePosMatrix(n, o, !0) : null;
            let v;
            return v = n && n.terrainRttPosMatrix32f && c ? n.terrainRttPosMatrix32f : g || a.b8(), { mainMatrix: v, tileMercatorCoords: d, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: v };
          }
          isLocationOccluded(e) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e, n, o) {
            return 1;
          }
          transformLightDirection(e) {
            return a.aT(e);
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e, n, o, c) {
            const d = this.calculatePosMatrix(o);
            let g;
            c ? (g = [e, n, c(e, n), 1], a.aw(g, g, d)) : (g = [e, n, 0, 1], Us(g, g, d));
            const v = g[3];
            return { point: new a.P(g[0] / v, g[1] / v), signedDistanceFromCamera: v, isOccluded: !1 };
          }
          populateCache(e) {
            for (const n of e) this.calculatePosMatrix(n);
          }
          getMatrixForModel(e, n) {
            const o = a.a1.fromLngLat(e, n), c = o.meterInMercatorCoordinateUnits(), d = a.b9();
            return a.M(d, d, [o.x, o.y, o.z]), a.b6(d, d, Math.PI), a.b7(d, d, Math.PI / 2), a.N(d, d, [-c, c, c]), d;
          }
          getProjectionDataForCustomLayer(e = !0) {
            const n = new a.Z(0, 0, 0, 0, 0), o = this.getProjectionData({ overscaledTileID: n, applyGlobeMatrix: e }), c = le(n, this.worldSize);
            a.O(c, this._viewProjMatrix, c), o.tileMercatorCoords = [0, 0, 1, 1];
            const d = [a.$, a.$, this.worldSize / this._helper.pixelsPerMeter], g = a.ba();
            return a.N(g, c, d), o.fallbackMatrix = g, o.mainMatrix = g, o;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e);
          }
        }
        function du() {
          a.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function xr(h) {
          if (h.useSlerp) if (h.k < 1) {
            const e = a.bb(h.startEulerAngles.roll, h.startEulerAngles.pitch, h.startEulerAngles.bearing), n = a.bb(h.endEulerAngles.roll, h.endEulerAngles.pitch, h.endEulerAngles.bearing), o = new Float64Array(4);
            a.bc(o, e, n, h.k);
            const c = a.bd(o);
            h.tr.setRoll(c.roll), h.tr.setPitch(c.pitch), h.tr.setBearing(c.bearing);
          } else h.tr.setRoll(h.endEulerAngles.roll), h.tr.setPitch(h.endEulerAngles.pitch), h.tr.setBearing(h.endEulerAngles.bearing);
          else h.tr.setRoll(a.C.number(h.startEulerAngles.roll, h.endEulerAngles.roll, h.k)), h.tr.setPitch(a.C.number(h.startEulerAngles.pitch, h.endEulerAngles.pitch, h.k)), h.tr.setBearing(a.C.number(h.startEulerAngles.bearing, h.endEulerAngles.bearing, h.k));
        }
        function Lr(h, e, n, o, c) {
          const d = c.padding, g = N(c.worldSize, n.getNorthWest()), v = N(c.worldSize, n.getNorthEast()), x = N(c.worldSize, n.getSouthEast()), M = N(c.worldSize, n.getSouthWest()), C = a.ae(-o), k = g.rotate(C), A = v.rotate(C), R = x.rotate(C), O = M.rotate(C), G = new a.P(Math.max(k.x, A.x, O.x, R.x), Math.max(k.y, A.y, O.y, R.y)), Z = new a.P(Math.min(k.x, A.x, O.x, R.x), Math.min(k.y, A.y, O.y, R.y)), q = G.sub(Z), W = (c.width - (d.left + d.right + e.left + e.right)) / q.x, J = (c.height - (d.top + d.bottom + e.top + e.bottom)) / q.y;
          if (J < 0 || W < 0) return void du();
          const K = Math.min(a.ak(c.scale * Math.min(W, J)), h.maxZoom), te = a.P.convert(h.offset), se = new a.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(a.ae(o)), Y = te.add(se).mult(c.scale / a.af(K));
          return { center: X(c.worldSize, g.add(x).div(2).sub(Y)), zoom: K, bearing: o };
        }
        class dr {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(e, n) {
            const o = e.mag(), c = Math.abs(ie(n));
            return { easingOffset: e.mult(Math.min(0.75 * c / o, 1)), easingCenter: n.center };
          }
          handleMapControlsRollPitchBearingZoom(e, n) {
            e.bearingDelta && n.setBearing(n.bearing + e.bearingDelta), e.pitchDelta && n.setPitch(n.pitch + e.pitchDelta), e.rollDelta && n.setRoll(n.roll + e.rollDelta), e.zoomDelta && n.setZoom(n.zoom + e.zoomDelta);
          }
          handleMapControlsPan(e, n, o) {
            e.around.distSqr(n.centerPoint) < 0.01 || n.setLocationAtPoint(o, e.around);
          }
          cameraForBoxAndBearing(e, n, o, c, d) {
            return Lr(e, n, o, c, d);
          }
          handleJumpToCenterZoom(e, n) {
            e.zoom !== (n.zoom !== void 0 ? +n.zoom : e.zoom) && e.setZoom(+n.zoom), n.center !== void 0 && e.setCenter(a.S.convert(n.center));
          }
          handleEaseTo(e, n) {
            const o = e.zoom, c = e.padding, d = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, g = { roll: n.roll === void 0 ? e.roll : n.roll, pitch: n.pitch === void 0 ? e.pitch : n.pitch, bearing: n.bearing === void 0 ? e.bearing : n.bearing }, v = n.zoom !== void 0, x = !e.isPaddingEqual(n.padding);
            let M = !1;
            const C = v ? +n.zoom : e.zoom;
            let k = e.centerPoint.add(n.offsetAsPoint);
            const A = e.screenPointToLocation(k), { center: R, zoom: O } = e.getConstrained(a.S.convert(n.center || A), C ?? o);
            wa(e, R);
            const G = N(e.worldSize, A), Z = N(e.worldSize, R).sub(G), q = a.af(O - o);
            return M = O !== o, { easeFunc: (W) => {
              if (M && e.setZoom(a.C.number(o, O, W)), a.be(d, g) || xr({ startEulerAngles: d, endEulerAngles: g, tr: e, k: W, useSlerp: d.roll != g.roll }), x && (e.interpolatePadding(c, n.padding, W), k = e.centerPoint.add(n.offsetAsPoint)), n.around) e.setLocationAtPoint(n.around, n.aroundPoint);
              else {
                const J = a.af(e.zoom - o), K = O > o ? Math.min(2, q) : Math.max(0.5, q), te = Math.pow(K, 1 - W), se = X(e.worldSize, G.add(Z.mult(W * te)).mult(J));
                e.setLocationAtPoint(e.renderWorldCopies ? se.wrap() : se, k);
              }
            }, isZooming: M, elevationCenter: R };
          }
          handleFlyTo(e, n) {
            const o = n.zoom !== void 0, c = e.zoom, d = e.getConstrained(a.S.convert(n.center || n.locationAtOffset), o ? +n.zoom : c), g = d.center, v = d.zoom;
            wa(e, g);
            const x = N(e.worldSize, n.locationAtOffset), M = N(e.worldSize, g).sub(x), C = M.mag(), k = a.af(v - c);
            let A;
            if (n.minZoom !== void 0) {
              const R = Math.min(+n.minZoom, c, v), O = e.getConstrained(g, R).zoom;
              A = a.af(O - c);
            }
            return { easeFunc: (R, O, G, Z) => {
              e.setZoom(R === 1 ? v : c + a.ak(O));
              const q = R === 1 ? g : X(e.worldSize, x.add(M.mult(G)).mult(O));
              e.setLocationAtPoint(e.renderWorldCopies ? q.wrap() : q, Z);
            }, scaleOfZoom: k, targetCenter: g, scaleOfMinZoom: A, pixelPathLength: C };
          }
        }
        class hi {
          constructor(e, n, o) {
            this.blendFunction = e, this.blendColor = n, this.mask = o;
          }
        }
        hi.Replace = [1, 0], hi.disabled = new hi(hi.Replace, a.bf.transparent, [!1, !1, !1, !1]), hi.unblended = new hi(hi.Replace, a.bf.transparent, [!0, !0, !0, !0]), hi.alphaBlended = new hi([1, 771], a.bf.transparent, [!0, !0, !0, !0]);
        const gs = 2305;
        class ft {
          constructor(e, n, o) {
            this.enable = e, this.mode = n, this.frontFace = o;
          }
        }
        ft.disabled = new ft(!1, 1029, gs), ft.backCCW = new ft(!0, 1029, gs), ft.frontCCW = new ft(!0, 1028, gs);
        class Tt {
          constructor(e, n, o) {
            this.func = e, this.mask = n, this.range = o;
          }
        }
        Tt.ReadOnly = !1, Tt.ReadWrite = !0, Tt.disabled = new Tt(519, Tt.ReadOnly, [0, 1]);
        const En = 7680;
        class qt {
          constructor(e, n, o, c, d, g) {
            this.test = e, this.ref = n, this.mask = o, this.fail = c, this.depthFail = d, this.pass = g;
          }
        }
        qt.disabled = new qt({ func: 519, mask: 0 }, 0, 0, En, En, En);
        const Fr = /* @__PURE__ */ new WeakMap();
        function bn(h) {
          var e;
          if (Fr.has(h)) return Fr.get(h);
          {
            const n = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return Fr.set(h, n), n;
          }
        }
        class wn {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const n = e.context, o = n.gl;
            this._texFormat = o.RGBA, this._texType = o.UNSIGNED_BYTE;
            const c = new a.aL();
            c.emplaceBack(-1, -1), c.emplaceBack(2, -1), c.emplaceBack(-1, 2);
            const d = new a.aN();
            d.emplaceBack(0, 1, 2), this._fullscreenTriangle = new ps(n.createVertexBuffer(c, Hn.members), n.createIndexBuffer(d), a.aM.simpleSegment(0, 0, c.length, d.length)), this._resultBuffer = new Uint8Array(4), n.activeTexture.set(o.TEXTURE1);
            const g = o.createTexture();
            o.bindTexture(o.TEXTURE_2D, g), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.NEAREST), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.NEAREST), o.texImage2D(o.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = n.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(g), bn(o) && (this._pbo = o.createBuffer(), o.bindBuffer(o.PIXEL_PACK_BUFFER, this._pbo), o.bufferData(o.PIXEL_PACK_BUFFER, 4, o.STREAM_READ), o.bindBuffer(o.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(e, n) {
            const o = this._updateCount;
            return this._readbackQueue ? o >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : o >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, n), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context, n = e.gl;
            e.activeTexture.set(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(e, n) {
            const o = this._cachedRenderContext.context, c = o.gl;
            if (this._bindFramebuffer(), o.viewport.set([0, 0, this._texWidth, this._texHeight]), o.clear({ color: a.bf.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(o, c.TRIANGLES, Tt.disabled, qt.disabled, hi.unblended, ft.disabled, /* @__PURE__ */ ((d, g) => ({ u_input: d, u_output_expected: g }))(e, n), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && bn(c)) {
              c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo), c.readBuffer(c.COLOR_ATTACHMENT0), c.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), c.bindBuffer(c.PIXEL_PACK_BUFFER, null);
              const d = c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0);
              c.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: d };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && bn(e)) {
              const n = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (n === e.WAIT_FAILED) return a.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (n === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = wn._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(e) {
            let n = 0;
            return n += e[0] / 256, n += e[1] / 65536, n += e[2] / 16777216, e[3] < 127 && (n = -n), n / 128;
          }
        }
        const Sa = a.$ / 128;
        function Vl(h, e) {
          const n = h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1, o = n + (h.generateBorders ? 2 : 0), c = n + (h.extendToNorthPole || h.generateBorders ? 1 : 0) + (h.extendToSouthPole || h.generateBorders ? 1 : 0), d = o + 1, g = c + 1, v = h.generateBorders ? -1 : 0, x = h.generateBorders || h.extendToNorthPole ? -1 : 0, M = n + (h.generateBorders ? 1 : 0), C = n + (h.generateBorders || h.extendToSouthPole ? 1 : 0), k = d * g, A = o * c * 6, R = d * g > 65536;
          if (R && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const O = R || e === "32bit", G = new Int16Array(2 * k);
          let Z = 0;
          for (let J = x; J <= C; J++) for (let K = v; K <= M; K++) {
            let te = K / n * a.$;
            K === -1 && (te = -Sa), K === n + 1 && (te = a.$ + Sa);
            let se = J / n * a.$;
            J === -1 && (se = h.extendToNorthPole ? a.bh : -Sa), J === n + 1 && (se = h.extendToSouthPole ? a.bi : a.$ + Sa), G[Z++] = te, G[Z++] = se;
          }
          const q = O ? new Uint32Array(A) : new Uint16Array(A);
          let W = 0;
          for (let J = 0; J < c; J++) for (let K = 0; K < o; K++) {
            const te = K + 1 + J * d, se = K + (J + 1) * d, Y = K + 1 + (J + 1) * d;
            q[W++] = K + J * d, q[W++] = se, q[W++] = te, q[W++] = te, q[W++] = se, q[W++] = Y;
          }
          return { vertices: G.buffer.slice(0), indices: q.buffer.slice(0), uses32bitIndices: O };
        }
        const Ws = new a.aK({ fill: new a.bj(128, 2), line: new a.bj(512, 0), tile: new a.bj(128, 32), stencil: new a.bj(128, 1), circle: 3 });
        class Eo {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return en.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return en.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return Ws;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new wn(e));
            const n = a.U(this._errorQueryLatitudeDegrees), o = 2 * Math.atan(Math.exp(Math.PI - n * Math.PI * 2)) - 0.5 * Math.PI, c = this._errorMeasurement.updateErrorLoop(n, o), d = we.now();
            c !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = c, this._errorMeasurementLastChangeTime = d);
            const g = Math.min(Math.max((d - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = a.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, a.bl(g));
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e, n, o, c, d) {
            const g = (d === "stencil" ? Ws.stencil : Ws.tile).getGranularityForZoomLevel(n.z);
            return this._getMesh(e, { granularity: g, generateBorders: o, extendToNorthPole: n.y === 0 && c, extendToSouthPole: n.y === (1 << n.z) - 1 && c });
          }
          _getMesh(e, n) {
            const o = this._getMeshKey(n);
            if (o in this._tileMeshCache) return this._tileMeshCache[o];
            const c = function(d, g) {
              const v = Vl(g, "16bit"), x = a.aL.deserialize({ arrayBuffer: v.vertices, length: v.vertices.byteLength / 2 / 2 }), M = a.aN.deserialize({ arrayBuffer: v.indices, length: v.indices.byteLength / 2 / 3 });
              return new ps(d.createVertexBuffer(x, Hn.members), d.createIndexBuffer(M), a.aM.simpleSegment(0, 0, x.length, M.length));
            }(e, n);
            return this._tileMeshCache[o] = c, c;
          }
          recalculate(e) {
          }
          hasTransition() {
            const e = we.now();
            let n = !1;
            return n = n || (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, n = n || this._errorMeasurement && this._errorMeasurement.awaitingQuery, n;
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e;
          }
        }
        const Pa = new a.r({ type: new a.D(a.v.projection.type) });
        class Ma extends a.E {
          constructor(e) {
            super(), this._transitionable = new a.t(Pa), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new a.F(0)), this._mercatorProjection = new Bt(), this._verticalPerspectiveProjection = new Eo();
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof a.bm) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
          }
          getMeshFromTileID(e, n, o, c, d) {
            return this.currentProjection.getMeshFromTileID(e, n, o, c, d);
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator");
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
          }
        }
        function Ca(h) {
          const e = Xs(h.worldSize, h.center.lat);
          return 2 * Math.PI * e;
        }
        function tn(h, e, n, o, c) {
          const d = 1 / (1 << c), g = e / a.$ * d + o * d, v = a.bo((h / a.$ * d + n * d) * Math.PI * 2 + Math.PI, 2 * Math.PI), x = 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - 0.5 * Math.PI, M = Math.cos(x), C = new Float64Array(3);
          return C[0] = Math.sin(v) * M, C[1] = Math.sin(x), C[2] = Math.cos(v) * M, C;
        }
        function Hi(h) {
          return function(e, n) {
            const o = Math.cos(n), c = new Float64Array(3);
            return c[0] = Math.sin(e) * o, c[1] = Math.sin(n), c[2] = Math.cos(e) * o, c;
          }(h.lng * Math.PI / 180, h.lat * Math.PI / 180);
        }
        function Xs(h, e) {
          return h / (2 * Math.PI) / Math.cos(e * Math.PI / 180);
        }
        function Ao(h) {
          const e = Math.asin(h[1]) / Math.PI * 180, n = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
          if (n > 1e-6) {
            const o = h[0] / n, c = Math.acos(h[2] / n), d = (o > 0 ? c : -c) / Math.PI * 180;
            return new a.S(a.aO(d, -180, 180), e);
          }
          return new a.S(0, e);
        }
        function _s(h) {
          return Math.cos(h * Math.PI / 180);
        }
        function Si(h, e) {
          const n = _s(h), o = _s(e);
          return a.ak(o / n);
        }
        function pu(h, e) {
          const n = h.rotate(e.bearingInRadians), o = e.zoom + Si(e.center.lat, 0), c = a.bk(1 / _s(e.center.lat), 1 / _s(Math.min(Math.abs(e.center.lat), 60)), a.bn(o, 7, 3, 0, 1)), d = 360 / Ca({ worldSize: e.worldSize, center: { lat: e.center.lat } });
          return new a.S(e.center.lng - n.x * d * c, a.ah(e.center.lat + n.y * d, -a.ai, a.ai));
        }
        function ko(h) {
          const e = 0.5 * h, n = Math.sin(e), o = Math.cos(e);
          return Math.log(n + o) - Math.log(o - n);
        }
        function Nl(h, e, n, o) {
          const c = h.lat + n * o;
          if (Math.abs(n) > 1) {
            const d = (Math.sign(h.lat + n) !== Math.sign(h.lat) ? -Math.abs(h.lat) : Math.abs(h.lat)) * Math.PI / 180, g = Math.abs(h.lat + n) * Math.PI / 180, v = ko(d + o * (g - d)), x = ko(d), M = ko(g);
            return new a.S(h.lng + e * ((v - x) / (M - x)), c);
          }
          return new a.S(h.lng + e * o, c);
        }
        class od {
          constructor(e) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = e;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1;
          }
          getTileBoundingVolume(e, n, o, c) {
            const d = `${e.z}_${e.x}_${e.y}_${c != null && c.terrain ? "t" : ""}`, g = this._cache.get(d);
            if (g) return g;
            const v = this._cachePrevious.get(d);
            if (v) return this._cache.set(d, v), v;
            const x = this._boundingVolumeFactory(e, n, o, c);
            return this._cache.set(d, x), this._hadAnyChanges = !0, x;
          }
        }
        class Ks {
          constructor(e, n, o, c) {
            this.min = o, this.max = c, this.points = e, this.planes = n;
          }
          static fromAabb(e, n) {
            const o = [];
            for (let c = 0; c < 8; c++) o.push([1 & ~c ? e[0] : n[0], (c >> 1 & 1) == 1 ? n[1] : e[1], (c >> 2 & 1) == 1 ? n[2] : e[2]]);
            return new Ks(o, [[-1, 0, 0, n[0]], [1, 0, 0, -e[0]], [0, -1, 0, n[1]], [0, 1, 0, -e[1]], [0, 0, -1, n[2]], [0, 0, 1, -e[2]]], e, n);
          }
          static fromCenterSizeAngles(e, n, o) {
            const c = a.br([], o[0], o[1], o[2]), d = a.bs([], [n[0], 0, 0], c), g = a.bs([], [0, n[1], 0], c), v = a.bs([], [0, 0, n[2]], c), x = [...e], M = [...e];
            for (let k = 0; k < 8; k++) for (let A = 0; A < 3; A++) {
              const R = e[A] + d[A] * (1 & ~k ? -1 : 1) + g[A] * ((k >> 1 & 1) == 1 ? 1 : -1) + v[A] * ((k >> 2 & 1) == 1 ? 1 : -1);
              x[A] = Math.min(x[A], R), M[A] = Math.max(M[A], R);
            }
            const C = [];
            for (let k = 0; k < 8; k++) {
              const A = [...e];
              a.aS(A, A, a.aR([], d, 1 & ~k ? -1 : 1)), a.aS(A, A, a.aR([], g, (k >> 1 & 1) == 1 ? 1 : -1)), a.aS(A, A, a.aR([], v, (k >> 2 & 1) == 1 ? 1 : -1)), C.push(A);
            }
            return new Ks(C, [[...d, -a.aX(d, C[0])], [...g, -a.aX(g, C[0])], [...v, -a.aX(v, C[0])], [-d[0], -d[1], -d[2], -a.aX(d, C[7])], [-g[0], -g[1], -g[2], -a.aX(g, C[7])], [-v[0], -v[1], -v[2], -a.aX(v, C[7])]], x, M);
          }
          intersectsFrustum(e) {
            let n = !0;
            const o = this.points.length, c = this.planes.length, d = e.planes.length, g = e.points.length;
            for (let v = 0; v < d; v++) {
              const x = e.planes[v];
              let M = 0;
              for (let C = 0; C < o; C++) {
                const k = this.points[C];
                x[0] * k[0] + x[1] * k[1] + x[2] * k[2] + x[3] >= 0 && M++;
              }
              if (M === 0) return 0;
              M < o && (n = !1);
            }
            if (n) return 2;
            for (let v = 0; v < c; v++) {
              const x = this.planes[v];
              let M = 0;
              for (let C = 0; C < g; C++) {
                const k = e.points[C];
                x[0] * k[0] + x[1] * k[1] + x[2] * k[2] + x[3] >= 0 && M++;
              }
              if (M === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(e) {
            const n = this.points.length;
            let o = 0;
            for (let c = 0; c < n; c++) {
              const d = this.points[c];
              e[0] * d[0] + e[1] * d[1] + e[2] * d[2] + e[3] >= 0 && o++;
            }
            return o === n ? 2 : o === 0 ? 0 : 1;
          }
        }
        function nr(h, e, n) {
          const o = h - e;
          return o < 0 ? -o : Math.max(0, o - n);
        }
        function zo(h, e, n, o, c) {
          const d = h - n;
          let g;
          return g = d < 0 ? Math.min(-d, 1 + d - c) : d > 1 ? Math.min(Math.max(d - c, 0), 1 - d) : 0, Math.max(g, nr(e, o, c));
        }
        class Tn {
          constructor() {
            this._boundingVolumeCache = new od(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(e, n, o, c) {
            const d = 1 << o.z, g = 1 / d, v = o.x / d, x = o.y / d;
            let M = 2;
            return M = Math.min(M, zo(e, n, v, x, g)), M = Math.min(M, zo(e, n, v + 0.5, -x - g, g)), M = Math.min(M, zo(e, n, v + 0.5, 2 - x - g, g)), M;
          }
          getWrap(e, n, o) {
            const c = 1 << n.z, d = 1 / c, g = n.x / c, v = nr(e.x, g, d), x = nr(e.x, g - 1, d), M = nr(e.x, g + 1, d), C = Math.min(v, x, M);
            return C === M ? 1 : C === x ? -1 : 0;
          }
          allowVariableZoom(e, n) {
            return rt(e, n) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileBoundingVolume(e, n, o, c) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, n, o, c);
          }
          _computeTileBoundingVolume(e, n, o, c) {
            var d, g;
            let v = 0, x = 0;
            if (c != null && c.terrain) {
              const M = new a.Z(e.z, n, e.z, e.x, e.y), C = c.terrain.getMinMaxElevation(M);
              v = (d = C.minElevation) !== null && d !== void 0 ? d : Math.min(0, o), x = (g = C.maxElevation) !== null && g !== void 0 ? g : Math.max(0, o);
            }
            if (v /= a.bu, x /= a.bu, v += 1, x += 1, e.z <= 0) return Ks.fromAabb([-x, -x, -x], [x, x, x]);
            if (e.z === 1) return Ks.fromAabb([e.x === 0 ? -x : 0, e.y === 0 ? 0 : -x, -x], [e.x === 0 ? 0 : x, e.y === 0 ? x : 0, x]);
            {
              const M = [tn(0, 0, e.x, e.y, e.z), tn(a.$, 0, e.x, e.y, e.z), tn(a.$, a.$, e.x, e.y, e.z), tn(0, a.$, e.x, e.y, e.z)], C = [];
              for (const _e of M) C.push(a.aR([], _e, x));
              if (x !== v) for (const _e of M) C.push(a.aR([], _e, v));
              e.y === 0 && C.push([0, 1, 0]), e.y === (1 << e.z) - 1 && C.push([0, -1, 0]);
              const k = [1, 1, 1], A = [-1, -1, -1];
              for (const _e of C) for (let xe = 0; xe < 3; xe++) k[xe] = Math.min(k[xe], _e[xe]), A[xe] = Math.max(A[xe], _e[xe]);
              const R = tn(a.$ / 2, a.$ / 2, e.x, e.y, e.z), O = a.aW([], [0, 1, 0], R);
              a.aV(O, O);
              const G = a.aW([], R, O);
              a.aV(G, G);
              const Z = a.aW([], M[2], M[1]);
              a.aV(Z, Z);
              const q = a.aW([], M[0], M[3]);
              a.aV(q, q), C.push(a.aR([], R, x)), e.y >= (1 << e.z) / 2 && C.push(a.aR([], tn(a.$ / 2, 0, e.x, e.y, e.z), x)), e.y < (1 << e.z) / 2 && C.push(a.aR([], tn(a.$ / 2, a.$, e.x, e.y, e.z), x));
              const W = Ro(R, C), J = Ro(G, C), K = [-R[0], -R[1], -R[2], W.max], te = [R[0], R[1], R[2], -W.min], se = [-G[0], -G[1], -G[2], J.max], Y = [G[0], G[1], G[2], -J.min], pe = [...Z, 0], be = [...q, 0], ge = [];
              return e.y === 0 ? ge.push(a.bt(be, pe, K), a.bt(be, pe, te)) : ge.push(a.bt(se, pe, K), a.bt(se, pe, te), a.bt(se, be, K), a.bt(se, be, te)), e.y === (1 << e.z) - 1 ? ge.push(a.bt(be, pe, K), a.bt(be, pe, te)) : ge.push(a.bt(Y, pe, K), a.bt(Y, pe, te), a.bt(Y, be, K), a.bt(Y, be, te)), new Ks(ge, [K, te, se, Y, pe, be], k, A);
            }
          }
        }
        function Ro(h, e) {
          let n = 1 / 0, o = -1 / 0;
          for (const c of e) {
            const d = a.aX(h, c);
            n = Math.min(n, d), o = Math.max(o, d);
          }
          return { min: n, max: o };
        }
        class Do {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, n, o) {
            return this._helper.interpolatePadding(e, n, o);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, n) {
            this._helper.resize(e, n);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, n) {
            this._helper.overrideNearFarZ(e, n);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e) {
          }
          constructor() {
            this._cachedClippingPlane = a.bv(), this._projectionMatrix = a.b9(), this._globeViewProjMatrix32f = a.b8(), this._globeViewProjMatrixNoCorrection = a.b9(), this._globeViewProjMatrixNoCorrectionInverted = a.b9(), this._globeProjMatrixInverted = a.b9(), this._cameraPosition = a.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new yr({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, n) => this.getConstrained(e, n) }), this._coveringTilesDetailsProvider = new Tn();
          }
          clone() {
            const e = new Do();
            return e.apply(this), e;
          }
          apply(e, n) {
            this._globeLatitudeErrorCorrectionRadians = n || 0, this._helper.apply(e);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e = a.bp();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e) {
            const { overscaledTileID: n, applyGlobeMatrix: o } = e, c = this._helper.getMercatorTileCoordinates(n);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: c, clippingPlane: this._cachedClippingPlane, projectionTransition: o ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(e) {
            const n = this.pitchInRadians, o = this.cameraToCenterDistance / e, c = Math.sin(n) * o, d = Math.cos(n) * o + 1, g = 1 / Math.sqrt(c * c + d * d) * 1;
            let v = -c, x = d;
            const M = Math.sqrt(v * v + x * x);
            v /= M, x /= M;
            const C = [0, v, x];
            a.bw(C, C, [0, 0, 0], -this.bearingInRadians), a.bx(C, C, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), a.by(C, C, [0, 0, 0], this.center.lng * Math.PI / 180);
            const k = 1 / a.aZ(C);
            return a.aR(C, C, k), [...C, -g * k];
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(Hi(e));
          }
          transformLightDirection(e) {
            const n = this._helper._center.lng * Math.PI / 180, o = this._helper._center.lat * Math.PI / 180, c = Math.cos(o), d = [Math.sin(n) * c, Math.sin(o), Math.cos(n) * c], g = [d[2], 0, -d[0]], v = [0, 0, 0];
            a.aW(v, g, d), a.aV(g, g), a.aV(v, v);
            const x = [0, 0, 0];
            return a.aV(x, [g[0] * e[0] + v[0] * e[1] + d[0] * e[2], g[1] * e[0] + v[1] * e[1] + d[1] * e[2], g[2] * e[0] + v[2] * e[1] + d[2] * e[2]]), x;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(e, n, o) {
            const c = function(v, x, M) {
              const C = 1 / (1 << M.z);
              return new a.a1(v / a.$ * C + M.x * C, x / a.$ * C + M.y * C);
            }(e, n, o.canonical), d = (g = c.y, [a.bo(c.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - 0.5 * Math.PI]);
            var g;
            return this.getCircleRadiusCorrection() / Math.cos(d[1]);
          }
          projectTileCoordinates(e, n, o, c) {
            const d = o.canonical, g = tn(e, n, d.x, d.y, d.z), v = 1 + (c ? c(e, n) : 0) / a.bu, x = [g[0] * v, g[1] * v, g[2] * v, 1];
            a.aw(x, x, this._globeViewProjMatrixNoCorrection);
            const M = this._cachedClippingPlane, C = M[0] * g[0] + M[1] * g[1] + M[2] * g[2] + M[3] < 0;
            return { point: new a.P(x[0] / x[3], x[1] / x[3]), signedDistanceFromCamera: x[3], isOccluded: C };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = Xs(this.worldSize, this.center.lat), n = a.ba(), o = a.ba();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), a.b4(n, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const c = this.centerOffset;
            n[8] = 2 * -c.x / this._helper._width, n[9] = 2 * c.y / this._helper._height, this._projectionMatrix = a.b5(n), this._globeProjMatrixInverted = a.ba(), a.aq(this._globeProjMatrixInverted, n), a.M(n, n, [0, 0, -this.cameraToCenterDistance]), a.b6(n, n, this.rollInRadians), a.b7(n, n, -this.pitchInRadians), a.b6(n, n, this.bearingInRadians), a.M(n, n, [0, 0, -e]);
            const d = a.bp();
            d[0] = e, d[1] = e, d[2] = e, a.b7(o, n, this.center.lat * Math.PI / 180), a.bz(o, o, -this.center.lng * Math.PI / 180), a.N(o, o, d), this._globeViewProjMatrixNoCorrection = o, a.b7(n, n, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), a.bz(n, n, -this.center.lng * Math.PI / 180), a.N(n, n, d), this._globeViewProjMatrix32f = new Float32Array(n), this._globeViewProjMatrixNoCorrectionInverted = a.ba(), a.aq(this._globeViewProjMatrixNoCorrectionInverted, o);
            const g = a.bp();
            this._cameraPosition = a.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e, a.bw(this._cameraPosition, this._cameraPosition, g, -this.rollInRadians), a.bx(this._cameraPosition, this._cameraPosition, g, this.pitchInRadians), a.bw(this._cameraPosition, this._cameraPosition, g, -this.bearingInRadians), a.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]), a.bx(this._cameraPosition, this._cameraPosition, g, -this.center.lat * Math.PI / 180), a.by(this._cameraPosition, this._cameraPosition, g, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const v = a.b5(this._globeViewProjMatrixNoCorrectionInverted);
            a.N(v, v, [1, 1, -1]), this._cachedFrustum = Di.fromInvProjectionMatrix(v, 1, 0, this._cachedClippingPlane, !0);
          }
          calculateFogMatrix(e) {
            a.w("calculateFogMatrix is not supported on globe projection.");
            const n = a.ba();
            return a.ag(n), n;
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new a.b2(0, e)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            e && a.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, n) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const o = Hi(e);
            a.aR(o, o, 1 + n / a.bu);
            const c = a.bv();
            return a.aw(c, [o[0], o[1], o[2], 1], this._globeViewProjMatrixNoCorrection), c[2] / c[3];
          }
          populateCache(e) {
          }
          getBounds() {
            const e = 0.5 * this.width, n = 0.5 * this.height, o = [new a.P(0, 0), new a.P(e, 0), new a.P(this.width, 0), new a.P(this.width, n), new a.P(this.width, this.height), new a.P(e, this.height), new a.P(0, this.height), new a.P(0, n)], c = [];
            for (const k of o) c.push(this.unprojectScreenPoint(k));
            let d = 0, g = 0, v = 0, x = 0;
            const M = this.center;
            for (const k of c) {
              const A = a.bA(M.lng, k.lng), R = a.bA(M.lat, k.lat);
              A < g && (g = A), A > d && (d = A), R < x && (x = R), R > v && (v = R);
            }
            const C = [M.lng + g, M.lat + x, M.lng + d, M.lat + v];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (C[3] = 90, C[0] = -180, C[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (C[1] = -90, C[0] = -180, C[2] = 180), new ae(C);
          }
          getConstrained(e, n) {
            const o = a.ah(e.lat, -a.ai, a.ai), c = a.ah(+n, this.minZoom + Si(0, o), this.maxZoom);
            return { center: new a.S(e.lng, o), zoom: c };
          }
          calculateCenterFromCameraLngLatAlt(e, n, o, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, n, o, c);
          }
          setLocationAtPoint(e, n) {
            const o = Hi(this.unprojectScreenPoint(n)), c = Hi(e), d = a.bp();
            a.bB(d);
            const g = a.bp();
            a.by(g, o, d, -this.center.lng * Math.PI / 180), a.bx(g, g, d, this.center.lat * Math.PI / 180);
            const v = c[0] * c[0] + c[2] * c[2], x = g[0] * g[0];
            if (v < x) return;
            const M = Math.sqrt(v - x), C = -M, k = a.bC(c[0], c[2], g[0], M), A = a.bC(c[0], c[2], g[0], C), R = a.bp();
            a.by(R, c, d, -k);
            const O = a.bC(R[1], R[2], g[1], g[2]), G = a.bp();
            a.by(G, c, d, -A);
            const Z = a.bC(G[1], G[2], g[1], g[2]), q = 0.5 * Math.PI, W = O >= -q && O <= q, J = Z >= -q && Z <= q;
            let K, te;
            if (W && J) {
              const be = this.center.lng * Math.PI / 180, ge = this.center.lat * Math.PI / 180;
              a.bD(k, be) + a.bD(O, ge) < a.bD(A, be) + a.bD(Z, ge) ? (K = k, te = O) : (K = A, te = Z);
            } else if (W) K = k, te = O;
            else {
              if (!J) return;
              K = A, te = Z;
            }
            const se = K / Math.PI * 180, Y = te / Math.PI * 180, pe = this.center.lat;
            this.setCenter(new a.S(se, a.ah(Y, -90, 90))), this.setZoom(this.zoom + Si(pe, this.center.lat));
          }
          locationToScreenPoint(e, n) {
            const o = Hi(e);
            if (n) {
              const c = n.getElevationForLngLatZoom(e, this._helper._tileZoom);
              a.aR(o, o, 1 + c / a.bu);
            }
            return this._projectSurfacePointToScreen(o);
          }
          _projectSurfacePointToScreen(e) {
            const n = a.bv();
            return a.aw(n, [...e, 1], this._globeViewProjMatrixNoCorrection), n[0] /= n[3], n[1] /= n[3], new a.P((0.5 * n[0] + 0.5) * this.width, (0.5 * -n[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(e, n) {
            if (n) {
              const o = n.pointCoordinate(e);
              if (o) return o;
            }
            return a.a1.fromLngLat(this.unprojectScreenPoint(e));
          }
          screenPointToLocation(e, n) {
            var o;
            return (o = this.screenPointToMercatorCoordinate(e, n)) === null || o === void 0 ? void 0 : o.toLngLat();
          }
          isPointOnMapSurface(e, n) {
            const o = this._cameraPosition, c = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(o, c);
          }
          getRayDirectionFromPixel(e) {
            const n = a.bv();
            n[0] = e.x / this.width * 2 - 1, n[1] = -1 * (e.y / this.height * 2 - 1), n[2] = 1, n[3] = 1, a.aw(n, n, this._globeViewProjMatrixNoCorrectionInverted), n[0] /= n[3], n[1] /= n[3], n[2] /= n[3];
            const o = a.bp();
            o[0] = n[0] - this._cameraPosition[0], o[1] = n[1] - this._cameraPosition[1], o[2] = n[2] - this._cameraPosition[2];
            const c = a.bp();
            return a.aV(c, o), c;
          }
          isSurfacePointVisible(e) {
            const n = this._cachedClippingPlane;
            return n[0] * e[0] + n[1] * e[1] + n[2] * e[2] + n[3] >= 0;
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const n = a.bv();
            return a.aw(n, [...e, 1], this._globeViewProjMatrixNoCorrection), n[0] /= n[3], n[1] /= n[3], n[2] /= n[3], n[0] > -1 && n[0] < 1 && n[1] > -1 && n[1] < 1 && n[2] > -1 && n[2] < 1;
          }
          rayPlanetIntersection(e, n) {
            const o = a.aX(e, n), c = a.bp(), d = a.bp();
            a.aR(d, n, o), a.aU(c, e, d);
            const g = 1 - a.aX(c, c);
            if (g < 0) return null;
            const v = a.aX(e, e) - 1, x = -o + (o < 0 ? 1 : -1) * Math.sqrt(g), M = v / x, C = x;
            return { tMin: Math.min(M, C), tMax: Math.max(M, C) };
          }
          unprojectScreenPoint(e) {
            const n = this._cameraPosition, o = this.getRayDirectionFromPixel(e), c = this.rayPlanetIntersection(n, o);
            if (c) {
              const C = a.bp();
              a.aS(C, n, [o[0] * c.tMin, o[1] * c.tMin, o[2] * c.tMin]);
              const k = a.bp();
              return a.aV(k, C), Ao(k);
            }
            const d = this._cachedClippingPlane, g = d[0] * o[0] + d[1] * o[1] + d[2] * o[2], v = -a.b1(d, n) / g, x = a.bp();
            if (v > 0) a.aS(x, n, [o[0] * v, o[1] * v, o[2] * v]);
            else {
              const C = a.bp();
              a.aS(C, n, [2 * o[0], 2 * o[1], 2 * o[2]]);
              const k = a.b1(this._cachedClippingPlane, C);
              a.aU(x, C, [this._cachedClippingPlane[0] * k, this._cachedClippingPlane[1] * k, this._cachedClippingPlane[2] * k]);
            }
            const M = function(C) {
              const k = a.bp();
              return k[0] = C[0] * -C[3], k[1] = C[1] * -C[3], k[2] = C[2] * -C[3], { center: k, radius: Math.sqrt(1 - C[3] * C[3]) };
            }(d);
            return Ao(function(C, k, A) {
              const R = a.bp();
              a.aU(R, A, C);
              const O = a.bp();
              return a.bq(O, C, R, k / a.a$(R)), O;
            }(M.center, M.radius, x));
          }
          getMatrixForModel(e, n) {
            const o = a.S.convert(e), c = 1 / a.bu, d = a.b9();
            return a.bz(d, d, o.lng / 180 * Math.PI), a.b7(d, d, -o.lat / 180 * Math.PI), a.M(d, d, [0, 0, 1 + n / a.bu]), a.b7(d, d, 0.5 * Math.PI), a.N(d, d, [c, c, c]), d;
          }
          getProjectionDataForCustomLayer(e = !0) {
            const n = this.getProjectionData({ overscaledTileID: new a.Z(0, 0, 0, 0, 0), applyGlobeMatrix: e });
            return n.tileMercatorCoords = [0, 0, 1, 1], n;
          }
          getFastPathSimpleProjectionMatrix(e) {
          }
        }
        class Lo {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, n, o) {
            return this._helper.interpolatePadding(e, n, o);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, n, o = !0) {
            this._helper.resize(e, n, o);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, n) {
            this._helper.overrideNearFarZ(e, n);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e, n) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = n, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new yr({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, n) => this.getConstrained(e, n) }), this._globeness = 1, this._mercatorTransform = new oi(), this._verticalPerspectiveTransform = new Do();
          }
          clone() {
            const e = new Lo();
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e) {
            const n = this._mercatorTransform.getProjectionData(e), o = this._verticalPerspectiveTransform.getProjectionData(e);
            return { mainMatrix: this.isGlobeRendering ? o.mainMatrix : n.mainMatrix, clippingPlane: o.clippingPlane, tileMercatorCoords: o.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: n.fallbackMatrix };
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e);
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e);
          }
          getPixelScale() {
            return a.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return a.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(e, n, o) {
            const c = this._mercatorTransform.getPitchedTextCorrection(e, n, o), d = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, n, o);
            return a.bk(c, d, this._globeness);
          }
          projectTileCoordinates(e, n, o, c) {
            return this.currentTransform.projectTileCoordinates(e, n, o, c);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e);
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, n) {
            return this.currentTransform.lngLatToCameraDepth(e, n);
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(e, n) {
            return this.currentTransform.getConstrained(e, n);
          }
          calculateCenterFromCameraLngLatAlt(e, n, o, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, n, o, c);
          }
          setLocationAtPoint(e, n) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, n), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, n), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(e, n) {
            return this.currentTransform.locationToScreenPoint(e, n);
          }
          screenPointToMercatorCoordinate(e, n) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, n);
          }
          screenPointToLocation(e, n) {
            return this.currentTransform.screenPointToLocation(e, n);
          }
          isPointOnMapSurface(e, n) {
            return this.currentTransform.isPointOnMapSurface(e, n);
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
          }
          getMatrixForModel(e, n) {
            return this.currentTransform.getMatrixForModel(e, n);
          }
          getProjectionDataForCustomLayer(e = !0) {
            const n = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return n;
            const o = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return o.fallbackMatrix = n.mainMatrix, o;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
          }
        }
        class pr {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(e, n) {
            const o = pu(e, n);
            return Math.abs(o.lng - n.center.lng) > 180 && (o.lng = n.center.lng + 179.5 * Math.sign(o.lng - n.center.lng)), { easingCenter: o, easingOffset: new a.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(e, n) {
            const o = e.around, c = n.screenPointToLocation(o);
            e.bearingDelta && n.setBearing(n.bearing + e.bearingDelta), e.pitchDelta && n.setPitch(n.pitch + e.pitchDelta), e.rollDelta && n.setRoll(n.roll + e.rollDelta);
            const d = n.zoom;
            e.zoomDelta && n.setZoom(n.zoom + e.zoomDelta);
            const g = n.zoom - d;
            if (g === 0) return;
            const v = a.bA(n.center.lng, c.lng), x = v / (Math.abs(v / 180) + 1), M = a.bA(n.center.lat, c.lat), C = n.getRayDirectionFromPixel(o), k = n.cameraPosition, A = -1 * a.aX(k, C), R = a.bp();
            a.aS(R, k, [C[0] * A, C[1] * A, C[2] * A]);
            const O = a.aZ(R) - 1, G = Math.exp(0.5 * -Math.max(O - 0.3, 0)), Z = Xs(n.worldSize, n.center.lat) / Math.min(n.width, n.height), q = a.bn(Z, 0.9, 0.5, 1, 0.25), W = (1 - a.af(-g)) * Math.min(G, q), J = n.center.lat, K = n.zoom, te = new a.S(n.center.lng + x * W, a.ah(n.center.lat + M * W, -a.ai, a.ai));
            n.setLocationAtPoint(c, o);
            const se = n.center, Y = a.bn(Math.abs(v), 45, 85, 0, 1), pe = a.bn(Z, 0.75, 0.35, 0, 1), be = Math.pow(Math.max(Y, pe), 0.25), ge = a.bA(se.lng, te.lng), _e = a.bA(se.lat, te.lat);
            n.setCenter(new a.S(se.lng + ge * be, se.lat + _e * be).wrap()), n.setZoom(K + Si(J, n.center.lat));
          }
          handleMapControlsPan(e, n, o) {
            if (!e.panDelta) return;
            const c = n.center.lat, d = n.zoom;
            n.setCenter(pu(e.panDelta, n).wrap()), n.setZoom(d + Si(c, n.center.lat));
          }
          cameraForBoxAndBearing(e, n, o, c, d) {
            const g = Lr(e, n, o, c, d), v = n.left / d.width * 2 - 1, x = (d.width - n.right) / d.width * 2 - 1, M = n.top / d.height * -2 + 1, C = (d.height - n.bottom) / d.height * -2 + 1, k = a.bA(o.getWest(), o.getEast()) < 0, A = k ? o.getEast() : o.getWest(), R = k ? o.getWest() : o.getEast(), O = Math.max(o.getNorth(), o.getSouth()), G = Math.min(o.getNorth(), o.getSouth()), Z = A + 0.5 * a.bA(A, R), q = O + 0.5 * a.bA(O, G), W = d.clone();
            W.setCenter(g.center), W.setBearing(g.bearing), W.setPitch(0), W.setRoll(0), W.setZoom(g.zoom);
            const J = W.modelViewProjectionMatrix, K = [Hi(o.getNorthWest()), Hi(o.getNorthEast()), Hi(o.getSouthWest()), Hi(o.getSouthEast()), Hi(new a.S(R, q)), Hi(new a.S(A, q)), Hi(new a.S(Z, O)), Hi(new a.S(Z, G))], te = Hi(g.center);
            let se = Number.POSITIVE_INFINITY;
            for (const Y of K) v < 0 && (se = pr.getLesserNonNegativeNonNull(se, pr.solveVectorScale(Y, te, J, "x", v))), x > 0 && (se = pr.getLesserNonNegativeNonNull(se, pr.solveVectorScale(Y, te, J, "x", x))), M > 0 && (se = pr.getLesserNonNegativeNonNull(se, pr.solveVectorScale(Y, te, J, "y", M))), C < 0 && (se = pr.getLesserNonNegativeNonNull(se, pr.solveVectorScale(Y, te, J, "y", C)));
            if (Number.isFinite(se) && se !== 0) return g.zoom = W.zoom + a.ak(se), g;
            du();
          }
          handleJumpToCenterZoom(e, n) {
            const o = e.center.lat, c = e.getConstrained(n.center ? a.S.convert(n.center) : e.center, e.zoom).center;
            e.setCenter(c.wrap());
            const d = n.zoom !== void 0 ? +n.zoom : e.zoom + Si(o, c.lat);
            e.zoom !== d && e.setZoom(d);
          }
          handleEaseTo(e, n) {
            const o = e.zoom, c = e.center, d = e.padding, g = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, v = { roll: n.roll === void 0 ? e.roll : n.roll, pitch: n.pitch === void 0 ? e.pitch : n.pitch, bearing: n.bearing === void 0 ? e.bearing : n.bearing }, x = n.zoom !== void 0, M = !e.isPaddingEqual(n.padding);
            let C = !1;
            const k = n.center ? a.S.convert(n.center) : c, A = e.getConstrained(k, o).center;
            wa(e, A);
            const R = e.clone();
            R.setCenter(A), R.setZoom(x ? +n.zoom : o + Si(c.lat, k.lat)), R.setBearing(n.bearing);
            const O = new a.P(a.ah(e.centerPoint.x + n.offsetAsPoint.x, 0, e.width), a.ah(e.centerPoint.y + n.offsetAsPoint.y, 0, e.height));
            R.setLocationAtPoint(A, O);
            const G = (n.offset && n.offsetAsPoint.mag()) > 0 ? R.center : A, Z = x ? +n.zoom : o + Si(c.lat, G.lat), q = o + Si(c.lat, 0), W = Z + Si(G.lat, 0), J = a.bA(c.lng, G.lng), K = a.bA(c.lat, G.lat), te = a.af(W - q);
            return C = Z !== o, { easeFunc: (se) => {
              if (a.be(g, v) || xr({ startEulerAngles: g, endEulerAngles: v, tr: e, k: se, useSlerp: g.roll != v.roll }), M && e.interpolatePadding(d, n.padding, se), n.around) a.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(n.around, n.aroundPoint);
              else {
                const Y = W > q ? Math.min(2, te) : Math.max(0.5, te), pe = Math.pow(Y, 1 - se), be = Nl(c, J, K, se * pe);
                e.setCenter(be.wrap());
              }
              if (C) {
                const Y = a.C.number(q, W, se) + Si(0, e.center.lat);
                e.setZoom(Y);
              }
            }, isZooming: C, elevationCenter: G };
          }
          handleFlyTo(e, n) {
            const o = n.zoom !== void 0, c = e.center, d = e.zoom, g = e.padding, v = !e.isPaddingEqual(n.padding), x = e.getConstrained(a.S.convert(n.center || n.locationAtOffset), d).center, M = o ? +n.zoom : e.zoom + Si(e.center.lat, x.lat), C = e.clone();
            C.setCenter(x), C.setZoom(M), C.setBearing(n.bearing);
            const k = new a.P(a.ah(e.centerPoint.x + n.offsetAsPoint.x, 0, e.width), a.ah(e.centerPoint.y + n.offsetAsPoint.y, 0, e.height));
            C.setLocationAtPoint(x, k);
            const A = C.center;
            wa(e, A);
            const R = function(K, te, se) {
              const Y = Hi(te), pe = Hi(se), be = a.aX(Y, pe), ge = Math.acos(be), _e = Ca(K);
              return ge / (2 * Math.PI) * _e;
            }(e, c, A), O = d + Si(c.lat, 0), G = M + Si(A.lat, 0), Z = a.af(G - O);
            let q;
            if (typeof n.minZoom == "number") {
              const K = +n.minZoom + Si(A.lat, 0), te = Math.min(K, O, G) + Si(0, A.lat), se = e.getConstrained(A, te).zoom + Si(A.lat, 0);
              q = a.af(se - O);
            }
            const W = a.bA(c.lng, A.lng), J = a.bA(c.lat, A.lat);
            return { easeFunc: (K, te, se, Y) => {
              const pe = Nl(c, W, J, se);
              v && e.interpolatePadding(g, n.padding, K);
              const be = K === 1 ? A : pe;
              e.setCenter(be.wrap());
              const ge = O + a.ak(te);
              e.setZoom(K === 1 ? M : ge + Si(0, be.lat));
            }, scaleOfZoom: Z, targetCenter: A, scaleOfMinZoom: q, pixelPathLength: R };
          }
          static solveVectorScale(e, n, o, c, d) {
            const g = c === "x" ? [o[0], o[4], o[8], o[12]] : [o[1], o[5], o[9], o[13]], v = [o[3], o[7], o[11], o[15]], x = e[0] * g[0] + e[1] * g[1] + e[2] * g[2], M = e[0] * v[0] + e[1] * v[1] + e[2] * v[2], C = n[0] * g[0] + n[1] * g[1] + n[2] * g[2], k = n[0] * v[0] + n[1] * v[1] + n[2] * v[2];
            return C + d * M === x + d * k || v[3] * (x - C) + g[3] * (k - M) + x * k == C * M ? null : (C + g[3] - d * k - d * v[3]) / (C - x - d * k + d * M);
          }
          static getLesserNonNegativeNonNull(e, n) {
            return n !== null && n >= 0 && n < e ? n : e;
          }
        }
        class fu {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new dr(), this._verticalPerspectiveCameraHelper = new pr();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(e, n) {
            return this.currentHelper.handlePanInertia(e, n);
          }
          handleMapControlsRollPitchBearingZoom(e, n) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, n);
          }
          handleMapControlsPan(e, n, o) {
            this.currentHelper.handleMapControlsPan(e, n, o);
          }
          cameraForBoxAndBearing(e, n, o, c, d) {
            return this.currentHelper.cameraForBoxAndBearing(e, n, o, c, d);
          }
          handleJumpToCenterZoom(e, n) {
            this.currentHelper.handleJumpToCenterZoom(e, n);
          }
          handleEaseTo(e, n) {
            return this.currentHelper.handleEaseTo(e, n);
          }
          handleFlyTo(e, n) {
            return this.currentHelper.handleFlyTo(e, n);
          }
        }
        const Ia = (h, e) => a.y(h, e && e.filter((n) => n.identifier !== "source.canvas")), ad = a.bE();
        class $l extends a.E {
          constructor(e, n = {}) {
            var o, c;
            super(), this._rtlPluginLoaded = () => {
              for (const g in this.sourceCaches) {
                const v = this.sourceCaches[g].getSource().type;
                v !== "vector" && v !== "geojson" || this.sourceCaches[g].reload();
              }
            }, this.map = e, this.dispatcher = new zi(Cn(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", (g, v) => this.getGlyphs(g, v)), this.dispatcher.registerMessageHandler("GI", (g, v) => this.getImages(g, v)), this.imageManager = new _t(), this.imageManager.setEventedParent(this);
            const d = ((o = e._container) === null || o === void 0 ? void 0 : o.lang) || typeof document < "u" && ((c = document.documentElement) === null || c === void 0 ? void 0 : c.lang) || void 0;
            this.glyphManager = new ir(e._requestManager, n.localIdeographFontFamily, d), this.lineAtlas = new Zt(256, 512), this.crossTileSymbolIndex = new Hs(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new a.bF(), this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", a.bG()), Wt().on(ct, this._rtlPluginLoaded), this.on("data", (g) => {
              if (g.dataType !== "source" || g.sourceDataType !== "metadata") return;
              const v = this.sourceCaches[g.sourceId];
              if (!v) return;
              const x = v.getSource();
              if (x && x.vectorLayerIds) for (const M in this._layers) {
                const C = this._layers[M];
                C.source === x.id && this._validateLayer(C);
              }
            });
          }
          setGlobalStateProperty(e, n) {
            var o, c, d;
            this._checkLoaded();
            const g = n === null ? (d = (c = (o = this.stylesheet.state) === null || o === void 0 ? void 0 : o[e]) === null || c === void 0 ? void 0 : c.default) !== null && d !== void 0 ? d : null : n;
            if (a.bH(g, this._globalState[e])) return this;
            this._globalState[e] = g, this._applyGlobalStateChanges([e]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(e) {
            this._checkLoaded();
            const n = [];
            for (const o in e) !a.bH(this._globalState[o], e[o].default) && (n.push(o), this._globalState[o] = e[o].default);
            this._applyGlobalStateChanges(n);
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const n = /* @__PURE__ */ new Set();
            for (const o in this._layers) {
              const c = this._layers[o], d = c.getLayoutAffectingGlobalStateRefs(), g = c.getPaintAffectingGlobalStateRefs();
              for (const v of e) if (d.has(v) && n.add(c.source), g.has(v)) for (const { name: x, value: M } of g.get(v)) this._updatePaintProperty(c, x, M);
            }
            for (const o in this.sourceCaches) n.has(o) && (this._reloadSource(o), this._changed = !0);
          }
          loadURL(e, n = {}, o) {
            this.fire(new a.l("dataloading", { dataType: "style" })), n.validate = typeof n.validate != "boolean" || n.validate;
            const c = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController();
            const d = this._loadStyleRequest;
            a.j(c, this._loadStyleRequest).then((g) => {
              this._loadStyleRequest = null, this._load(g.data, n, o);
            }).catch((g) => {
              this._loadStyleRequest = null, g && !d.signal.aborted && this.fire(new a.k(g));
            });
          }
          loadJSON(e, n = {}, o) {
            this.fire(new a.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), we.frameAsync(this._frameRequest).then(() => {
              this._frameRequest = null, n.validate = n.validate !== !1, this._load(e, n, o);
            }).catch(() => {
            });
          }
          loadEmpty() {
            this.fire(new a.l("dataloading", { dataType: "style" })), this._load(ad, { validate: !1 });
          }
          _load(e, n, o) {
            var c, d;
            let g = n.transformStyle ? n.transformStyle(o, e) : e;
            if (!n.validate || !Ia(this, a.z(g))) {
              g = Object.assign({}, g), this._loaded = !0, this.stylesheet = g;
              for (const v in g.sources) this.addSource(v, g.sources[v], { validate: !1 });
              g.sprite ? this._loadSprite(g.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(g.glyphs), this._createLayers(), this.light = new ti(this.stylesheet.light), this._setProjectionInternal(((c = this.stylesheet.projection) === null || c === void 0 ? void 0 : c.type) || "mercator"), this.sky = new Jt(this.stylesheet.sky), this.map.setTerrain((d = this.stylesheet.terrain) !== null && d !== void 0 ? d : null), this.fire(new a.l("data", { dataType: "style" })), this.fire(new a.l("style.load"));
            }
          }
          _createLayers() {
            var e;
            const n = a.bI(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", n), this._order = n.map((o) => o.id), this._layers = {}, this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this._serializedLayers = null;
            for (const o of n) {
              const c = a.bJ(o);
              c.setEventedParent(this, { layer: { id: o.id } }), c.setGlobalState(this._globalState), this._layers[o.id] = c;
            }
          }
          _loadSprite(e, n = !1, o = void 0) {
            let c;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(d, g, v, x) {
              return a._(this, void 0, void 0, function* () {
                const M = ki(d), C = v > 1 ? "@2x" : "", k = {}, A = {};
                for (const { id: R, url: O } of M) {
                  const G = g.transformRequest(pt(O, C, ".json"), "SpriteJSON");
                  k[R] = a.j(G, x);
                  const Z = g.transformRequest(pt(O, C, ".png"), "SpriteImage");
                  A[R] = Qe.getImage(Z, x);
                }
                return yield Promise.all([...Object.values(k), ...Object.values(A)]), function(R, O) {
                  return a._(this, void 0, void 0, function* () {
                    const G = {};
                    for (const Z in R) {
                      G[Z] = {};
                      const q = we.getImageCanvasContext((yield O[Z]).data), W = (yield R[Z]).data;
                      for (const J in W) {
                        const { width: K, height: te, x: se, y: Y, sdf: pe, pixelRatio: be, stretchX: ge, stretchY: _e, content: xe, textFitWidth: Le, textFitHeight: Oe } = W[J];
                        G[Z][J] = { data: null, pixelRatio: be, sdf: pe, stretchX: ge, stretchY: _e, content: xe, textFitWidth: Le, textFitHeight: Oe, spriteData: { width: K, height: te, x: se, y: Y, context: q } };
                      }
                    }
                    return G;
                  });
                }(k, A);
              });
            }(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((d) => {
              if (this._spriteRequest = null, d) for (const g in d) {
                this._spritesImagesIds[g] = [];
                const v = this._spritesImagesIds[g] ? this._spritesImagesIds[g].filter((x) => !(x in d)) : [];
                for (const x of v) this.imageManager.removeImage(x), this._changedImages[x] = !0;
                for (const x in d[g]) {
                  const M = g === "default" ? x : `${g}:${x}`;
                  this._spritesImagesIds[g].push(M), M in this.imageManager.images ? this.imageManager.updateImage(M, d[g][x], !1) : this.imageManager.addImage(M, d[g][x]), n && (this._changedImages[M] = !0);
                }
              }
            }).catch((d) => {
              this._spriteRequest = null, c = d, this.fire(new a.k(c));
            }).finally(() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), n && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.l("data", { dataType: "style" })), o && o(c);
            });
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.l("data", { dataType: "style" }));
          }
          _validateLayer(e) {
            const n = this.sourceCaches[e.source];
            if (!n) return;
            const o = e.sourceLayer;
            if (!o) return;
            const c = n.getSource();
            (c.type === "geojson" || c.vectorLayerIds && c.vectorLayerIds.indexOf(o) === -1) && this.fire(new a.k(new Error(`Source layer "${o}" does not exist on source "${c.id}" as specified by style layer "${e.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e, n = !1) {
            const o = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(n ? a.bK(o) : o);
            const c = [];
            for (const d of e) if (o[d]) {
              const g = n ? a.bK(o[d]) : o[d];
              c.push(g);
            }
            return c;
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const n = Object.keys(this._layers);
            for (const o of n) {
              const c = this._layers[o];
              c.type !== "custom" && (e[o] = c.serialize());
            }
            return e;
          }
          hasTransitions() {
            var e, n, o;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((n = this.sky) === null || n === void 0) && n.hasTransition() || !((o = this.projection) === null || o === void 0) && o.hasTransition()) return !0;
            for (const c in this.sourceCaches) if (this.sourceCaches[c].hasTransition()) return !0;
            for (const c in this._layers) if (this._layers[c].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e) {
            if (!this._loaded) return;
            const n = this._changed;
            if (n) {
              const c = Object.keys(this._updatedLayers), d = Object.keys(this._removedLayers);
              (c.length || d.length) && this._updateWorkerLayers(c, d);
              for (const g in this._updatedSources) {
                const v = this._updatedSources[g];
                if (v === "reload") this._reloadSource(g);
                else {
                  if (v !== "clear") throw new Error(`Invalid action ${v}`);
                  this._clearSource(g);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const g in this._updatedPaintProps) this._layers[g].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
            }
            const o = {};
            for (const c in this.sourceCaches) {
              const d = this.sourceCaches[c];
              o[c] = d.used, d.used = !1;
            }
            for (const c of this._order) {
              const d = this._layers[c];
              d.recalculate(e, this._availableImages), !d.isHidden(e.zoom) && d.source && (this.sourceCaches[d.source].used = !0);
            }
            for (const c in o) {
              const d = this.sourceCaches[c];
              !!o[c] != !!d.used && d.fire(new a.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: c }));
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, n && this.fire(new a.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const n in this.sourceCaches) this.sourceCaches[n].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(e, n) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, !1), removedIds: n });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
          }
          setState(e, n = {}) {
            var o;
            this._checkLoaded();
            const c = this.serialize();
            if (e = n.transformStyle ? n.transformStyle(c, e) : e, ((o = n.validate) === null || o === void 0 || o) && Ia(this, a.z(e))) return !1;
            (e = a.bK(e)).layers = a.bI(e.layers);
            const d = a.bL(c, e), g = this._getOperationsToPerform(d);
            if (g.unimplemented.length > 0) throw new Error(`Unimplemented: ${g.unimplemented.join(", ")}.`);
            if (g.operations.length === 0) return !1;
            for (const v of g.operations) v();
            return this.stylesheet = e, this._serializedLayers = null, !0;
          }
          _getOperationsToPerform(e) {
            const n = [], o = [];
            for (const c of e) switch (c.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                n.push(() => this.addLayer.apply(this, c.args));
                break;
              case "removeLayer":
                n.push(() => this.removeLayer.apply(this, c.args));
                break;
              case "setPaintProperty":
                n.push(() => this.setPaintProperty.apply(this, c.args));
                break;
              case "setLayoutProperty":
                n.push(() => this.setLayoutProperty.apply(this, c.args));
                break;
              case "setFilter":
                n.push(() => this.setFilter.apply(this, c.args));
                break;
              case "addSource":
                n.push(() => this.addSource.apply(this, c.args));
                break;
              case "removeSource":
                n.push(() => this.removeSource.apply(this, c.args));
                break;
              case "setLayerZoomRange":
                n.push(() => this.setLayerZoomRange.apply(this, c.args));
                break;
              case "setLight":
                n.push(() => this.setLight.apply(this, c.args));
                break;
              case "setGeoJSONSourceData":
                n.push(() => this.setGeoJSONSourceData.apply(this, c.args));
                break;
              case "setGlyphs":
                n.push(() => this.setGlyphs.apply(this, c.args));
                break;
              case "setSprite":
                n.push(() => this.setSprite.apply(this, c.args));
                break;
              case "setTerrain":
                n.push(() => this.map.setTerrain.apply(this, c.args));
                break;
              case "setSky":
                n.push(() => this.setSky.apply(this, c.args));
                break;
              case "setProjection":
                this.setProjection.apply(this, c.args);
                break;
              case "setGlobalState":
                n.push(() => this.setGlobalState.apply(this, c.args));
                break;
              case "setTransition":
                n.push(() => {
                });
                break;
              default:
                o.push(c.command);
            }
            return { operations: n, unimplemented: o };
          }
          addImage(e, n) {
            if (this.getImage(e)) return this.fire(new a.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, n), this._afterImageUpdated(e);
          }
          updateImage(e, n) {
            this.imageManager.updateImage(e, n);
          }
          getImage(e) {
            return this.imageManager.getImage(e);
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new a.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e);
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e, n, o = {}) {
            if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!n.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(n).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(n.type) >= 0 && this._validate(a.z.source, `sources.${e}`, n, null, o)) return;
            this.map && this.map._collectResourceTiming && (n.collectResourceTiming = !0);
            const c = this.sourceCaches[e] = new Dt(e, n, this.dispatcher);
            c.style = this, c.setEventedParent(this, () => ({ isSourceLoaded: c.loaded(), source: c.serialize(), sourceId: e })), c.onAdd(this.map), this._changed = !0;
          }
          removeSource(e) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
            for (const o in this._layers) if (this._layers[o].source === e) return this.fire(new a.k(new Error(`Source "${e}" cannot be removed while layer "${o}" is using it.`)));
            const n = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], n.fire(new a.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), n.setEventedParent(null), n.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(e, n) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const o = this.sourceCaches[e].getSource();
            if (o.type !== "geojson") throw new Error(`geojsonSource.type is ${o.type}, which is !== 'geojson`);
            o.setData(n), this._changed = !0;
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource();
          }
          addLayer(e, n, o = {}) {
            this._checkLoaded();
            const c = e.id;
            if (this.getLayer(c)) return void this.fire(new a.k(new Error(`Layer "${c}" already exists on this map.`)));
            let d;
            if (e.type === "custom") {
              if (Ia(this, a.bM(e))) return;
              d = a.bJ(e);
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(c, e.source), e = a.bK(e), e = a.e(e, { source: c })), this._validate(a.z.layer, `layers.${c}`, e, { arrayIndex: -1 }, o)) return;
              d = a.bJ(e), this._validateLayer(d), d.setEventedParent(this, { layer: { id: c } });
            }
            const g = n ? this._order.indexOf(n) : this._order.length;
            if (n && g === -1) this.fire(new a.k(new Error(`Cannot add layer "${c}" before non-existing layer "${n}".`)));
            else {
              if (this._order.splice(g, 0, c), this._layerOrderChanged = !0, this._layers[c] = d, this._removedLayers[c] && d.source && d.type !== "custom") {
                const v = this._removedLayers[c];
                delete this._removedLayers[c], v.type !== d.type ? this._updatedSources[d.source] = "clear" : (this._updatedSources[d.source] = "reload", this.sourceCaches[d.source].pause());
              }
              this._updateLayer(d), d.onAdd && d.onAdd(this.map);
            }
          }
          moveLayer(e, n) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new a.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === n) return;
            const o = this._order.indexOf(e);
            this._order.splice(o, 1);
            const c = n ? this._order.indexOf(n) : this._order.length;
            n && c === -1 ? this.fire(new a.k(new Error(`Cannot move layer "${e}" before non-existing layer "${n}".`))) : (this._order.splice(c, 0, e), this._layerOrderChanged = !0);
          }
          removeLayer(e) {
            this._checkLoaded();
            const n = this._layers[e];
            if (!n) return void this.fire(new a.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            n.setEventedParent(null);
            const o = this._order.indexOf(e);
            this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = n, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], n.onRemove && n.onRemove(this.map);
          }
          getLayer(e) {
            return this._layers[e];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e) {
            return e in this._layers;
          }
          setLayerZoomRange(e, n, o) {
            this._checkLoaded();
            const c = this.getLayer(e);
            c ? c.minzoom === n && c.maxzoom === o || (n != null && (c.minzoom = n), o != null && (c.maxzoom = o), this._updateLayer(c)) : this.fire(new a.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
          }
          setFilter(e, n, o = {}) {
            this._checkLoaded();
            const c = this.getLayer(e);
            if (c) {
              if (!a.bH(c.filter, n)) return n == null ? (c.setFilter(void 0), void this._updateLayer(c)) : void (this._validate(a.z.filter, `layers.${c.id}.filter`, n, null, o) || (c.setFilter(a.bK(n)), this._updateLayer(c)));
            } else this.fire(new a.k(new Error(`Cannot filter non-existing layer "${e}".`)));
          }
          getFilter(e) {
            return a.bK(this.getLayer(e).filter);
          }
          setLayoutProperty(e, n, o, c = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? a.bH(d.getLayoutProperty(n), o) || (d.setLayoutProperty(n, o, c), this._updateLayer(d)) : this.fire(new a.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getLayoutProperty(e, n) {
            const o = this.getLayer(e);
            if (o) return o.getLayoutProperty(n);
            this.fire(new a.k(new Error(`Cannot get style of non-existing layer "${e}".`)));
          }
          setPaintProperty(e, n, o, c = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? a.bH(d.getPaintProperty(n), o) || this._updatePaintProperty(d, n, o, c) : this.fire(new a.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          _updatePaintProperty(e, n, o, c = {}) {
            e.setPaintProperty(n, o, c) && this._updateLayer(e), this._changed = !0, this._updatedPaintProps[e.id] = !0, this._serializedLayers = null;
          }
          getPaintProperty(e, n) {
            return this.getLayer(e).getPaintProperty(n);
          }
          setFeatureState(e, n) {
            this._checkLoaded();
            const o = e.source, c = e.sourceLayer, d = this.sourceCaches[o];
            if (d === void 0) return void this.fire(new a.k(new Error(`The source '${o}' does not exist in the map's style.`)));
            const g = d.getSource().type;
            g === "geojson" && c ? this.fire(new a.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : g !== "vector" || c ? (e.id === void 0 && this.fire(new a.k(new Error("The feature id parameter must be provided."))), d.setFeatureState(c, e.id, n)) : this.fire(new a.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e, n) {
            this._checkLoaded();
            const o = e.source, c = this.sourceCaches[o];
            if (c === void 0) return void this.fire(new a.k(new Error(`The source '${o}' does not exist in the map's style.`)));
            const d = c.getSource().type, g = d === "vector" ? e.sourceLayer : void 0;
            d !== "vector" || g ? n && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new a.k(new Error("A feature id is required to remove its specific state property."))) : c.removeFeatureState(g, e.id, n) : this.fire(new a.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e) {
            this._checkLoaded();
            const n = e.source, o = e.sourceLayer, c = this.sourceCaches[n];
            if (c !== void 0) return c.getSource().type !== "vector" || o ? (e.id === void 0 && this.fire(new a.k(new Error("The feature id parameter must be provided."))), c.getFeatureState(o, e.id)) : void this.fire(new a.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new a.k(new Error(`The source '${n}' does not exist in the map's style.`)));
          }
          getTransition() {
            return a.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e = a.bN(this.sourceCaches, (d) => d.serialize()), n = this._serializeByIds(this._order, !0), o = this.map.getTerrain() || void 0, c = this.stylesheet;
            return a.bO({ version: c.version, name: c.name, metadata: c.metadata, light: c.light, sky: c.sky, center: c.center, zoom: c.zoom, bearing: c.bearing, pitch: c.pitch, sprite: c.sprite, glyphs: c.glyphs, transition: c.transition, projection: c.projection, sources: e, layers: n, terrain: o }, (d) => d !== void 0);
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(e) {
            const n = (g) => this._layers[g].type === "fill-extrusion", o = {}, c = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const v = this._order[g];
              if (n(v)) {
                o[v] = g;
                for (const x of e) {
                  const M = x[v];
                  if (M) for (const C of M) c.push(C);
                }
              }
            }
            c.sort((g, v) => v.intersectionZ - g.intersectionZ);
            const d = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const v = this._order[g];
              if (n(v)) for (let x = c.length - 1; x >= 0; x--) {
                const M = c[x].feature;
                if (o[M.layer.id] < g) break;
                d.push(M), c.pop();
              }
              else for (const x of e) {
                const M = x[v];
                if (M) for (const C of M) d.push(C.feature);
              }
            }
            return d;
          }
          queryRenderedFeatures(e, n, o) {
            n && n.filter && this._validate(a.z.filter, "queryRenderedFeatures.filter", n.filter, null, n);
            const c = {};
            if (n && n.layers) {
              if (!(Array.isArray(n.layers) || n.layers instanceof Set)) return this.fire(new a.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const M of n.layers) {
                const C = this._layers[M];
                if (!C) return this.fire(new a.k(new Error(`The layer '${M}' does not exist in the map's style and cannot be queried for features.`))), [];
                c[C.source] = !0;
              }
            }
            const d = [];
            n.availableImages = this._availableImages;
            const g = this._serializedAllLayers(), v = n.layers instanceof Set ? n.layers : Array.isArray(n.layers) ? new Set(n.layers) : null, x = Object.assign(Object.assign({}, n), { layers: v });
            for (const M in this.sourceCaches) n.layers && !c[M] || d.push(Mr(this.sourceCaches[M], this._layers, g, e, x, o, this.map.terrain ? (C, k, A) => this.map.terrain.getElevation(C, k, A) : void 0));
            return this.placement && d.push(function(M, C, k, A, R, O, G) {
              const Z = {}, q = O.queryRenderedSymbols(A), W = [];
              for (const J of Object.keys(q).map(Number)) W.push(G[J]);
              W.sort(Hr);
              for (const J of W) {
                const K = J.featureIndex.lookupSymbolFeatures(q[J.bucketInstanceId], C, J.bucketIndex, J.sourceLayerIndex, R.filter, R.layers, R.availableImages, M);
                for (const te in K) {
                  const se = Z[te] = Z[te] || [], Y = K[te];
                  Y.sort((pe, be) => {
                    const ge = J.featureSortOrder;
                    if (ge) {
                      const _e = ge.indexOf(pe.featureIndex);
                      return ge.indexOf(be.featureIndex) - _e;
                    }
                    return be.featureIndex - pe.featureIndex;
                  });
                  for (const pe of Y) se.push(pe);
                }
              }
              return function(J, K, te) {
                for (const se in J) for (const Y of J[se]) hs(Y, te[K[se].source]);
                return J;
              }(Z, M, k);
            }(this._layers, g, this.sourceCaches, e, x, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(d);
          }
          querySourceFeatures(e, n) {
            n && n.filter && this._validate(a.z.filter, "querySourceFeatures.filter", n.filter, null, n);
            const o = this.sourceCaches[e];
            return o ? function(c, d) {
              const g = c.getRenderableIds().map((M) => c.getTileByID(M)), v = [], x = {};
              for (let M = 0; M < g.length; M++) {
                const C = g[M], k = C.tileID.canonical.key;
                x[k] || (x[k] = !0, C.querySourceFeatures(v, d));
              }
              return v;
            }(o, n) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e, n = {}) {
            this._checkLoaded();
            const o = this.light.getLight();
            let c = !1;
            for (const g in e) if (!a.bH(e[g], o[g])) {
              c = !0;
              break;
            }
            if (!c) return;
            const d = { now: we.now(), transition: a.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e, n), this.light.updateTransitions(d);
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection;
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type);
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
          }
          setSky(e, n = {}) {
            this._checkLoaded();
            const o = this.getSky();
            let c = !1;
            if (!e && !o) return;
            if (e && !o) c = !0;
            else if (!e && o) c = !0;
            else for (const g in e) if (!a.bH(e[g], o[g])) {
              c = !0;
              break;
            }
            if (!c) return;
            const d = { now: we.now(), transition: a.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = e, this.sky.setSky(e, n), this.sky.updateTransitions(d);
          }
          _setProjectionInternal(e) {
            const n = function(o) {
              if (Array.isArray(o)) {
                const c = new Ma({ type: o });
                return { projection: c, transform: new Lo(), cameraHelper: new fu(c) };
              }
              switch (o) {
                case "mercator":
                  return { projection: new Bt(), transform: new oi(), cameraHelper: new dr() };
                case "globe": {
                  const c = new Ma({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: c, transform: new Lo(), cameraHelper: new fu(c) };
                }
                case "vertical-perspective":
                  return { projection: new Eo(), transform: new Do(), cameraHelper: new pr() };
                default:
                  return a.w(`Unknown projection name: ${o}. Falling back to mercator projection.`), { projection: new Bt(), transform: new oi(), cameraHelper: new dr() };
              }
            }(e);
            this.projection = n.projection, this.map.migrateProjection(n.transform, n.cameraHelper);
            for (const o in this.sourceCaches) this.sourceCaches[o].reload();
          }
          _validate(e, n, o, c, d = {}) {
            return (!d || d.validate !== !1) && Ia(this, e.call(a.z, a.e({ key: n, style: this.serialize(), value: o, styleSpec: a.v }, c)));
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Wt().off(ct, this._rtlPluginLoaded);
            for (const n in this._layers) this._layers[n].setEventedParent(null);
            for (const n in this.sourceCaches) {
              const o = this.sourceCaches[n];
              o.setEventedParent(null), o.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles();
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
          }
          _updateSources(e) {
            for (const n in this.sourceCaches) this.sourceCaches[n].update(e, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e);
          }
          _updatePlacement(e, n, o, c, d = !1) {
            let g = !1, v = !1;
            const x = {};
            for (const M of this._order) {
              const C = this._layers[M];
              if (C.type !== "symbol") continue;
              if (!x[C.source]) {
                const A = this.sourceCaches[C.source];
                x[C.source] = A.getRenderableIds(!0).map((R) => A.getTileByID(R)).sort((R, O) => O.tileID.overscaledZ - R.tileID.overscaledZ || (R.tileID.isLessThan(O.tileID) ? -1 : 1));
              }
              const k = this.crossTileSymbolIndex.addLayer(C, x[C.source], e.center.lng);
              g = g || k;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((d = d || this._layerOrderChanged || o === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(we.now(), e.zoom)) && (this.pauseablePlacement = new Bl(e, this.map.terrain, this._order, d, n, o, c, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, x), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(we.now()), v = !0), g && this.pauseablePlacement.placement.setStale()), v || g) for (const M of this._order) {
              const C = this._layers[M];
              C.type === "symbol" && this.placement.updateLayerOpacities(C, x[C.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(we.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
          }
          getImages(e, n) {
            return a._(this, void 0, void 0, function* () {
              const o = yield this.imageManager.getImages(n.icons);
              this._updateTilesForChangedImages();
              const c = this.sourceCaches[n.source];
              return c && c.setDependencies(n.tileID.key, n.type, n.icons), o;
            });
          }
          getGlyphs(e, n) {
            return a._(this, void 0, void 0, function* () {
              const o = yield this.glyphManager.getGlyphs(n.stacks), c = this.sourceCaches[n.source];
              return c && c.setDependencies(n.tileID.key, n.type, [""]), o;
            });
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e, n = {}) {
            this._checkLoaded(), e && this._validate(a.z.glyphs, "glyphs", e, null, n) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
          }
          addSprite(e, n, o = {}, c) {
            this._checkLoaded();
            const d = [{ id: e, url: n }], g = [...ki(this.stylesheet.sprite), ...d];
            this._validate(a.z.sprite, "sprite", g, null, o) || (this.stylesheet.sprite = g, this._loadSprite(d, !0, c));
          }
          removeSprite(e) {
            this._checkLoaded();
            const n = ki(this.stylesheet.sprite);
            if (n.find((o) => o.id === e)) {
              if (this._spritesImagesIds[e]) for (const o of this._spritesImagesIds[e]) this.imageManager.removeImage(o), this._changedImages[o] = !0;
              n.splice(n.findIndex((o) => o.id === e), 1), this.stylesheet.sprite = n.length > 0 ? n : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.l("data", { dataType: "style" }));
            } else this.fire(new a.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
          }
          getSprite() {
            return ki(this.stylesheet.sprite);
          }
          setSprite(e, n = {}, o) {
            this._checkLoaded(), e && this._validate(a.z.sprite, "sprite", e, null, n) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, o) : (this._unloadSprite(), o && o(null)));
          }
        }
        var ld = a.aJ([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class cd {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e, n, o, c, d, g, v, x, M) {
            this.context = e;
            let C = this.boundPaintVertexBuffers.length !== c.length;
            for (let k = 0; !C && k < c.length; k++) this.boundPaintVertexBuffers[k] !== c[k] && (C = !0);
            !this.vao || this.boundProgram !== n || this.boundLayoutVertexBuffer !== o || C || this.boundIndexBuffer !== d || this.boundVertexOffset !== g || this.boundDynamicVertexBuffer !== v || this.boundDynamicVertexBuffer2 !== x || this.boundDynamicVertexBuffer3 !== M ? this.freshBind(n, o, c, d, g, v, x, M) : (e.bindVertexArray.set(this.vao), v && v.bind(), d && d.dynamicDraw && d.bind(), x && x.bind(), M && M.bind());
          }
          freshBind(e, n, o, c, d, g, v, x) {
            const M = e.numAttributes, C = this.context, k = C.gl;
            this.vao && this.destroy(), this.vao = C.createVertexArray(), C.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = n, this.boundPaintVertexBuffers = o, this.boundIndexBuffer = c, this.boundVertexOffset = d, this.boundDynamicVertexBuffer = g, this.boundDynamicVertexBuffer2 = v, this.boundDynamicVertexBuffer3 = x, n.enableAttributes(k, e);
            for (const A of o) A.enableAttributes(k, e);
            g && g.enableAttributes(k, e), v && v.enableAttributes(k, e), x && x.enableAttributes(k, e), n.bind(), n.setVertexAttribPointers(k, e, d);
            for (const A of o) A.bind(), A.setVertexAttribPointers(k, e, d);
            g && (g.bind(), g.setVertexAttribPointers(k, e, d)), c && c.bind(), v && (v.bind(), v.setVertexAttribPointers(k, e, d)), x && (x.bind(), x.setVertexAttribPointers(k, e, d)), C.currentNumAttributes = M;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const Ea = (h, e, n, o, c) => ({ u_texture: 0, u_ele_delta: h, u_fog_matrix: e, u_fog_color: n ? n.properties.get("fog-color") : a.bf.white, u_fog_ground_blend: n ? n.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: c ? 0 : n ? n.calculateFogBlendOpacity(o) : 0, u_horizon_color: n ? n.properties.get("horizon-color") : a.bf.white, u_horizon_fog_blend: n ? n.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: c ? 1 : 0 }), Ul = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function ys(h) {
          const e = [];
          for (let n = 0; n < h.length; n++) {
            if (h[n] === null) continue;
            const o = h[n].split(" ");
            e.push(o.pop());
          }
          return e;
        }
        class Zl {
          constructor(e, n, o, c, d, g, v, x, M = []) {
            const C = e.gl;
            this.program = C.createProgram();
            const k = ys(n.staticAttributes), A = o ? o.getBinderAttributes() : [], R = k.concat(A), O = en.prelude.staticUniforms ? ys(en.prelude.staticUniforms) : [], G = v.staticUniforms ? ys(v.staticUniforms) : [], Z = n.staticUniforms ? ys(n.staticUniforms) : [], q = o ? o.getBinderUniforms() : [], W = O.concat(G).concat(Z).concat(q), J = [];
            for (const ge of W) J.indexOf(ge) < 0 && J.push(ge);
            const K = o ? o.defines() : [];
            bn(C) && K.unshift("#version 300 es"), d && K.push("#define OVERDRAW_INSPECTOR;"), g && K.push("#define TERRAIN3D;"), x && K.push(x), M && K.push(...M);
            let te = K.concat(en.prelude.fragmentSource, v.fragmentSource, n.fragmentSource).join(`
`), se = K.concat(en.prelude.vertexSource, v.vertexSource, n.vertexSource).join(`
`);
            bn(C) || (te = function(ge) {
              return ge.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            }(te), se = function(ge) {
              return ge.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            }(se));
            const Y = C.createShader(C.FRAGMENT_SHADER);
            if (C.isContextLost()) return void (this.failedToCreate = !0);
            if (C.shaderSource(Y, te), C.compileShader(Y), !C.getShaderParameter(Y, C.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${C.getShaderInfoLog(Y)}`);
            C.attachShader(this.program, Y);
            const pe = C.createShader(C.VERTEX_SHADER);
            if (C.isContextLost()) return void (this.failedToCreate = !0);
            if (C.shaderSource(pe, se), C.compileShader(pe), !C.getShaderParameter(pe, C.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${C.getShaderInfoLog(pe)}`);
            C.attachShader(this.program, pe), this.attributes = {};
            const be = {};
            this.numAttributes = R.length;
            for (let ge = 0; ge < this.numAttributes; ge++) R[ge] && (C.bindAttribLocation(this.program, ge, R[ge]), this.attributes[R[ge]] = ge);
            if (C.linkProgram(this.program), !C.getProgramParameter(this.program, C.LINK_STATUS)) throw new Error(`Program failed to link: ${C.getProgramInfoLog(this.program)}`);
            C.deleteShader(pe), C.deleteShader(Y);
            for (let ge = 0; ge < J.length; ge++) {
              const _e = J[ge];
              if (_e && !be[_e]) {
                const xe = C.getUniformLocation(this.program, _e);
                xe && (be[_e] = xe);
              }
            }
            this.fixedUniforms = c(e, be), this.terrainUniforms = ((ge, _e) => ({ u_depth: new a.bP(ge, _e.u_depth), u_terrain: new a.bP(ge, _e.u_terrain), u_terrain_dim: new a.bg(ge, _e.u_terrain_dim), u_terrain_matrix: new a.bR(ge, _e.u_terrain_matrix), u_terrain_unpack: new a.bS(ge, _e.u_terrain_unpack), u_terrain_exaggeration: new a.bg(ge, _e.u_terrain_exaggeration) }))(e, be), this.projectionUniforms = ((ge, _e) => ({ u_projection_matrix: new a.bR(ge, _e.u_projection_matrix), u_projection_tile_mercator_coords: new a.bS(ge, _e.u_projection_tile_mercator_coords), u_projection_clipping_plane: new a.bS(ge, _e.u_projection_clipping_plane), u_projection_transition: new a.bg(ge, _e.u_projection_transition), u_projection_fallback_matrix: new a.bR(ge, _e.u_projection_fallback_matrix) }))(e, be), this.binderUniforms = o ? o.getUniforms(e, be) : [];
          }
          draw(e, n, o, c, d, g, v, x, M, C, k, A, R, O, G, Z, q, W, J) {
            const K = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(o), e.setStencilMode(c), e.setColorMode(d), e.setCullFace(g), x) {
              e.activeTexture.set(K.TEXTURE2), K.bindTexture(K.TEXTURE_2D, x.depthTexture), e.activeTexture.set(K.TEXTURE3), K.bindTexture(K.TEXTURE_2D, x.texture);
              for (const se in this.terrainUniforms) this.terrainUniforms[se].set(x[se]);
            }
            if (M) for (const se in M) this.projectionUniforms[Ul[se]].set(M[se]);
            if (v) for (const se in this.fixedUniforms) this.fixedUniforms[se].set(v[se]);
            Z && Z.setUniforms(e, this.binderUniforms, O, { zoom: G });
            let te = 0;
            switch (n) {
              case K.LINES:
                te = 2;
                break;
              case K.TRIANGLES:
                te = 3;
                break;
              case K.LINE_STRIP:
                te = 1;
            }
            for (const se of R.get()) {
              const Y = se.vaos || (se.vaos = {});
              (Y[C] || (Y[C] = new cd())).bind(e, this, k, Z ? Z.getPaintVertexBuffers() : [], A, se.vertexOffset, q, W, J), K.drawElements(n, se.primitiveLength * te, K.UNSIGNED_SHORT, se.primitiveOffset * te * 2);
            }
          }
        }
        function Aa(h, e, n) {
          const o = 1 / a.aC(n, 1, e.transform.tileZoom), c = Math.pow(2, n.tileID.overscaledZ), d = n.tileSize * Math.pow(2, e.transform.tileZoom) / c, g = d * (n.tileID.canonical.x + n.tileID.wrap * c), v = d * n.tileID.canonical.y;
          return { u_image: 0, u_texsize: n.imageAtlasTexture.size, u_scale: [o, h.fromScale, h.toScale], u_fade: h.t, u_pixel_coord_upper: [g >> 16, v >> 16], u_pixel_coord_lower: [65535 & g, 65535 & v] };
        }
        const rn = (h, e, n, o) => {
          const c = h.style.light, d = c.properties.get("position"), g = [d.x, d.y, d.z], v = a.bV();
          c.properties.get("anchor") === "viewport" && a.bW(v, h.transform.bearingInRadians), a.bX(g, g, v);
          const x = h.transform.transformLightDirection(g), M = c.properties.get("color");
          return { u_lightpos: g, u_lightpos_globe: x, u_lightintensity: c.properties.get("intensity"), u_lightcolor: [M.r, M.g, M.b], u_vertical_gradient: +e, u_opacity: n, u_fill_translate: o };
        }, ud = (h, e, n, o, c, d, g) => a.e(rn(h, e, n, o), Aa(d, h, g), { u_height_factor: -Math.pow(2, c.overscaledZ) / g.tileSize / 8 }), ka = (h, e, n, o) => a.e(Aa(e, h, n), { u_fill_translate: o }), Fo = (h, e) => ({ u_world: h, u_fill_translate: e }), Bo = (h, e, n, o, c) => a.e(ka(h, e, n, c), { u_world: o }), hd = (h, e, n, o, c) => {
          const d = h.transform;
          let g, v, x = 0;
          if (n.paint.get("circle-pitch-alignment") === "map") {
            const M = a.aC(e, 1, d.zoom);
            g = !0, v = [M, M], x = M / (a.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * c;
          } else g = !1, v = d.pixelsToGLUnits;
          return { u_camera_to_center_distance: d.cameraToCenterDistance, u_scale_with_map: +(n.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +g, u_device_pixel_ratio: h.pixelRatio, u_extrude_scale: v, u_globe_extrude_scale: x, u_translate: o };
        }, za = (h) => ({ u_pixel_extrude_scale: [1 / h.width, 1 / h.height] }), dd = (h) => ({ u_viewport_size: [h.width, h.height] }), vs = (h, e = 1) => ({ u_color: h, u_overlay: 0, u_overlay_scale: e }), mu = (h, e, n, o) => {
          const c = a.aC(h, 1, e) / (a.$ * Math.pow(2, h.tileID.overscaledZ)) * 2 * Math.PI * o;
          return { u_extrude_scale: a.aC(h, 1, e), u_intensity: n, u_globe_extrude_scale: c };
        }, Gl = (h, e, n, o) => {
          const c = a.L();
          a.bY(c, 0, h.width, h.height, 0, 0, 1);
          const d = h.context.gl;
          return { u_matrix: c, u_world: [d.drawingBufferWidth, d.drawingBufferHeight], u_image: n, u_color_ramp: o, u_opacity: e.paint.get("heatmap-opacity") };
        }, pd = (h, e, n) => {
          const o = n.paint.get("hillshade-accent-color");
          let c;
          switch (n.paint.get("hillshade-method")) {
            case "basic":
              c = 4;
              break;
            case "combined":
              c = 1;
              break;
            case "igor":
              c = 2;
              break;
            case "multidirectional":
              c = 3;
              break;
            default:
              c = 0;
          }
          const d = n.getIlluminationProperties();
          for (let g = 0; g < d.directionRadians.length; g++) n.paint.get("hillshade-illumination-anchor") === "viewport" && (d.directionRadians[g] += h.transform.bearingInRadians);
          return { u_image: 0, u_latrange: ql(0, e.tileID), u_exaggeration: n.paint.get("hillshade-exaggeration"), u_altitudes: d.altitudeRadians, u_azimuths: d.directionRadians, u_accent: o, u_method: c, u_highlights: d.highlightColor, u_shadows: d.shadowColor };
        }, gu = (h, e) => {
          const n = e.stride, o = a.L();
          return a.bY(o, 0, a.$, -a.$, 0, 0, 1), a.M(o, o, [0, -a.$, 0]), { u_matrix: o, u_image: 1, u_dimension: [n, n], u_zoom: h.overscaledZ, u_unpack: e.getUnpackVector() };
        };
        function ql(h, e) {
          const n = Math.pow(2, e.canonical.z), o = e.canonical.y;
          return [new a.a1(0, o / n).toLngLat().lat, new a.a1(0, (o + 1) / n).toLngLat().lat];
        }
        const _u = (h, e, n = 0) => ({ u_image: 0, u_unpack: e.getUnpackVector(), u_dimension: [e.stride, e.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: n, u_opacity: h.paint.get("color-relief-opacity") }), Ra = (h, e, n, o) => {
          const c = h.transform;
          return { u_translation: Wl(h, e, n), u_ratio: o / a.aC(e, 1, c.zoom), u_device_pixel_ratio: h.pixelRatio, u_units_to_pixels: [1 / c.pixelsToGLUnits[0], 1 / c.pixelsToGLUnits[1]] };
        }, yu = (h, e, n, o, c) => a.e(Ra(h, e, n, o), { u_image: 0, u_image_height: c }), vu = (h, e, n, o, c) => {
          const d = h.transform, g = Hl(e, d);
          return { u_translation: Wl(h, e, n), u_texsize: e.imageAtlasTexture.size, u_ratio: o / a.aC(e, 1, d.zoom), u_device_pixel_ratio: h.pixelRatio, u_image: 0, u_scale: [g, c.fromScale, c.toScale], u_fade: c.t, u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]] };
        }, xs = (h, e, n, o, c, d) => {
          const g = h.lineAtlas, v = Hl(e, h.transform), x = n.layout.get("line-cap") === "round", M = g.getDash(c.from, x), C = g.getDash(c.to, x), k = M.width * d.fromScale, A = C.width * d.toScale;
          return a.e(Ra(h, e, n, o), { u_patternscale_a: [v / k, -M.height / 2], u_patternscale_b: [v / A, -C.height / 2], u_sdfgamma: g.width / (256 * Math.min(k, A) * h.pixelRatio) / 2, u_image: 0, u_tex_y_a: M.y, u_tex_y_b: C.y, u_mix: d.t });
        };
        function Hl(h, e) {
          return 1 / a.aC(h, 1, e.tileZoom);
        }
        function Wl(h, e, n) {
          return a.aD(h.transform, e, n.paint.get("line-translate"), n.paint.get("line-translate-anchor"));
        }
        const Oo = (h, e, n, o, c) => {
          return { u_tl_parent: h, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: n.mix, u_opacity: n.opacity * o.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: o.paint.get("raster-brightness-min"), u_brightness_high: o.paint.get("raster-brightness-max"), u_saturation_factor: (g = o.paint.get("raster-saturation"), g > 0 ? 1 - 1 / (1.001 - g) : -g), u_contrast_factor: (d = o.paint.get("raster-contrast"), d > 0 ? 1 / (1 - d) : 1 + d), u_spin_weights: fd(o.paint.get("raster-hue-rotate")), u_coords_top: [c[0].x, c[0].y, c[1].x, c[1].y], u_coords_bottom: [c[3].x, c[3].y, c[2].x, c[2].y] };
          var d, g;
        };
        function fd(h) {
          h *= Math.PI / 180;
          const e = Math.sin(h), n = Math.cos(h);
          return [(2 * n + 1) / 3, (-Math.sqrt(3) * e - n + 1) / 3, (Math.sqrt(3) * e - n + 1) / 3];
        }
        const jo = (h, e, n, o, c, d, g, v, x, M, C, k, A) => {
          const R = g.transform;
          return { u_is_size_zoom_constant: +(h === "constant" || h === "source"), u_is_size_feature_constant: +(h === "constant" || h === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: R.cameraToCenterDistance, u_pitch: R.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +n, u_aspect_ratio: R.width / R.height, u_fade_change: g.options.fadeDuration ? g.symbolFadeChange : 1, u_label_plane_matrix: v, u_coord_matrix: x, u_is_text: +C, u_pitch_with_map: +o, u_is_along_line: c, u_is_variable_anchor: d, u_texsize: k, u_texture: 0, u_translation: M, u_pitched_scale: A };
        }, xu = (h, e, n, o, c, d, g, v, x, M, C, k, A, R) => {
          const O = g.transform;
          return a.e(jo(h, e, n, o, c, d, g, v, x, M, C, k, R), { u_gamma_scale: o ? Math.cos(O.pitch * Math.PI / 180) * O.cameraToCenterDistance : 1, u_device_pixel_ratio: g.pixelRatio, u_is_halo: 1 });
        }, md = (h, e, n, o, c, d, g, v, x, M, C, k, A) => a.e(xu(h, e, n, o, c, d, g, v, x, M, !0, C, 0, A), { u_texsize_icon: k, u_texture_icon: 1 }), bu = (h, e) => ({ u_opacity: h, u_color: e }), wu = (h, e, n, o, c) => a.e(function(d, g, v, x) {
          const M = v.imageManager.getPattern(d.from.toString()), C = v.imageManager.getPattern(d.to.toString()), { width: k, height: A } = v.imageManager.getPixelSize(), R = Math.pow(2, x.tileID.overscaledZ), O = x.tileSize * Math.pow(2, v.transform.tileZoom) / R, G = O * (x.tileID.canonical.x + x.tileID.wrap * R), Z = O * x.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: M.tl, u_pattern_br_a: M.br, u_pattern_tl_b: C.tl, u_pattern_br_b: C.br, u_texsize: [k, A], u_mix: g.t, u_pattern_size_a: M.displaySize, u_pattern_size_b: C.displaySize, u_scale_a: g.fromScale, u_scale_b: g.toScale, u_tile_units_to_pixels: 1 / a.aC(x, 1, v.transform.tileZoom), u_pixel_coord_upper: [G >> 16, Z >> 16], u_pixel_coord_lower: [65535 & G, 65535 & Z] };
        }(n, c, e, o), { u_opacity: h }), Xl = (h, e) => {
        }, Kl = { fillExtrusion: (h, e) => ({ u_lightpos: new a.bT(h, e.u_lightpos), u_lightpos_globe: new a.bT(h, e.u_lightpos_globe), u_lightintensity: new a.bg(h, e.u_lightintensity), u_lightcolor: new a.bT(h, e.u_lightcolor), u_vertical_gradient: new a.bg(h, e.u_vertical_gradient), u_opacity: new a.bg(h, e.u_opacity), u_fill_translate: new a.bU(h, e.u_fill_translate) }), fillExtrusionPattern: (h, e) => ({ u_lightpos: new a.bT(h, e.u_lightpos), u_lightpos_globe: new a.bT(h, e.u_lightpos_globe), u_lightintensity: new a.bg(h, e.u_lightintensity), u_lightcolor: new a.bT(h, e.u_lightcolor), u_vertical_gradient: new a.bg(h, e.u_vertical_gradient), u_height_factor: new a.bg(h, e.u_height_factor), u_opacity: new a.bg(h, e.u_opacity), u_fill_translate: new a.bU(h, e.u_fill_translate), u_image: new a.bP(h, e.u_image), u_texsize: new a.bU(h, e.u_texsize), u_pixel_coord_upper: new a.bU(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new a.bU(h, e.u_pixel_coord_lower), u_scale: new a.bT(h, e.u_scale), u_fade: new a.bg(h, e.u_fade) }), fill: (h, e) => ({ u_fill_translate: new a.bU(h, e.u_fill_translate) }), fillPattern: (h, e) => ({ u_image: new a.bP(h, e.u_image), u_texsize: new a.bU(h, e.u_texsize), u_pixel_coord_upper: new a.bU(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new a.bU(h, e.u_pixel_coord_lower), u_scale: new a.bT(h, e.u_scale), u_fade: new a.bg(h, e.u_fade), u_fill_translate: new a.bU(h, e.u_fill_translate) }), fillOutline: (h, e) => ({ u_world: new a.bU(h, e.u_world), u_fill_translate: new a.bU(h, e.u_fill_translate) }), fillOutlinePattern: (h, e) => ({ u_world: new a.bU(h, e.u_world), u_image: new a.bP(h, e.u_image), u_texsize: new a.bU(h, e.u_texsize), u_pixel_coord_upper: new a.bU(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new a.bU(h, e.u_pixel_coord_lower), u_scale: new a.bT(h, e.u_scale), u_fade: new a.bg(h, e.u_fade), u_fill_translate: new a.bU(h, e.u_fill_translate) }), circle: (h, e) => ({ u_camera_to_center_distance: new a.bg(h, e.u_camera_to_center_distance), u_scale_with_map: new a.bP(h, e.u_scale_with_map), u_pitch_with_map: new a.bP(h, e.u_pitch_with_map), u_extrude_scale: new a.bU(h, e.u_extrude_scale), u_device_pixel_ratio: new a.bg(h, e.u_device_pixel_ratio), u_globe_extrude_scale: new a.bg(h, e.u_globe_extrude_scale), u_translate: new a.bU(h, e.u_translate) }), collisionBox: (h, e) => ({ u_pixel_extrude_scale: new a.bU(h, e.u_pixel_extrude_scale) }), collisionCircle: (h, e) => ({ u_viewport_size: new a.bU(h, e.u_viewport_size) }), debug: (h, e) => ({ u_color: new a.bQ(h, e.u_color), u_overlay: new a.bP(h, e.u_overlay), u_overlay_scale: new a.bg(h, e.u_overlay_scale) }), depth: Xl, clippingMask: Xl, heatmap: (h, e) => ({ u_extrude_scale: new a.bg(h, e.u_extrude_scale), u_intensity: new a.bg(h, e.u_intensity), u_globe_extrude_scale: new a.bg(h, e.u_globe_extrude_scale) }), heatmapTexture: (h, e) => ({ u_matrix: new a.bR(h, e.u_matrix), u_world: new a.bU(h, e.u_world), u_image: new a.bP(h, e.u_image), u_color_ramp: new a.bP(h, e.u_color_ramp), u_opacity: new a.bg(h, e.u_opacity) }), hillshade: (h, e) => ({ u_image: new a.bP(h, e.u_image), u_latrange: new a.bU(h, e.u_latrange), u_exaggeration: new a.bg(h, e.u_exaggeration), u_altitudes: new a.b_(h, e.u_altitudes), u_azimuths: new a.b_(h, e.u_azimuths), u_accent: new a.bQ(h, e.u_accent), u_method: new a.bP(h, e.u_method), u_shadows: new a.bZ(h, e.u_shadows), u_highlights: new a.bZ(h, e.u_highlights) }), hillshadePrepare: (h, e) => ({ u_matrix: new a.bR(h, e.u_matrix), u_image: new a.bP(h, e.u_image), u_dimension: new a.bU(h, e.u_dimension), u_zoom: new a.bg(h, e.u_zoom), u_unpack: new a.bS(h, e.u_unpack) }), colorRelief: (h, e) => ({ u_image: new a.bP(h, e.u_image), u_unpack: new a.bS(h, e.u_unpack), u_dimension: new a.bU(h, e.u_dimension), u_elevation_stops: new a.bP(h, e.u_elevation_stops), u_color_stops: new a.bP(h, e.u_color_stops), u_color_ramp_size: new a.bP(h, e.u_color_ramp_size), u_opacity: new a.bg(h, e.u_opacity) }), line: (h, e) => ({ u_translation: new a.bU(h, e.u_translation), u_ratio: new a.bg(h, e.u_ratio), u_device_pixel_ratio: new a.bg(h, e.u_device_pixel_ratio), u_units_to_pixels: new a.bU(h, e.u_units_to_pixels) }), lineGradient: (h, e) => ({ u_translation: new a.bU(h, e.u_translation), u_ratio: new a.bg(h, e.u_ratio), u_device_pixel_ratio: new a.bg(h, e.u_device_pixel_ratio), u_units_to_pixels: new a.bU(h, e.u_units_to_pixels), u_image: new a.bP(h, e.u_image), u_image_height: new a.bg(h, e.u_image_height) }), linePattern: (h, e) => ({ u_translation: new a.bU(h, e.u_translation), u_texsize: new a.bU(h, e.u_texsize), u_ratio: new a.bg(h, e.u_ratio), u_device_pixel_ratio: new a.bg(h, e.u_device_pixel_ratio), u_image: new a.bP(h, e.u_image), u_units_to_pixels: new a.bU(h, e.u_units_to_pixels), u_scale: new a.bT(h, e.u_scale), u_fade: new a.bg(h, e.u_fade) }), lineSDF: (h, e) => ({ u_translation: new a.bU(h, e.u_translation), u_ratio: new a.bg(h, e.u_ratio), u_device_pixel_ratio: new a.bg(h, e.u_device_pixel_ratio), u_units_to_pixels: new a.bU(h, e.u_units_to_pixels), u_patternscale_a: new a.bU(h, e.u_patternscale_a), u_patternscale_b: new a.bU(h, e.u_patternscale_b), u_sdfgamma: new a.bg(h, e.u_sdfgamma), u_image: new a.bP(h, e.u_image), u_tex_y_a: new a.bg(h, e.u_tex_y_a), u_tex_y_b: new a.bg(h, e.u_tex_y_b), u_mix: new a.bg(h, e.u_mix) }), raster: (h, e) => ({ u_tl_parent: new a.bU(h, e.u_tl_parent), u_scale_parent: new a.bg(h, e.u_scale_parent), u_buffer_scale: new a.bg(h, e.u_buffer_scale), u_fade_t: new a.bg(h, e.u_fade_t), u_opacity: new a.bg(h, e.u_opacity), u_image0: new a.bP(h, e.u_image0), u_image1: new a.bP(h, e.u_image1), u_brightness_low: new a.bg(h, e.u_brightness_low), u_brightness_high: new a.bg(h, e.u_brightness_high), u_saturation_factor: new a.bg(h, e.u_saturation_factor), u_contrast_factor: new a.bg(h, e.u_contrast_factor), u_spin_weights: new a.bT(h, e.u_spin_weights), u_coords_top: new a.bS(h, e.u_coords_top), u_coords_bottom: new a.bS(h, e.u_coords_bottom) }), symbolIcon: (h, e) => ({ u_is_size_zoom_constant: new a.bP(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new a.bP(h, e.u_is_size_feature_constant), u_size_t: new a.bg(h, e.u_size_t), u_size: new a.bg(h, e.u_size), u_camera_to_center_distance: new a.bg(h, e.u_camera_to_center_distance), u_pitch: new a.bg(h, e.u_pitch), u_rotate_symbol: new a.bP(h, e.u_rotate_symbol), u_aspect_ratio: new a.bg(h, e.u_aspect_ratio), u_fade_change: new a.bg(h, e.u_fade_change), u_label_plane_matrix: new a.bR(h, e.u_label_plane_matrix), u_coord_matrix: new a.bR(h, e.u_coord_matrix), u_is_text: new a.bP(h, e.u_is_text), u_pitch_with_map: new a.bP(h, e.u_pitch_with_map), u_is_along_line: new a.bP(h, e.u_is_along_line), u_is_variable_anchor: new a.bP(h, e.u_is_variable_anchor), u_texsize: new a.bU(h, e.u_texsize), u_texture: new a.bP(h, e.u_texture), u_translation: new a.bU(h, e.u_translation), u_pitched_scale: new a.bg(h, e.u_pitched_scale) }), symbolSDF: (h, e) => ({ u_is_size_zoom_constant: new a.bP(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new a.bP(h, e.u_is_size_feature_constant), u_size_t: new a.bg(h, e.u_size_t), u_size: new a.bg(h, e.u_size), u_camera_to_center_distance: new a.bg(h, e.u_camera_to_center_distance), u_pitch: new a.bg(h, e.u_pitch), u_rotate_symbol: new a.bP(h, e.u_rotate_symbol), u_aspect_ratio: new a.bg(h, e.u_aspect_ratio), u_fade_change: new a.bg(h, e.u_fade_change), u_label_plane_matrix: new a.bR(h, e.u_label_plane_matrix), u_coord_matrix: new a.bR(h, e.u_coord_matrix), u_is_text: new a.bP(h, e.u_is_text), u_pitch_with_map: new a.bP(h, e.u_pitch_with_map), u_is_along_line: new a.bP(h, e.u_is_along_line), u_is_variable_anchor: new a.bP(h, e.u_is_variable_anchor), u_texsize: new a.bU(h, e.u_texsize), u_texture: new a.bP(h, e.u_texture), u_gamma_scale: new a.bg(h, e.u_gamma_scale), u_device_pixel_ratio: new a.bg(h, e.u_device_pixel_ratio), u_is_halo: new a.bP(h, e.u_is_halo), u_translation: new a.bU(h, e.u_translation), u_pitched_scale: new a.bg(h, e.u_pitched_scale) }), symbolTextAndIcon: (h, e) => ({ u_is_size_zoom_constant: new a.bP(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new a.bP(h, e.u_is_size_feature_constant), u_size_t: new a.bg(h, e.u_size_t), u_size: new a.bg(h, e.u_size), u_camera_to_center_distance: new a.bg(h, e.u_camera_to_center_distance), u_pitch: new a.bg(h, e.u_pitch), u_rotate_symbol: new a.bP(h, e.u_rotate_symbol), u_aspect_ratio: new a.bg(h, e.u_aspect_ratio), u_fade_change: new a.bg(h, e.u_fade_change), u_label_plane_matrix: new a.bR(h, e.u_label_plane_matrix), u_coord_matrix: new a.bR(h, e.u_coord_matrix), u_is_text: new a.bP(h, e.u_is_text), u_pitch_with_map: new a.bP(h, e.u_pitch_with_map), u_is_along_line: new a.bP(h, e.u_is_along_line), u_is_variable_anchor: new a.bP(h, e.u_is_variable_anchor), u_texsize: new a.bU(h, e.u_texsize), u_texsize_icon: new a.bU(h, e.u_texsize_icon), u_texture: new a.bP(h, e.u_texture), u_texture_icon: new a.bP(h, e.u_texture_icon), u_gamma_scale: new a.bg(h, e.u_gamma_scale), u_device_pixel_ratio: new a.bg(h, e.u_device_pixel_ratio), u_is_halo: new a.bP(h, e.u_is_halo), u_translation: new a.bU(h, e.u_translation), u_pitched_scale: new a.bg(h, e.u_pitched_scale) }), background: (h, e) => ({ u_opacity: new a.bg(h, e.u_opacity), u_color: new a.bQ(h, e.u_color) }), backgroundPattern: (h, e) => ({ u_opacity: new a.bg(h, e.u_opacity), u_image: new a.bP(h, e.u_image), u_pattern_tl_a: new a.bU(h, e.u_pattern_tl_a), u_pattern_br_a: new a.bU(h, e.u_pattern_br_a), u_pattern_tl_b: new a.bU(h, e.u_pattern_tl_b), u_pattern_br_b: new a.bU(h, e.u_pattern_br_b), u_texsize: new a.bU(h, e.u_texsize), u_mix: new a.bg(h, e.u_mix), u_pattern_size_a: new a.bU(h, e.u_pattern_size_a), u_pattern_size_b: new a.bU(h, e.u_pattern_size_b), u_scale_a: new a.bg(h, e.u_scale_a), u_scale_b: new a.bg(h, e.u_scale_b), u_pixel_coord_upper: new a.bU(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new a.bU(h, e.u_pixel_coord_lower), u_tile_units_to_pixels: new a.bg(h, e.u_tile_units_to_pixels) }), terrain: (h, e) => ({ u_texture: new a.bP(h, e.u_texture), u_ele_delta: new a.bg(h, e.u_ele_delta), u_fog_matrix: new a.bR(h, e.u_fog_matrix), u_fog_color: new a.bQ(h, e.u_fog_color), u_fog_ground_blend: new a.bg(h, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new a.bg(h, e.u_fog_ground_blend_opacity), u_horizon_color: new a.bQ(h, e.u_horizon_color), u_horizon_fog_blend: new a.bg(h, e.u_horizon_fog_blend), u_is_globe_mode: new a.bg(h, e.u_is_globe_mode) }), terrainDepth: (h, e) => ({ u_ele_delta: new a.bg(h, e.u_ele_delta) }), terrainCoords: (h, e) => ({ u_texture: new a.bP(h, e.u_texture), u_terrain_coords_id: new a.bg(h, e.u_terrain_coords_id), u_ele_delta: new a.bg(h, e.u_ele_delta) }), projectionErrorMeasurement: (h, e) => ({ u_input: new a.bg(h, e.u_input), u_output_expected: new a.bg(h, e.u_output_expected) }), atmosphere: (h, e) => ({ u_sun_pos: new a.bT(h, e.u_sun_pos), u_atmosphere_blend: new a.bg(h, e.u_atmosphere_blend), u_globe_position: new a.bT(h, e.u_globe_position), u_globe_radius: new a.bg(h, e.u_globe_radius), u_inv_proj_matrix: new a.bR(h, e.u_inv_proj_matrix) }), sky: (h, e) => ({ u_sky_color: new a.bQ(h, e.u_sky_color), u_horizon_color: new a.bQ(h, e.u_horizon_color), u_horizon: new a.bU(h, e.u_horizon), u_horizon_normal: new a.bU(h, e.u_horizon_normal), u_sky_horizon_blend: new a.bg(h, e.u_sky_horizon_blend), u_sky_blend: new a.bg(h, e.u_sky_blend) }) };
        class Tu {
          constructor(e, n, o) {
            this.context = e;
            const c = e.gl;
            this.buffer = c.createBuffer(), this.dynamicDraw = !!o, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), c.bufferData(c.ELEMENT_ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? c.DYNAMIC_DRAW : c.STATIC_DRAW), this.dynamicDraw || delete n.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e) {
            const n = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), n.bufferSubData(n.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Da = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class An {
          constructor(e, n, o, c) {
            this.length = n.length, this.attributes = o, this.itemSize = n.bytesPerElement, this.dynamicDraw = c, this.context = e;
            const d = e.gl;
            this.buffer = d.createBuffer(), e.bindVertexBuffer.set(this.buffer), d.bufferData(d.ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete n.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const n = this.context.gl;
            this.bind(), n.bufferSubData(n.ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          enableAttributes(e, n) {
            for (let o = 0; o < this.attributes.length; o++) {
              const c = n.attributes[this.attributes[o].name];
              c !== void 0 && e.enableVertexAttribArray(c);
            }
          }
          setVertexAttribPointers(e, n, o) {
            for (let c = 0; c < this.attributes.length; c++) {
              const d = this.attributes[c], g = n.attributes[d.name];
              g !== void 0 && e.vertexAttribPointer(g, d.components, e[Da[d.type]], !1, this.itemSize, d.offset + this.itemSize * (o || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Xt {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(e) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Yl extends Xt {
          getDefault() {
            return a.bf.transparent;
          }
          set(e) {
            const n = this.current;
            (e.r !== n.r || e.g !== n.g || e.b !== n.b || e.a !== n.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
          }
        }
        class Jl extends Xt {
          getDefault() {
            return 1;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
          }
        }
        class Su extends Xt {
          getDefault() {
            return 0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
          }
        }
        class Ql extends Xt {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(e) {
            const n = this.current;
            (e[0] !== n[0] || e[1] !== n[1] || e[2] !== n[2] || e[3] !== n[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
          }
        }
        class bs extends Xt {
          getDefault() {
            return !0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
          }
        }
        class ec extends Xt {
          getDefault() {
            return 255;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
          }
        }
        class gd extends Xt {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e) {
            const n = this.current;
            (e.func !== n.func || e.ref !== n.ref || e.mask !== n.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
          }
        }
        class _d extends Xt {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP];
          }
          set(e) {
            const n = this.current;
            (e[0] !== n[0] || e[1] !== n[1] || e[2] !== n[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
          }
        }
        class yd extends Xt {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            e ? n.enable(n.STENCIL_TEST) : n.disable(n.STENCIL_TEST), this.current = e, this.dirty = !1;
          }
        }
        class vd extends Xt {
          getDefault() {
            return [0, 1];
          }
          set(e) {
            const n = this.current;
            (e[0] !== n[0] || e[1] !== n[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
          }
        }
        class Pu extends Xt {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            e ? n.enable(n.DEPTH_TEST) : n.disable(n.DEPTH_TEST), this.current = e, this.dirty = !1;
          }
        }
        class xd extends Xt {
          getDefault() {
            return this.gl.LESS;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
          }
        }
        class Mu extends Xt {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            e ? n.enable(n.BLEND) : n.disable(n.BLEND), this.current = e, this.dirty = !1;
          }
        }
        class La extends Xt {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO];
          }
          set(e) {
            const n = this.current;
            (e[0] !== n[0] || e[1] !== n[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
          }
        }
        class Fa extends Xt {
          getDefault() {
            return a.bf.transparent;
          }
          set(e) {
            const n = this.current;
            (e.r !== n.r || e.g !== n.g || e.b !== n.b || e.a !== n.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
          }
        }
        class Ba extends Xt {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
          }
        }
        class tc extends Xt {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            e ? n.enable(n.CULL_FACE) : n.disable(n.CULL_FACE), this.current = e, this.dirty = !1;
          }
        }
        class ws extends Xt {
          getDefault() {
            return this.gl.BACK;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
          }
        }
        class Vo extends Xt {
          getDefault() {
            return this.gl.CCW;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
          }
        }
        class Ys extends Xt {
          getDefault() {
            return null;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
          }
        }
        class Wr extends Xt {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
          }
        }
        class Cu extends Xt {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
          }
          set(e) {
            const n = this.current;
            (e[0] !== n[0] || e[1] !== n[1] || e[2] !== n[2] || e[3] !== n[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
          }
        }
        class Iu extends Xt {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindFramebuffer(n.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class ic extends Xt {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindRenderbuffer(n.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class Ts extends Xt {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindTexture(n.TEXTURE_2D, e), this.current = e, this.dirty = !1;
          }
        }
        class Oa extends Xt {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindBuffer(n.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class ja extends Xt {
          getDefault() {
            return null;
          }
          set(e) {
            const n = this.gl;
            n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class No extends Xt {
          getDefault() {
            return null;
          }
          set(e) {
            var n;
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            bn(o) ? o.bindVertexArray(e) : (n = o.getExtension("OES_vertex_array_object")) === null || n === void 0 || n.bindVertexArrayOES(e), this.current = e, this.dirty = !1;
          }
        }
        class Va extends Xt {
          getDefault() {
            return 4;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
          }
        }
        class Eu extends Xt {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
          }
        }
        class Js extends Xt {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
          }
        }
        class Wn extends Xt {
          constructor(e, n) {
            super(e), this.context = e, this.parent = n;
          }
          getDefault() {
            return null;
          }
        }
        class Au extends Wn {
          setDirty() {
            this.dirty = !0;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
          }
        }
        class rc extends Wn {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class jt extends Wn {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        const $o = "Framebuffer is not complete";
        class bd {
          constructor(e, n, o, c, d) {
            this.context = e, this.width = n, this.height = o;
            const g = e.gl, v = this.framebuffer = g.createFramebuffer();
            if (this.colorAttachment = new Au(e, v), c) this.depthAttachment = d ? new jt(e, v) : new rc(e, v);
            else if (d) throw new Error("Stencil cannot be set without depth");
            if (g.checkFramebufferStatus(g.FRAMEBUFFER) !== g.FRAMEBUFFER_COMPLETE) throw new Error($o);
          }
          destroy() {
            const e = this.context.gl, n = this.colorAttachment.get();
            if (n && e.deleteTexture(n), this.depthAttachment) {
              const o = this.depthAttachment.get();
              o && e.deleteRenderbuffer(o);
            }
            e.deleteFramebuffer(this.framebuffer);
          }
        }
        class ku {
          constructor(e) {
            var n, o;
            if (this.gl = e, this.clearColor = new Yl(this), this.clearDepth = new Jl(this), this.clearStencil = new Su(this), this.colorMask = new Ql(this), this.depthMask = new bs(this), this.stencilMask = new ec(this), this.stencilFunc = new gd(this), this.stencilOp = new _d(this), this.stencilTest = new yd(this), this.depthRange = new vd(this), this.depthTest = new Pu(this), this.depthFunc = new xd(this), this.blend = new Mu(this), this.blendFunc = new La(this), this.blendColor = new Fa(this), this.blendEquation = new Ba(this), this.cullFace = new tc(this), this.cullFaceSide = new ws(this), this.frontFace = new Vo(this), this.program = new Ys(this), this.activeTexture = new Wr(this), this.viewport = new Cu(this), this.bindFramebuffer = new Iu(this), this.bindRenderbuffer = new ic(this), this.bindTexture = new Ts(this), this.bindVertexBuffer = new Oa(this), this.bindElementBuffer = new ja(this), this.bindVertexArray = new No(this), this.pixelStoreUnpack = new Va(this), this.pixelStoreUnpackPremultiplyAlpha = new Eu(this), this.pixelStoreUnpackFlipY = new Js(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), bn(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const c = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (n = e.RGBA16F) !== null && n !== void 0 ? n : c == null ? void 0 : c.RGBA16F_EXT, this.RGB16F = (o = e.RGB16F) !== null && o !== void 0 ? o : c == null ? void 0 : c.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const c = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = c == null ? void 0 : c.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(e, n) {
            return new Tu(this, e, n);
          }
          createVertexBuffer(e, n, o) {
            return new An(this, e, n, o);
          }
          createRenderbuffer(e, n, o) {
            const c = this.gl, d = c.createRenderbuffer();
            return this.bindRenderbuffer.set(d), c.renderbufferStorage(c.RENDERBUFFER, e, n, o), this.bindRenderbuffer.set(null), d;
          }
          createFramebuffer(e, n, o, c) {
            return new bd(this, e, n, o, c);
          }
          clear({ color: e, depth: n, stencil: o }) {
            const c = this.gl;
            let d = 0;
            e && (d |= c.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), n !== void 0 && (d |= c.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(n), this.depthMask.set(!0)), o !== void 0 && (d |= c.STENCIL_BUFFER_BIT, this.clearStencil.set(o), this.stencilMask.set(255)), c.clear(d);
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(e) {
            a.bH(e.blendFunction, hi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
          }
          createVertexArray() {
            var e;
            return bn(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
          }
          deleteVertexArray(e) {
            var n;
            return bn(this.gl) ? this.gl.deleteVertexArray(e) : (n = this.gl.getExtension("OES_vertex_array_object")) === null || n === void 0 ? void 0 : n.deleteVertexArrayOES(e);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let Xn;
        function zu(h, e, n, o, c) {
          const d = h.context, g = h.transform, v = d.gl, x = h.useProgram("collisionBox"), M = [];
          let C = 0, k = 0;
          for (let q = 0; q < o.length; q++) {
            const W = o[q], J = e.getTile(W).getBucket(n);
            if (!J) continue;
            const K = c ? J.textCollisionBox : J.iconCollisionBox, te = J.collisionCircleArray;
            te.length > 0 && (M.push({ circleArray: te, circleOffset: k, coord: W }), C += te.length / 4, k = C), K && x.draw(d, v.LINES, Tt.disabled, qt.disabled, h.colorModeForRenderPass(), ft.disabled, za(h.transform), h.style.map.terrain && h.style.map.terrain.getTerrainData(W), g.getProjectionData({ overscaledTileID: W, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), n.id, K.layoutVertexBuffer, K.indexBuffer, K.segments, null, h.transform.zoom, null, null, K.collisionVertexBuffer);
          }
          if (!c || !M.length) return;
          const A = h.useProgram("collisionCircle"), R = new a.b$();
          R.resize(4 * C), R._trim();
          let O = 0;
          for (const q of M) for (let W = 0; W < q.circleArray.length / 4; W++) {
            const J = 4 * W, K = q.circleArray[J + 0], te = q.circleArray[J + 1], se = q.circleArray[J + 2], Y = q.circleArray[J + 3];
            R.emplace(O++, K, te, se, Y, 0), R.emplace(O++, K, te, se, Y, 1), R.emplace(O++, K, te, se, Y, 2), R.emplace(O++, K, te, se, Y, 3);
          }
          (!Xn || Xn.length < 2 * C) && (Xn = function(q) {
            const W = 2 * q, J = new a.c1();
            J.resize(W), J._trim();
            for (let K = 0; K < W; K++) {
              const te = 6 * K;
              J.uint16[te + 0] = 4 * K + 0, J.uint16[te + 1] = 4 * K + 1, J.uint16[te + 2] = 4 * K + 2, J.uint16[te + 3] = 4 * K + 2, J.uint16[te + 4] = 4 * K + 3, J.uint16[te + 5] = 4 * K + 0;
            }
            return J;
          }(C));
          const G = d.createIndexBuffer(Xn, !0), Z = d.createVertexBuffer(R, a.c0.members, !0);
          for (const q of M) {
            const W = dd(h.transform);
            A.draw(d, v.TRIANGLES, Tt.disabled, qt.disabled, h.colorModeForRenderPass(), ft.disabled, W, h.style.map.terrain && h.style.map.terrain.getTerrainData(q.coord), null, n.id, Z, G, a.aM.simpleSegment(0, 2 * q.circleOffset, q.circleArray.length, q.circleArray.length / 2), null, h.transform.zoom, null, null, null);
          }
          Z.destroy(), G.destroy();
        }
        const wd = a.ag(new Float32Array(16));
        function Ru(h, e, n, o, c, d) {
          const { horizontalAlign: g, verticalAlign: v } = a.aH(h);
          return new a.P((-(g - 0.5) * e / c + o[0]) * d, (-(v - 0.5) * n / c + o[1]) * d);
        }
        function Td(h, e, n, o, c, d) {
          const g = e.tileAnchorPoint.add(new a.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let v = o.mult(d);
            n || (v = v.rotate(-c));
            const x = g.add(v);
            return Ri(x.x, x.y, e.pitchedLabelPlaneMatrix, e.getElevation).point;
          }
          if (n) {
            const v = rr(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h), x = Math.atan(v.y / v.x) + (v.x < 0 ? Math.PI : 0);
            return h.add(o.rotate(x));
          }
          return h.add(o);
        }
        function nc(h, e, n, o, c, d, g, v, x, M, C, k) {
          const A = h.text.placedSymbolArray, R = h.text.dynamicLayoutVertexArray, O = h.icon.dynamicLayoutVertexArray, G = {};
          R.clear();
          for (let Z = 0; Z < A.length; Z++) {
            const q = A.get(Z), W = q.hidden || !q.crossTileID || h.allowVerticalPlacement && !q.placedOrientation ? null : o[q.crossTileID];
            if (W) {
              const J = new a.P(q.anchorX, q.anchorY), K = { getElevation: k, width: c.width, height: c.height, pitchedLabelPlaneMatrix: d, pitchWithMap: n, transform: c, tileAnchorPoint: J, translation: M, unwrappedTileID: C }, te = n ? Un(J.x, J.y, K) : rr(J.x, J.y, K), se = Fe(c.cameraToCenterDistance, te.signedDistanceFromCamera);
              let Y = a.ap(h.textSizeData, v, q) * se / a.aB;
              n && (Y *= h.tilePixelRatio / g);
              const { width: pe, height: be, anchor: ge, textOffset: _e, textBoxScale: xe } = W, Le = Ru(ge, pe, be, _e, xe, Y), Oe = c.getPitchedTextCorrection(J.x + M[0], J.y + M[1], C), Ie = Td(te.point, K, e, Le, -c.bearingInRadians, Oe), et = h.allowVerticalPlacement && q.placedOrientation === a.ao.vertical ? Math.PI / 2 : 0;
              for (let Ct = 0; Ct < q.numGlyphs; Ct++) a.av(R, Ie, et);
              x && q.associatedIconIndex >= 0 && (G[q.associatedIconIndex] = { shiftedAnchor: Ie, angle: et });
            } else xn(q.numGlyphs, R);
          }
          if (x) {
            O.clear();
            const Z = h.icon.placedSymbolArray;
            for (let q = 0; q < Z.length; q++) {
              const W = Z.get(q);
              if (W.hidden) xn(W.numGlyphs, O);
              else {
                const J = G[q];
                if (J) for (let K = 0; K < W.numGlyphs; K++) a.av(O, J.shiftedAnchor, J.angle);
                else xn(W.numGlyphs, O);
              }
            }
            h.icon.dynamicLayoutVertexBuffer.updateData(O);
          }
          h.text.dynamicLayoutVertexBuffer.updateData(R);
        }
        function Na(h, e, n) {
          return n.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon";
        }
        function Uo(h, e, n, o, c, d, g, v, x, M, C, k, A) {
          const R = h.context, O = R.gl, G = h.transform, Z = v === "map", q = x === "map", W = v !== "viewport" && n.layout.get("symbol-placement") !== "point", J = Z && !q && !W, K = !n.layout.get("symbol-sort-key").isConstant();
          let te = !1;
          const se = h.getDepthModeForSublayer(0, Tt.ReadOnly), Y = n._unevaluatedLayout.hasValue("text-variable-anchor") || n._unevaluatedLayout.hasValue("text-variable-anchor-offset"), pe = [], be = G.getCircleRadiusCorrection();
          for (const ge of o) {
            const _e = e.getTile(ge), xe = _e.getBucket(n);
            if (!xe) continue;
            const Le = c ? xe.text : xe.icon;
            if (!Le || !Le.segments.get().length || !Le.hasVisibleVertices) continue;
            const Oe = Le.programConfigurations.get(n.id), Ie = c || xe.sdfIcons, et = c ? xe.textSizeData : xe.iconSizeData, Ct = q || G.pitch !== 0, Kt = h.useProgram(Na(Ie, c, xe), Oe), ri = a.an(et, G.zoom), ei = h.style.map.terrain && h.style.map.terrain.getTerrainData(ge);
            let gi, bi, Pt, ni, Li = [0, 0], Ni = null;
            if (c) bi = _e.glyphAtlasTexture, Pt = O.LINEAR, gi = _e.glyphAtlasTexture.size, xe.iconsInText && (Li = _e.imageAtlasTexture.size, Ni = _e.imageAtlasTexture, ni = Ct || h.options.rotating || h.options.zooming || et.kind === "composite" || et.kind === "camera" ? O.LINEAR : O.NEAREST);
            else {
              const Fi = n.layout.get("icon-size").constantOr(0) !== 1 || xe.iconsNeedLinear;
              bi = _e.imageAtlasTexture, Pt = Ie || h.options.rotating || h.options.zooming || Fi || Ct ? O.LINEAR : O.NEAREST, gi = _e.imageAtlasTexture.size;
            }
            const Wi = a.aC(_e, 1, h.transform.zoom), wr = Ci(Z, h.transform, Wi), cn = a.L();
            a.aq(cn, wr);
            const Yn = Ot(q, Z, h.transform, Wi), Jn = a.aD(G, _e, d, g), uo = G.getProjectionData({ overscaledTileID: ge, applyGlobeMatrix: !A, applyTerrainMatrix: !0 }), ho = Y && xe.hasTextData(), As = n.layout.get("icon-text-fit") !== "none" && ho && xe.hasIconData();
            if (W) {
              const Fi = h.style.map.terrain ? (Yr, Bi) => h.style.map.terrain.getElevation(ge, Yr, Bi) : null, $i = n.layout.get("text-rotation-alignment") === "map";
              vi(xe, h, c, wr, cn, q, M, $i, ge.toUnwrapped(), G.width, G.height, Jn, Fi);
            }
            const ks = c && Y || As, Ar = W || ks ? wd : q ? wr : h.transform.clipSpaceToPixelsMatrix, un = Ie && n.paint.get(c ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Tr;
            Tr = Ie ? xe.iconsInText ? md(et.kind, ri, J, q, W, ks, h, Ar, Yn, Jn, gi, Li, be) : xu(et.kind, ri, J, q, W, ks, h, Ar, Yn, Jn, c, gi, 0, be) : jo(et.kind, ri, J, q, W, ks, h, Ar, Yn, Jn, c, gi, be);
            const Qn = { program: Kt, buffers: Le, uniformValues: Tr, projectionData: uo, atlasTexture: bi, atlasTextureIcon: Ni, atlasInterpolation: Pt, atlasInterpolationIcon: ni, isSDF: Ie, hasHalo: un };
            if (K && xe.canOverlap) {
              te = !0;
              const Fi = Le.segments.get();
              for (const $i of Fi) pe.push({ segments: new a.aM([$i]), sortKey: $i.sortKey, state: Qn, terrainData: ei });
            } else pe.push({ segments: Le.segments, sortKey: 0, state: Qn, terrainData: ei });
          }
          te && pe.sort((ge, _e) => ge.sortKey - _e.sortKey);
          for (const ge of pe) {
            const _e = ge.state;
            if (R.activeTexture.set(O.TEXTURE0), _e.atlasTexture.bind(_e.atlasInterpolation, O.CLAMP_TO_EDGE), _e.atlasTextureIcon && (R.activeTexture.set(O.TEXTURE1), _e.atlasTextureIcon && _e.atlasTextureIcon.bind(_e.atlasInterpolationIcon, O.CLAMP_TO_EDGE)), _e.isSDF) {
              const xe = _e.uniformValues;
              _e.hasHalo && (xe.u_is_halo = 1, Zo(_e.buffers, ge.segments, n, h, _e.program, se, C, k, xe, _e.projectionData, ge.terrainData)), xe.u_is_halo = 0;
            }
            Zo(_e.buffers, ge.segments, n, h, _e.program, se, C, k, _e.uniformValues, _e.projectionData, ge.terrainData);
          }
        }
        function Zo(h, e, n, o, c, d, g, v, x, M, C) {
          const k = o.context;
          c.draw(k, k.gl.TRIANGLES, d, g, v, ft.backCCW, x, C, M, n.id, h.layoutVertexBuffer, h.indexBuffer, e, n.paint, o.transform.zoom, h.programConfigurations.get(n.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer);
        }
        function sc(h, e, n, o, c) {
          const d = h.context, g = d.gl, v = qt.disabled, x = new hi([g.ONE, g.ONE], a.bf.transparent, [!0, !0, !0, !0]), M = e.getBucket(n);
          if (!M) return;
          const C = o.key;
          let k = n.heatmapFbos.get(C);
          k || (k = Go(d, e.tileSize, e.tileSize), n.heatmapFbos.set(C, k)), d.bindFramebuffer.set(k.framebuffer), d.viewport.set([0, 0, e.tileSize, e.tileSize]), d.clear({ color: a.bf.transparent });
          const A = M.programConfigurations.get(n.id), R = h.useProgram("heatmap", A, !c), O = h.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), G = h.style.map.terrain.getTerrainData(o);
          R.draw(d, g.TRIANGLES, Tt.disabled, v, x, ft.disabled, mu(e, h.transform.zoom, n.paint.get("heatmap-intensity"), 1), G, O, n.id, M.layoutVertexBuffer, M.indexBuffer, M.segments, n.paint, h.transform.zoom, A);
        }
        function Du(h, e, n, o, c) {
          const d = h.context, g = d.gl, v = h.transform;
          d.setColorMode(h.colorModeForRenderPass());
          const x = qo(d, e), M = n.key, C = e.heatmapFbos.get(M);
          if (!C) return;
          d.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, C.colorAttachment.get()), d.activeTexture.set(g.TEXTURE1), x.bind(g.LINEAR, g.CLAMP_TO_EDGE);
          const k = v.getProjectionData({ overscaledTileID: n, applyTerrainMatrix: c, applyGlobeMatrix: !o });
          h.useProgram("heatmapTexture").draw(d, g.TRIANGLES, Tt.disabled, qt.disabled, h.colorModeForRenderPass(), ft.disabled, Gl(h, e, 0, 1), null, k, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, v.zoom), C.destroy(), e.heatmapFbos.delete(M);
        }
        function Go(h, e, n) {
          var o, c;
          const d = h.gl, g = d.createTexture();
          d.bindTexture(d.TEXTURE_2D, g), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR);
          const v = (o = h.HALF_FLOAT) !== null && o !== void 0 ? o : d.UNSIGNED_BYTE, x = (c = h.RGBA16F) !== null && c !== void 0 ? c : d.RGBA;
          d.texImage2D(d.TEXTURE_2D, 0, x, e, n, 0, d.RGBA, v, null);
          const M = h.createFramebuffer(e, n, !1, !1);
          return M.colorAttachment.set(g), M;
        }
        function qo(h, e) {
          return e.colorRampTexture || (e.colorRampTexture = new a.T(h, e.colorRamp, h.gl.RGBA)), e.colorRampTexture;
        }
        function Ho(h, e, n, o, c) {
          if (!n || !o || !o.imageAtlas) return;
          const d = o.imageAtlas.patternPositions;
          let g = d[n.to.toString()], v = d[n.from.toString()];
          if (!g && v && (g = v), !v && g && (v = g), !g || !v) {
            const x = c.getPaintProperty(e);
            g = d[x], v = d[x];
          }
          g && v && h.setConstantPatternPositions(g, v);
        }
        function $a(h, e, n, o, c, d, g, v) {
          const x = h.context.gl, M = "fill-pattern", C = n.paint.get(M), k = C && C.constantOr(1), A = n.getCrossfadeParameters();
          let R, O, G, Z, q;
          const W = h.transform, J = n.paint.get("fill-translate"), K = n.paint.get("fill-translate-anchor");
          g ? (O = k && !n.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", R = x.LINES) : (O = k ? "fillPattern" : "fill", R = x.TRIANGLES);
          const te = C.constantOr(null);
          for (const se of o) {
            const Y = e.getTile(se);
            if (k && !Y.patternsLoaded()) continue;
            const pe = Y.getBucket(n);
            if (!pe) continue;
            const be = pe.programConfigurations.get(n.id), ge = h.useProgram(O, be), _e = h.style.map.terrain && h.style.map.terrain.getTerrainData(se);
            k && (h.context.activeTexture.set(x.TEXTURE0), Y.imageAtlasTexture.bind(x.LINEAR, x.CLAMP_TO_EDGE), be.updatePaintBuffers(A)), Ho(be, M, te, Y, n);
            const xe = W.getProjectionData({ overscaledTileID: se, applyGlobeMatrix: !v, applyTerrainMatrix: !0 }), Le = a.aD(W, Y, J, K);
            if (g) {
              Z = pe.indexBuffer2, q = pe.segments2;
              const Ie = [x.drawingBufferWidth, x.drawingBufferHeight];
              G = O === "fillOutlinePattern" && k ? Bo(h, A, Y, Ie, Le) : Fo(Ie, Le);
            } else Z = pe.indexBuffer, q = pe.segments, G = k ? ka(h, A, Y, Le) : { u_fill_translate: Le };
            const Oe = h.stencilModeForClipping(se);
            ge.draw(h.context, R, c, Oe, d, ft.backCCW, G, _e, xe, n.id, pe.layoutVertexBuffer, Z, q, n.paint, h.transform.zoom, be);
          }
        }
        function oc(h, e, n, o, c, d, g, v) {
          const x = h.context, M = x.gl, C = "fill-extrusion-pattern", k = n.paint.get(C), A = k.constantOr(1), R = n.getCrossfadeParameters(), O = n.paint.get("fill-extrusion-opacity"), G = k.constantOr(null), Z = h.transform;
          for (const q of o) {
            const W = e.getTile(q), J = W.getBucket(n);
            if (!J) continue;
            const K = h.style.map.terrain && h.style.map.terrain.getTerrainData(q), te = J.programConfigurations.get(n.id), se = h.useProgram(A ? "fillExtrusionPattern" : "fillExtrusion", te);
            A && (h.context.activeTexture.set(M.TEXTURE0), W.imageAtlasTexture.bind(M.LINEAR, M.CLAMP_TO_EDGE), te.updatePaintBuffers(R));
            const Y = Z.getProjectionData({ overscaledTileID: q, applyGlobeMatrix: !v, applyTerrainMatrix: !0 });
            Ho(te, C, G, W, n);
            const pe = a.aD(Z, W, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor")), be = n.paint.get("fill-extrusion-vertical-gradient"), ge = A ? ud(h, be, O, pe, q, R, W) : rn(h, be, O, pe);
            se.draw(x, x.gl.TRIANGLES, c, d, g, ft.backCCW, ge, K, Y, n.id, J.layoutVertexBuffer, J.indexBuffer, J.segments, n.paint, h.transform.zoom, te, h.style.map.terrain && J.centroidVertexBuffer);
          }
        }
        function Ss(h, e, n, o, c, d, g, v, x) {
          var M;
          const C = h.style.projection, k = h.context, A = h.transform, R = k.gl, O = [`#define NUM_ILLUMINATION_SOURCES ${n.paint.get("hillshade-highlight-color").values.length}`], G = h.useProgram("hillshade", null, !1, O), Z = !h.options.moving;
          for (const q of o) {
            const W = e.getTile(q), J = W.fbo;
            if (!J) continue;
            const K = C.getMeshFromTileID(k, q.canonical, v, !0, "raster"), te = (M = h.style.map.terrain) === null || M === void 0 ? void 0 : M.getTerrainData(q);
            k.activeTexture.set(R.TEXTURE0), R.bindTexture(R.TEXTURE_2D, J.colorAttachment.get());
            const se = A.getProjectionData({ overscaledTileID: q, aligned: Z, applyGlobeMatrix: !x, applyTerrainMatrix: !0 });
            G.draw(k, R.TRIANGLES, d, c[q.overscaledZ], g, ft.backCCW, pd(h, W, n), te, se, n.id, K.vertexBuffer, K.indexBuffer, K.segments);
          }
        }
        function ac(h, e, n, o, c, d, g, v, x) {
          var M;
          const C = h.style.projection, k = h.context, A = h.transform, R = k.gl, O = h.useProgram("colorRelief"), G = !h.options.moving;
          let Z = !0, q = 0;
          for (const W of o) {
            const J = e.getTile(W), K = J.dem;
            if (Z) {
              const ge = R.getParameter(R.MAX_TEXTURE_SIZE), { elevationTexture: _e, colorTexture: xe } = n.getColorRampTextures(k, ge, K.getUnpackVector());
              k.activeTexture.set(R.TEXTURE1), _e.bind(R.NEAREST, R.CLAMP_TO_EDGE), k.activeTexture.set(R.TEXTURE4), xe.bind(R.LINEAR, R.CLAMP_TO_EDGE), Z = !1, q = _e.size[0];
            }
            if (!K || !K.data) continue;
            const te = K.stride, se = K.getPixels();
            if (k.activeTexture.set(R.TEXTURE0), k.pixelStoreUnpackPremultiplyAlpha.set(!1), J.demTexture = J.demTexture || h.getTileTexture(te), J.demTexture) {
              const ge = J.demTexture;
              ge.update(se, { premultiply: !1 }), ge.bind(R.LINEAR, R.CLAMP_TO_EDGE);
            } else J.demTexture = new a.T(k, se, R.RGBA, { premultiply: !1 }), J.demTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE);
            const Y = C.getMeshFromTileID(k, W.canonical, v, !0, "raster"), pe = (M = h.style.map.terrain) === null || M === void 0 ? void 0 : M.getTerrainData(W), be = A.getProjectionData({ overscaledTileID: W, aligned: G, applyGlobeMatrix: !x, applyTerrainMatrix: !0 });
            O.draw(k, R.TRIANGLES, d, c[W.overscaledZ], g, ft.backCCW, _u(n, J.dem, q), pe, be, n.id, Y.vertexBuffer, Y.indexBuffer, Y.segments);
          }
        }
        const Ua = [new a.P(0, 0), new a.P(a.$, 0), new a.P(a.$, a.$), new a.P(0, a.$)];
        function Ps(h, e, n, o, c, d, g, v, x = !1, M = !1) {
          const C = o[o.length - 1].overscaledZ, k = h.context, A = k.gl, R = h.useProgram("raster"), O = h.transform, G = h.style.projection, Z = h.colorModeForRenderPass(), q = !h.options.moving;
          for (const W of o) {
            const J = h.getDepthModeForSublayer(W.overscaledZ - C, n.paint.get("raster-opacity") === 1 ? Tt.ReadWrite : Tt.ReadOnly, A.LESS), K = e.getTile(W);
            K.registerFadeDuration(n.paint.get("raster-fade-duration"));
            const te = e.findLoadedParent(W, 0), se = e.findLoadedSibling(W), Y = lc(K, te || se || null, e, n, h.transform, h.style.map.terrain);
            let pe, be;
            const ge = n.paint.get("raster-resampling") === "nearest" ? A.NEAREST : A.LINEAR;
            k.activeTexture.set(A.TEXTURE0), K.texture.bind(ge, A.CLAMP_TO_EDGE, A.LINEAR_MIPMAP_NEAREST), k.activeTexture.set(A.TEXTURE1), te ? (te.texture.bind(ge, A.CLAMP_TO_EDGE, A.LINEAR_MIPMAP_NEAREST), pe = Math.pow(2, te.tileID.overscaledZ - K.tileID.overscaledZ), be = [K.tileID.canonical.x * pe % 1, K.tileID.canonical.y * pe % 1]) : K.texture.bind(ge, A.CLAMP_TO_EDGE, A.LINEAR_MIPMAP_NEAREST), K.texture.useMipmap && k.extTextureFilterAnisotropic && h.transform.pitch > 20 && A.texParameterf(A.TEXTURE_2D, k.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, k.extTextureFilterAnisotropicMax);
            const _e = h.style.map.terrain && h.style.map.terrain.getTerrainData(W), xe = O.getProjectionData({ overscaledTileID: W, aligned: q, applyGlobeMatrix: !M, applyTerrainMatrix: !0 }), Le = Oo(be || [0, 0], pe || 1, Y, n, v), Oe = G.getMeshFromTileID(k, W.canonical, d, g, "raster");
            R.draw(k, A.TRIANGLES, J, c ? c[W.overscaledZ] : qt.disabled, Z, x ? ft.frontCCW : ft.backCCW, Le, _e, xe, n.id, Oe.vertexBuffer, Oe.indexBuffer, Oe.segments);
          }
        }
        function lc(h, e, n, o, c, d) {
          const g = o.paint.get("raster-fade-duration");
          if (!d && g > 0) {
            const v = we.now(), x = (v - h.timeAdded) / g, M = e ? (v - e.timeAdded) / g : -1, C = n.getSource(), k = rt(c, { tileSize: C.tileSize, roundZoom: C.roundZoom }), A = !e || Math.abs(e.tileID.overscaledZ - k) > Math.abs(h.tileID.overscaledZ - k), R = A && h.refreshedUponExpiration ? 1 : a.ah(A ? x : 1 - M, 0, 1);
            return h.refreshedUponExpiration && x >= 1 && (h.refreshedUponExpiration = !1), e ? { opacity: 1, mix: 1 - R } : { opacity: R, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const Lu = new a.bf(1, 0, 0, 1), Fu = new a.bf(0, 1, 0, 1), Za = new a.bf(0, 0, 1, 1), cc = new a.bf(1, 0, 1, 1), Sd = new a.bf(0, 1, 1, 1);
        function uc(h, e, n, o) {
          Sn(h, 0, e + n / 2, h.transform.width, n, o);
        }
        function xi(h, e, n, o) {
          Sn(h, e - n / 2, 0, n, h.transform.height, o);
        }
        function Sn(h, e, n, o, c, d) {
          const g = h.context, v = g.gl;
          v.enable(v.SCISSOR_TEST), v.scissor(e * h.pixelRatio, n * h.pixelRatio, o * h.pixelRatio, c * h.pixelRatio), g.clear({ color: d }), v.disable(v.SCISSOR_TEST);
        }
        function Xr(h, e, n) {
          const o = h.context, c = o.gl, d = h.useProgram("debug"), g = Tt.disabled, v = qt.disabled, x = h.colorModeForRenderPass(), M = "$debug", C = h.style.map.terrain && h.style.map.terrain.getTerrainData(n);
          o.activeTexture.set(c.TEXTURE0);
          const k = e.getTileByID(n.key).latestRawTileData, A = Math.floor((k && k.byteLength || 0) / 1024), R = e.getTile(n).tileSize, O = 512 / Math.min(R, 512) * (n.overscaledZ / h.transform.zoom) * 0.5;
          let G = n.canonical.toString();
          n.overscaledZ !== n.canonical.z && (G += ` => ${n.overscaledZ}`), function(q, W) {
            q.initDebugOverlayCanvas();
            const J = q.debugOverlayCanvas, K = q.context.gl, te = q.debugOverlayCanvas.getContext("2d");
            te.clearRect(0, 0, J.width, J.height), te.shadowColor = "white", te.shadowBlur = 2, te.lineWidth = 1.5, te.strokeStyle = "white", te.textBaseline = "top", te.font = "bold 36px Open Sans, sans-serif", te.fillText(W, 5, 5), te.strokeText(W, 5, 5), q.debugOverlayTexture.update(J), q.debugOverlayTexture.bind(K.LINEAR, K.CLAMP_TO_EDGE);
          }(h, `${G} ${A}kB`);
          const Z = h.transform.getProjectionData({ overscaledTileID: n, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
          d.draw(o, c.TRIANGLES, g, v, hi.alphaBlended, ft.disabled, vs(a.bf.transparent, O), null, Z, M, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments), d.draw(o, c.LINE_STRIP, g, v, x, ft.disabled, vs(a.bf.red), C, Z, M, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments);
        }
        function Ga(h, e, n, o) {
          const { isRenderingGlobe: c } = o, d = h.context, g = d.gl, v = h.transform, x = h.colorModeForRenderPass(), M = h.getDepthModeFor3D(), C = h.useProgram("terrain");
          d.bindFramebuffer.set(null), d.viewport.set([0, 0, h.width, h.height]);
          for (const k of n) {
            const A = e.getTerrainMesh(k.tileID), R = h.renderToTexture.getTexture(k), O = e.getTerrainData(k.tileID);
            d.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, R.texture);
            const G = e.getMeshFrameDelta(v.zoom), Z = v.calculateFogMatrix(k.tileID.toUnwrapped()), q = Ea(G, Z, h.style.sky, v.pitch, c), W = v.getProjectionData({ overscaledTileID: k.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
            C.draw(d, g.TRIANGLES, M, qt.disabled, x, ft.backCCW, q, O, W, "terrain", A.vertexBuffer, A.indexBuffer, A.segments);
          }
        }
        function Wo(h, e) {
          if (!e.mesh) {
            const n = new a.aL();
            n.emplaceBack(-1, -1), n.emplaceBack(1, -1), n.emplaceBack(1, 1), n.emplaceBack(-1, 1);
            const o = new a.aN();
            o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), e.mesh = new ps(h.createVertexBuffer(n, Hn.members), h.createIndexBuffer(o), a.aM.simpleSegment(0, 0, n.length, o.length));
          }
          return e.mesh;
        }
        class Bu {
          constructor(e, n) {
            this.context = new ku(e), this.transform = n, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: a.ag(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Dt.maxUnderzooming + Dt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Hs();
          }
          resize(e, n, o) {
            if (this.width = Math.floor(e * o), this.height = Math.floor(n * o), this.pixelRatio = o, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const c of this.style._order) this.style._layers[c].resize();
          }
          setup() {
            const e = this.context, n = new a.aL();
            n.emplaceBack(0, 0), n.emplaceBack(a.$, 0), n.emplaceBack(0, a.$), n.emplaceBack(a.$, a.$), this.tileExtentBuffer = e.createVertexBuffer(n, Hn.members), this.tileExtentSegments = a.aM.simpleSegment(0, 0, 4, 2);
            const o = new a.aL();
            o.emplaceBack(0, 0), o.emplaceBack(a.$, 0), o.emplaceBack(0, a.$), o.emplaceBack(a.$, a.$), this.debugBuffer = e.createVertexBuffer(o, Hn.members), this.debugSegments = a.aM.simpleSegment(0, 0, 4, 5);
            const c = new a.c6();
            c.emplaceBack(0, 0, 0, 0), c.emplaceBack(a.$, 0, a.$, 0), c.emplaceBack(0, a.$, 0, a.$), c.emplaceBack(a.$, a.$, a.$, a.$), this.rasterBoundsBuffer = e.createVertexBuffer(c, ld.members), this.rasterBoundsSegments = a.aM.simpleSegment(0, 0, 4, 2);
            const d = new a.aL();
            d.emplaceBack(0, 0), d.emplaceBack(a.$, 0), d.emplaceBack(0, a.$), d.emplaceBack(a.$, a.$), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(d, Hn.members), this.rasterBoundsSegmentsPosOnly = a.aM.simpleSegment(0, 0, 4, 5);
            const g = new a.aL();
            g.emplaceBack(0, 0), g.emplaceBack(1, 0), g.emplaceBack(0, 1), g.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(g, Hn.members), this.viewportSegments = a.aM.simpleSegment(0, 0, 4, 2);
            const v = new a.c7();
            v.emplaceBack(0), v.emplaceBack(1), v.emplaceBack(3), v.emplaceBack(2), v.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(v);
            const x = new a.aN();
            x.emplaceBack(1, 0, 2), x.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(x);
            const M = this.context.gl;
            this.stencilClearMode = new qt({ func: M.ALWAYS, mask: 0 }, 0, 255, M.ZERO, M.ZERO, M.ZERO), this.tileExtentMesh = new ps(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const e = this.context, n = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const o = a.L();
            a.bY(o, 0, this.width, this.height, 0, 0, 1), a.N(o, o, [n.drawingBufferWidth, n.drawingBufferHeight, 0]);
            const c = { mainMatrix: o, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: o };
            this.useProgram("clippingMask", null, !0).draw(e, n.TRIANGLES, Tt.disabled, this.stencilClearMode, hi.disabled, ft.disabled, null, null, c, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e, n, o) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !n || !n.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + n.length > 256 && this.clearStencil();
            const c = this.context;
            c.setColorMode(hi.disabled), c.setDepthMode(Tt.disabled);
            const d = {};
            for (const g of n) d[g.key] = this.nextStencilID++;
            this._renderTileMasks(d, n, o, !0), this._renderTileMasks(d, n, o, !1), this._tileClippingMaskIDs = d;
          }
          _renderTileMasks(e, n, o, c) {
            const d = this.context, g = d.gl, v = this.style.projection, x = this.transform, M = this.useProgram("clippingMask");
            for (const C of n) {
              const k = e[C.key], A = this.style.map.terrain && this.style.map.terrain.getTerrainData(C), R = v.getMeshFromTileID(this.context, C.canonical, c, !0, "stencil"), O = x.getProjectionData({ overscaledTileID: C, applyGlobeMatrix: !o, applyTerrainMatrix: !0 });
              M.draw(d, g.TRIANGLES, Tt.disabled, new qt({ func: g.ALWAYS, mask: 0 }, k, 255, g.KEEP, g.KEEP, g.REPLACE), hi.disabled, o ? ft.disabled : ft.backCCW, null, A, O, "$clipping", R.vertexBuffer, R.indexBuffer, R.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context, n = e.gl, o = this.style.projection, c = this.transform, d = this.useProgram("depth"), g = this.getDepthModeFor3D(), v = fe(c, { tileSize: c.tileSize });
            for (const x of v) {
              const M = this.style.map.terrain && this.style.map.terrain.getTerrainData(x), C = o.getMeshFromTileID(this.context, x.canonical, !0, !0, "raster"), k = c.getProjectionData({ overscaledTileID: x, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              d.draw(e, n.TRIANGLES, g, qt.disabled, hi.disabled, ft.backCCW, null, M, k, "$clipping", C.vertexBuffer, C.indexBuffer, C.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++, n = this.context.gl;
            return new qt({ func: n.NOTEQUAL, mask: 255 }, e, 255, n.KEEP, n.KEEP, n.REPLACE);
          }
          stencilModeForClipping(e) {
            const n = this.context.gl;
            return new qt({ func: n.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, n.KEEP, n.KEEP, n.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const n = this.context.gl, o = e.sort((g, v) => v.overscaledZ - g.overscaledZ), c = o[o.length - 1].overscaledZ, d = o[0].overscaledZ - c + 1;
            if (d > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + d > 256 && this.clearStencil();
              const g = {};
              for (let v = 0; v < d; v++) g[v + c] = new qt({ func: n.GEQUAL, mask: 255 }, v + this.nextStencilID, 255, n.KEEP, n.KEEP, n.REPLACE);
              return this.nextStencilID += d, [g, o];
            }
            return [{ [c]: qt.disabled }, o];
          }
          stencilConfigForOverlapTwoPass(e) {
            const n = this.context.gl, o = e.sort((g, v) => v.overscaledZ - g.overscaledZ), c = o[o.length - 1].overscaledZ, d = o[0].overscaledZ - c + 1;
            if (this.clearStencil(), d > 1) {
              const g = {}, v = {};
              for (let x = 0; x < d; x++) g[x + c] = new qt({ func: n.GREATER, mask: 255 }, d + 1 + x, 255, n.KEEP, n.KEEP, n.REPLACE), v[x + c] = new qt({ func: n.GREATER, mask: 255 }, 1 + x, 255, n.KEEP, n.KEEP, n.REPLACE);
              return this.nextStencilID = 2 * d + 1, [g, v, o];
            }
            return this.nextStencilID = 3, [{ [c]: new qt({ func: n.GREATER, mask: 255 }, 2, 255, n.KEEP, n.KEEP, n.REPLACE) }, { [c]: new qt({ func: n.GREATER, mask: 255 }, 1, 255, n.KEEP, n.KEEP, n.REPLACE) }, o];
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new hi([e.CONSTANT_COLOR, e.ONE], new a.bf(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? hi.unblended : hi.alphaBlended;
          }
          getDepthModeForSublayer(e, n, o) {
            if (!this.opaquePassEnabledForLayer()) return Tt.disabled;
            const c = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new Tt(o || this.context.gl.LEQUAL, n, [c, c]);
          }
          getDepthModeFor3D() {
            return new Tt(this.context.gl.LEQUAL, Tt.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e, n) {
            var o, c;
            this.style = e, this.options = n, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(we.now()), this.imageManager.beginFrame();
            const d = this.style._order, g = this.style.sourceCaches, v = {}, x = {}, M = {}, C = { isRenderingToTexture: !1, isRenderingGlobe: ((o = e.projection) === null || o === void 0 ? void 0 : o.transitionState) > 0 };
            for (const A in g) {
              const R = g[A];
              R.used && R.prepare(this.context), v[A] = R.getVisibleCoordinates(!1), x[A] = v[A].slice().reverse(), M[A] = R.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let A = 0; A < d.length; A++) if (this.style._layers[d[A]].is3D()) {
              this.opaquePassCutoff = A;
              break;
            }
            this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const A of d) {
              const R = this.style._layers[A];
              if (!R.hasOffscreenPass() || R.isHidden(this.transform.zoom)) continue;
              const O = x[R.source];
              (R.type === "custom" || O.length) && this.renderLayer(this, g[R.source], R, O, C);
            }
            if ((c = this.style.projection) === null || c === void 0 || c.updateGPUdependent({ context: this.context, useProgram: (A) => this.useProgram(A) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: n.showOverdrawInspector ? a.bf.black : a.bf.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(A, R) {
              const O = A.context, G = O.gl, Z = ((se, Y, pe) => {
                const be = Math.cos(Y.rollInRadians), ge = Math.sin(Y.rollInRadians), _e = ie(Y), xe = Y.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
                return { u_sky_color: se.properties.get("sky-color"), u_horizon_color: se.properties.get("horizon-color"), u_horizon: [(Y.width / 2 - _e * ge) * pe, (Y.height / 2 + _e * be) * pe], u_horizon_normal: [-ge, be], u_sky_horizon_blend: se.properties.get("sky-horizon-blend") * Y.height / 2 * pe, u_sky_blend: xe };
              })(R, A.style.map.transform, A.pixelRatio), q = new Tt(G.LEQUAL, Tt.ReadWrite, [0, 1]), W = qt.disabled, J = A.colorModeForRenderPass(), K = A.useProgram("sky"), te = Wo(O, R);
              K.draw(O, G.TRIANGLES, q, W, J, ft.disabled, Z, null, void 0, "sky", te.vertexBuffer, te.indexBuffer, te.segments);
            }(this, this.style.sky), this._showOverdrawInspector = n.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const A = this.style._layers[d[this.currentLayer]], R = g[A.source], O = v[A.source];
              this._renderTileClippingMasks(A, O, !1), this.renderLayer(this, R, A, O, C);
            }
            this.renderPass = "translucent";
            let k = !1;
            for (this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
              const A = this.style._layers[d[this.currentLayer]], R = g[A.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(A, C)) continue;
              this.opaquePassEnabledForLayer() || k || (k = !0, C.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const O = (A.type === "symbol" ? M : x)[A.source];
              this._renderTileClippingMasks(A, v[A.source], !!this.renderToTexture), this.renderLayer(this, R, A, O, C);
            }
            if (C.isRenderingGlobe && function(A, R, O) {
              const G = A.context, Z = G.gl, q = A.useProgram("atmosphere"), W = new Tt(Z.LEQUAL, Tt.ReadOnly, [0, 1]), J = A.transform, K = function(xe, Le) {
                const Oe = xe.properties.get("position"), Ie = [-Oe.x, -Oe.y, -Oe.z], et = a.ag(new Float64Array(16));
                return xe.properties.get("anchor") === "map" && (a.b6(et, et, Le.rollInRadians), a.b7(et, et, -Le.pitchInRadians), a.b6(et, et, Le.bearingInRadians), a.b7(et, et, Le.center.lat * Math.PI / 180), a.bz(et, et, -Le.center.lng * Math.PI / 180)), a.c5(Ie, Ie, et), Ie;
              }(O, A.transform), te = J.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), se = R.properties.get("atmosphere-blend") * te.projectionTransition;
              if (se === 0) return;
              const Y = Xs(J.worldSize, J.center.lat), pe = J.inverseProjectionMatrix, be = new Float64Array(4);
              be[3] = 1, a.aw(be, be, J.modelViewProjectionMatrix), be[0] /= be[3], be[1] /= be[3], be[2] /= be[3], be[3] = 1, a.aw(be, be, pe), be[0] /= be[3], be[1] /= be[3], be[2] /= be[3], be[3] = 1;
              const ge = /* @__PURE__ */ ((xe, Le, Oe, Ie, et) => ({ u_sun_pos: xe, u_atmosphere_blend: Le, u_globe_position: Oe, u_globe_radius: Ie, u_inv_proj_matrix: et }))(K, se, [be[0], be[1], be[2]], Y, pe), _e = Wo(G, R);
              q.draw(G, Z.TRIANGLES, W, qt.disabled, hi.alphaBlended, ft.disabled, ge, null, null, "atmosphere", _e.vertexBuffer, _e.indexBuffer, _e.segments);
            }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const A = function(R, O) {
                let G = null;
                const Z = Object.values(R._layers).flatMap((K) => K.source && !K.isHidden(O) ? [R.sourceCaches[K.source]] : []), q = Z.filter((K) => K.getSource().type === "vector"), W = Z.filter((K) => K.getSource().type !== "vector"), J = (K) => {
                  (!G || G.getSource().maxzoom < K.getSource().maxzoom) && (G = K);
                };
                return q.forEach((K) => J(K)), G || W.forEach((K) => J(K)), G;
              }(this.style, this.transform.zoom);
              A && function(R, O, G) {
                for (let Z = 0; Z < G.length; Z++) Xr(R, O, G[Z]);
              }(this, A, A.getVisibleCoordinates());
            }
            this.options.showPadding && function(A) {
              const R = A.transform.padding;
              uc(A, A.transform.height - (R.top || 0), 3, Lu), uc(A, R.bottom || 0, 3, Fu), xi(A, R.left || 0, 3, Za), xi(A, A.transform.width - (R.right || 0), 3, cc);
              const O = A.transform.centerPoint;
              (function(G, Z, q, W) {
                Sn(G, Z - 1, q - 10, 2, 20, W), Sn(G, Z - 10, q - 1, 20, 2, W);
              })(A, O.x, A.transform.height - O.y, Sd);
            }(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const n = this.terrainFacilitator.matrix, o = this.transform.modelViewProjectionMatrix;
            let c = this.terrainFacilitator.dirty;
            c || (c = e ? !a.c8(n, o) : !a.c9(n, o)), c || (c = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), c && (a.ca(n, o), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(d, g) {
              const v = d.context, x = v.gl, M = d.transform, C = hi.unblended, k = new Tt(x.LEQUAL, Tt.ReadWrite, [0, 1]), A = g.sourceCache.getRenderableTiles(), R = d.useProgram("terrainDepth");
              v.bindFramebuffer.set(g.getFramebuffer("depth").framebuffer), v.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), v.clear({ color: a.bf.transparent, depth: 1 });
              for (const O of A) {
                const G = g.getTerrainMesh(O.tileID), Z = g.getTerrainData(O.tileID), q = M.getProjectionData({ overscaledTileID: O.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), W = { u_ele_delta: g.getMeshFrameDelta(M.zoom) };
                R.draw(v, x.TRIANGLES, k, qt.disabled, C, ft.backCCW, W, Z, q, "terrain", G.vertexBuffer, G.indexBuffer, G.segments);
              }
              v.bindFramebuffer.set(null), v.viewport.set([0, 0, d.width, d.height]);
            }(this, this.style.map.terrain), function(d, g) {
              const v = d.context, x = v.gl, M = d.transform, C = hi.unblended, k = new Tt(x.LEQUAL, Tt.ReadWrite, [0, 1]), A = g.getCoordsTexture(), R = g.sourceCache.getRenderableTiles(), O = d.useProgram("terrainCoords");
              v.bindFramebuffer.set(g.getFramebuffer("coords").framebuffer), v.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), v.clear({ color: a.bf.transparent, depth: 1 }), g.coordsIndex = [];
              for (const G of R) {
                const Z = g.getTerrainMesh(G.tileID), q = g.getTerrainData(G.tileID);
                v.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, A.texture);
                const W = { u_terrain_coords_id: (255 - g.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: g.getMeshFrameDelta(M.zoom) }, J = M.getProjectionData({ overscaledTileID: G.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                O.draw(v, x.TRIANGLES, k, qt.disabled, C, ft.backCCW, W, q, J, "terrain", Z.vertexBuffer, Z.indexBuffer, Z.segments), g.coordsIndex.push(G.tileID.key);
              }
              v.bindFramebuffer.set(null), v.viewport.set([0, 0, d.width, d.height]);
            }(this, this.style.map.terrain));
          }
          renderLayer(e, n, o, c, d) {
            o.isHidden(this.transform.zoom) || (o.type === "background" || o.type === "custom" || (c || []).length) && (this.id = o.id, a.cb(o) ? function(g, v, x, M, C, k) {
              if (g.renderPass !== "translucent") return;
              const { isRenderingToTexture: A } = k, R = qt.disabled, O = g.colorModeForRenderPass();
              (x._unevaluatedLayout.hasValue("text-variable-anchor") || x._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(G, Z, q, W, J, K, te, se, Y) {
                const pe = Z.transform, be = Z.style.map.terrain, ge = J === "map", _e = K === "map";
                for (const xe of G) {
                  const Le = W.getTile(xe), Oe = Le.getBucket(q);
                  if (!Oe || !Oe.text || !Oe.text.segments.get().length) continue;
                  const Ie = a.an(Oe.textSizeData, pe.zoom), et = a.aC(Le, 1, Z.transform.zoom), Ct = Ci(ge, Z.transform, et), Kt = q.layout.get("icon-text-fit") !== "none" && Oe.hasIconData();
                  if (Ie) {
                    const ri = Math.pow(2, pe.zoom - Le.tileID.overscaledZ), ei = be ? (gi, bi) => be.getElevation(xe, gi, bi) : null;
                    nc(Oe, ge, _e, Y, pe, Ct, ri, Ie, Kt, a.aD(pe, Le, te, se), xe.toUnwrapped(), ei);
                  }
                }
              }(M, g, x, v, x.layout.get("text-rotation-alignment"), x.layout.get("text-pitch-alignment"), x.paint.get("text-translate"), x.paint.get("text-translate-anchor"), C), x.paint.get("icon-opacity").constantOr(1) !== 0 && Uo(g, v, x, M, !1, x.paint.get("icon-translate"), x.paint.get("icon-translate-anchor"), x.layout.get("icon-rotation-alignment"), x.layout.get("icon-pitch-alignment"), x.layout.get("icon-keep-upright"), R, O, A), x.paint.get("text-opacity").constantOr(1) !== 0 && Uo(g, v, x, M, !0, x.paint.get("text-translate"), x.paint.get("text-translate-anchor"), x.layout.get("text-rotation-alignment"), x.layout.get("text-pitch-alignment"), x.layout.get("text-keep-upright"), R, O, A), v.map.showCollisionBoxes && (zu(g, v, x, M, !0), zu(g, v, x, M, !1));
            }(e, n, o, c, this.style.placement.variableOffsets, d) : a.cc(o) ? function(g, v, x, M, C) {
              if (g.renderPass !== "translucent") return;
              const { isRenderingToTexture: k } = C, A = x.paint.get("circle-opacity"), R = x.paint.get("circle-stroke-width"), O = x.paint.get("circle-stroke-opacity"), G = !x.layout.get("circle-sort-key").isConstant();
              if (A.constantOr(1) === 0 && (R.constantOr(1) === 0 || O.constantOr(1) === 0)) return;
              const Z = g.context, q = Z.gl, W = g.transform, J = g.getDepthModeForSublayer(0, Tt.ReadOnly), K = qt.disabled, te = g.colorModeForRenderPass(), se = [], Y = W.getCircleRadiusCorrection();
              for (let pe = 0; pe < M.length; pe++) {
                const be = M[pe], ge = v.getTile(be), _e = ge.getBucket(x);
                if (!_e) continue;
                const xe = x.paint.get("circle-translate"), Le = x.paint.get("circle-translate-anchor"), Oe = a.aD(W, ge, xe, Le), Ie = _e.programConfigurations.get(x.id), et = g.useProgram("circle", Ie), Ct = _e.layoutVertexBuffer, Kt = _e.indexBuffer, ri = g.style.map.terrain && g.style.map.terrain.getTerrainData(be), ei = { programConfiguration: Ie, program: et, layoutVertexBuffer: Ct, indexBuffer: Kt, uniformValues: hd(g, ge, x, Oe, Y), terrainData: ri, projectionData: W.getProjectionData({ overscaledTileID: be, applyGlobeMatrix: !k, applyTerrainMatrix: !0 }) };
                if (G) {
                  const gi = _e.segments.get();
                  for (const bi of gi) se.push({ segments: new a.aM([bi]), sortKey: bi.sortKey, state: ei });
                } else se.push({ segments: _e.segments, sortKey: 0, state: ei });
              }
              G && se.sort((pe, be) => pe.sortKey - be.sortKey);
              for (const pe of se) {
                const { programConfiguration: be, program: ge, layoutVertexBuffer: _e, indexBuffer: xe, uniformValues: Le, terrainData: Oe, projectionData: Ie } = pe.state;
                ge.draw(Z, q.TRIANGLES, J, K, te, ft.backCCW, Le, Oe, Ie, x.id, _e, xe, pe.segments, x.paint, g.transform.zoom, be);
              }
            }(e, n, o, c, d) : a.cd(o) ? function(g, v, x, M, C) {
              if (x.paint.get("heatmap-opacity") === 0) return;
              const k = g.context, { isRenderingToTexture: A, isRenderingGlobe: R } = C;
              if (g.style.map.terrain) {
                for (const O of M) {
                  const G = v.getTile(O);
                  v.hasRenderableParent(O) || (g.renderPass === "offscreen" ? sc(g, G, x, O, R) : g.renderPass === "translucent" && Du(g, x, O, A, R));
                }
                k.viewport.set([0, 0, g.width, g.height]);
              } else g.renderPass === "offscreen" ? function(O, G, Z, q) {
                const W = O.context, J = W.gl, K = O.transform, te = qt.disabled, se = new hi([J.ONE, J.ONE], a.bf.transparent, [!0, !0, !0, !0]);
                (function(Y, pe, be) {
                  const ge = Y.gl;
                  Y.activeTexture.set(ge.TEXTURE1), Y.viewport.set([0, 0, pe.width / 4, pe.height / 4]);
                  let _e = be.heatmapFbos.get(a.c2);
                  _e ? (ge.bindTexture(ge.TEXTURE_2D, _e.colorAttachment.get()), Y.bindFramebuffer.set(_e.framebuffer)) : (_e = Go(Y, pe.width / 4, pe.height / 4), be.heatmapFbos.set(a.c2, _e));
                })(W, O, Z), W.clear({ color: a.bf.transparent });
                for (let Y = 0; Y < q.length; Y++) {
                  const pe = q[Y];
                  if (G.hasRenderableParent(pe)) continue;
                  const be = G.getTile(pe), ge = be.getBucket(Z);
                  if (!ge) continue;
                  const _e = ge.programConfigurations.get(Z.id), xe = O.useProgram("heatmap", _e), Le = K.getProjectionData({ overscaledTileID: pe, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), Oe = K.getCircleRadiusCorrection();
                  xe.draw(W, J.TRIANGLES, Tt.disabled, te, se, ft.backCCW, mu(be, K.zoom, Z.paint.get("heatmap-intensity"), Oe), null, Le, Z.id, ge.layoutVertexBuffer, ge.indexBuffer, ge.segments, Z.paint, K.zoom, _e);
                }
                W.viewport.set([0, 0, O.width, O.height]);
              }(g, v, x, M) : g.renderPass === "translucent" && function(O, G) {
                const Z = O.context, q = Z.gl;
                Z.setColorMode(O.colorModeForRenderPass());
                const W = G.heatmapFbos.get(a.c2);
                W && (Z.activeTexture.set(q.TEXTURE0), q.bindTexture(q.TEXTURE_2D, W.colorAttachment.get()), Z.activeTexture.set(q.TEXTURE1), qo(Z, G).bind(q.LINEAR, q.CLAMP_TO_EDGE), O.useProgram("heatmapTexture").draw(Z, q.TRIANGLES, Tt.disabled, qt.disabled, O.colorModeForRenderPass(), ft.disabled, Gl(O, G, 0, 1), null, null, G.id, O.viewportBuffer, O.quadTriangleIndexBuffer, O.viewportSegments, G.paint, O.transform.zoom));
              }(g, x);
            }(e, n, o, c, d) : a.ce(o) ? function(g, v, x, M, C) {
              if (g.renderPass !== "translucent") return;
              const { isRenderingToTexture: k } = C, A = x.paint.get("line-opacity"), R = x.paint.get("line-width");
              if (A.constantOr(1) === 0 || R.constantOr(1) === 0) return;
              const O = g.getDepthModeForSublayer(0, Tt.ReadOnly), G = g.colorModeForRenderPass(), Z = x.paint.get("line-dasharray"), q = x.paint.get("line-pattern"), W = q.constantOr(1), J = x.paint.get("line-gradient"), K = x.getCrossfadeParameters(), te = W ? "linePattern" : Z ? "lineSDF" : J ? "lineGradient" : "line", se = g.context, Y = se.gl, pe = g.transform;
              let be = !0;
              for (const ge of M) {
                const _e = v.getTile(ge);
                if (W && !_e.patternsLoaded()) continue;
                const xe = _e.getBucket(x);
                if (!xe) continue;
                const Le = xe.programConfigurations.get(x.id), Oe = g.context.program.get(), Ie = g.useProgram(te, Le), et = be || Ie.program !== Oe, Ct = g.style.map.terrain && g.style.map.terrain.getTerrainData(ge), Kt = q.constantOr(null);
                if (Kt && _e.imageAtlas) {
                  const Pt = _e.imageAtlas, ni = Pt.patternPositions[Kt.to.toString()], Li = Pt.patternPositions[Kt.from.toString()];
                  ni && Li && Le.setConstantPatternPositions(ni, Li);
                }
                const ri = pe.getProjectionData({ overscaledTileID: ge, applyGlobeMatrix: !k, applyTerrainMatrix: !0 }), ei = pe.getPixelScale(), gi = W ? vu(g, _e, x, ei, K) : Z ? xs(g, _e, x, ei, Z, K) : J ? yu(g, _e, x, ei, xe.lineClipsArray.length) : Ra(g, _e, x, ei);
                if (W) se.activeTexture.set(Y.TEXTURE0), _e.imageAtlasTexture.bind(Y.LINEAR, Y.CLAMP_TO_EDGE), Le.updatePaintBuffers(K);
                else if (Z && (et || g.lineAtlas.dirty)) se.activeTexture.set(Y.TEXTURE0), g.lineAtlas.bind(se);
                else if (J) {
                  const Pt = xe.gradients[x.id];
                  let ni = Pt.texture;
                  if (x.gradientVersion !== Pt.version) {
                    let Li = 256;
                    if (x.stepInterpolant) {
                      const Ni = v.getSource().maxzoom, Wi = ge.canonical.z === Ni ? Math.ceil(1 << g.transform.maxZoom - ge.canonical.z) : 1;
                      Li = a.ah(a.c3(xe.maxLineLength / a.$ * 1024 * Wi), 256, se.maxTextureSize);
                    }
                    Pt.gradient = a.c4({ expression: x.gradientExpression(), evaluationKey: "lineProgress", resolution: Li, image: Pt.gradient || void 0, clips: xe.lineClipsArray }), Pt.texture ? Pt.texture.update(Pt.gradient) : Pt.texture = new a.T(se, Pt.gradient, Y.RGBA), Pt.version = x.gradientVersion, ni = Pt.texture;
                  }
                  se.activeTexture.set(Y.TEXTURE0), ni.bind(x.stepInterpolant ? Y.NEAREST : Y.LINEAR, Y.CLAMP_TO_EDGE);
                }
                const bi = g.stencilModeForClipping(ge);
                Ie.draw(se, Y.TRIANGLES, O, bi, G, ft.disabled, gi, Ct, ri, x.id, xe.layoutVertexBuffer, xe.indexBuffer, xe.segments, x.paint, g.transform.zoom, Le, xe.layoutVertexBuffer2), be = !1;
              }
            }(e, n, o, c, d) : a.cf(o) ? function(g, v, x, M, C) {
              const k = x.paint.get("fill-color"), A = x.paint.get("fill-opacity");
              if (A.constantOr(1) === 0) return;
              const { isRenderingToTexture: R } = C, O = g.colorModeForRenderPass(), G = x.paint.get("fill-pattern"), Z = g.opaquePassEnabledForLayer() && !G.constantOr(1) && k.constantOr(a.bf.transparent).a === 1 && A.constantOr(0) === 1 ? "opaque" : "translucent";
              if (g.renderPass === Z) {
                const q = g.getDepthModeForSublayer(1, g.renderPass === "opaque" ? Tt.ReadWrite : Tt.ReadOnly);
                $a(g, v, x, M, q, O, !1, R);
              }
              if (g.renderPass === "translucent" && x.paint.get("fill-antialias")) {
                const q = g.getDepthModeForSublayer(x.getPaintProperty("fill-outline-color") ? 2 : 0, Tt.ReadOnly);
                $a(g, v, x, M, q, O, !0, R);
              }
            }(e, n, o, c, d) : a.cg(o) ? function(g, v, x, M, C) {
              const k = x.paint.get("fill-extrusion-opacity");
              if (k === 0) return;
              const { isRenderingToTexture: A } = C;
              if (g.renderPass === "translucent") {
                const R = new Tt(g.context.gl.LEQUAL, Tt.ReadWrite, g.depthRangeFor3D);
                if (k !== 1 || x.paint.get("fill-extrusion-pattern").constantOr(1)) oc(g, v, x, M, R, qt.disabled, hi.disabled, A), oc(g, v, x, M, R, g.stencilModeFor3D(), g.colorModeForRenderPass(), A);
                else {
                  const O = g.colorModeForRenderPass();
                  oc(g, v, x, M, R, qt.disabled, O, A);
                }
              }
            }(e, n, o, c, d) : a.ch(o) ? function(g, v, x, M, C) {
              if (g.renderPass !== "offscreen" && g.renderPass !== "translucent") return;
              const { isRenderingToTexture: k } = C, A = g.context, R = g.style.projection.useSubdivision, O = g.getDepthModeForSublayer(0, Tt.ReadOnly), G = g.colorModeForRenderPass();
              if (g.renderPass === "offscreen") (function(Z, q, W, J, K, te, se) {
                const Y = Z.context, pe = Y.gl;
                for (const be of W) {
                  const ge = q.getTile(be), _e = ge.dem;
                  if (!_e || !_e.data || !ge.needsHillshadePrepare) continue;
                  const xe = _e.dim, Le = _e.stride, Oe = _e.getPixels();
                  if (Y.activeTexture.set(pe.TEXTURE1), Y.pixelStoreUnpackPremultiplyAlpha.set(!1), ge.demTexture = ge.demTexture || Z.getTileTexture(Le), ge.demTexture) {
                    const et = ge.demTexture;
                    et.update(Oe, { premultiply: !1 }), et.bind(pe.NEAREST, pe.CLAMP_TO_EDGE);
                  } else ge.demTexture = new a.T(Y, Oe, pe.RGBA, { premultiply: !1 }), ge.demTexture.bind(pe.NEAREST, pe.CLAMP_TO_EDGE);
                  Y.activeTexture.set(pe.TEXTURE0);
                  let Ie = ge.fbo;
                  if (!Ie) {
                    const et = new a.T(Y, { width: xe, height: xe, data: null }, pe.RGBA);
                    et.bind(pe.LINEAR, pe.CLAMP_TO_EDGE), Ie = ge.fbo = Y.createFramebuffer(xe, xe, !0, !1), Ie.colorAttachment.set(et.texture);
                  }
                  Y.bindFramebuffer.set(Ie.framebuffer), Y.viewport.set([0, 0, xe, xe]), Z.useProgram("hillshadePrepare").draw(Y, pe.TRIANGLES, K, te, se, ft.disabled, gu(ge.tileID, _e), null, null, J.id, Z.rasterBoundsBuffer, Z.quadTriangleIndexBuffer, Z.rasterBoundsSegments), ge.needsHillshadePrepare = !1;
                }
              })(g, v, M, x, O, qt.disabled, G), A.viewport.set([0, 0, g.width, g.height]);
              else if (g.renderPass === "translucent") if (R) {
                const [Z, q, W] = g.stencilConfigForOverlapTwoPass(M);
                Ss(g, v, x, W, Z, O, G, !1, k), Ss(g, v, x, W, q, O, G, !0, k);
              } else {
                const [Z, q] = g.getStencilConfigForOverlapAndUpdateStencilID(M);
                Ss(g, v, x, q, Z, O, G, !1, k);
              }
            }(e, n, o, c, d) : a.ci(o) ? function(g, v, x, M, C) {
              if (g.renderPass !== "translucent" || !M.length) return;
              const { isRenderingToTexture: k } = C, A = g.style.projection.useSubdivision, R = g.getDepthModeForSublayer(0, Tt.ReadOnly), O = g.colorModeForRenderPass();
              if (A) {
                const [G, Z, q] = g.stencilConfigForOverlapTwoPass(M);
                ac(g, v, x, q, G, R, O, !1, k), ac(g, v, x, q, Z, R, O, !0, k);
              } else {
                const [G, Z] = g.getStencilConfigForOverlapAndUpdateStencilID(M);
                ac(g, v, x, Z, G, R, O, !1, k);
              }
            }(e, n, o, c, d) : a.cj(o) ? function(g, v, x, M, C) {
              if (g.renderPass !== "translucent" || x.paint.get("raster-opacity") === 0 || !M.length) return;
              const { isRenderingToTexture: k } = C, A = v.getSource(), R = g.style.projection.useSubdivision;
              if (A instanceof Ue) Ps(g, v, x, M, null, !1, !1, A.tileCoords, A.flippedWindingOrder, k);
              else if (R) {
                const [O, G, Z] = g.stencilConfigForOverlapTwoPass(M);
                Ps(g, v, x, Z, O, !1, !0, Ua, !1, k), Ps(g, v, x, Z, G, !0, !0, Ua, !1, k);
              } else {
                const [O, G] = g.getStencilConfigForOverlapAndUpdateStencilID(M);
                Ps(g, v, x, G, O, !1, !0, Ua, !1, k);
              }
            }(e, n, o, c, d) : a.ck(o) ? function(g, v, x, M, C) {
              const k = x.paint.get("background-color"), A = x.paint.get("background-opacity");
              if (A === 0) return;
              const { isRenderingToTexture: R } = C, O = g.context, G = O.gl, Z = g.style.projection, q = g.transform, W = q.tileSize, J = x.paint.get("background-pattern");
              if (g.isPatternMissing(J)) return;
              const K = !J && k.a === 1 && A === 1 && g.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (g.renderPass !== K) return;
              const te = qt.disabled, se = g.getDepthModeForSublayer(0, K === "opaque" ? Tt.ReadWrite : Tt.ReadOnly), Y = g.colorModeForRenderPass(), pe = g.useProgram(J ? "backgroundPattern" : "background"), be = M || fe(q, { tileSize: W, terrain: g.style.map.terrain });
              J && (O.activeTexture.set(G.TEXTURE0), g.imageManager.bind(g.context));
              const ge = x.getCrossfadeParameters();
              for (const _e of be) {
                const xe = q.getProjectionData({ overscaledTileID: _e, applyGlobeMatrix: !R, applyTerrainMatrix: !0 }), Le = J ? wu(A, g, J, { tileID: _e, tileSize: W }, ge) : bu(A, k), Oe = g.style.map.terrain && g.style.map.terrain.getTerrainData(_e), Ie = Z.getMeshFromTileID(O, _e.canonical, !1, !0, "raster");
                pe.draw(O, G.TRIANGLES, se, te, Y, ft.backCCW, Le, Oe, xe, x.id, Ie.vertexBuffer, Ie.indexBuffer, Ie.segments);
              }
            }(e, 0, o, c, d) : a.cl(o) && function(g, v, x, M) {
              const { isRenderingGlobe: C } = M, k = g.context, A = x.implementation, R = g.style.projection, O = g.transform, G = O.getProjectionDataForCustomLayer(C), Z = { farZ: O.farZ, nearZ: O.nearZ, fov: O.fov * Math.PI / 180, modelViewProjectionMatrix: O.modelViewProjectionMatrix, projectionMatrix: O.projectionMatrix, shaderData: { variantName: R.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${R.shaderPreludeCode.vertexSource}`, define: R.shaderDefine }, defaultProjectionData: G }, q = A.renderingMode ? A.renderingMode : "2d";
              if (g.renderPass === "offscreen") {
                const W = A.prerender;
                W && (g.setCustomLayerDefaults(), k.setColorMode(g.colorModeForRenderPass()), W.call(A, k.gl, Z), k.setDirty(), g.setBaseState());
              } else if (g.renderPass === "translucent") {
                g.setCustomLayerDefaults(), k.setColorMode(g.colorModeForRenderPass()), k.setStencilMode(qt.disabled);
                const W = q === "3d" ? g.getDepthModeFor3D() : g.getDepthModeForSublayer(0, Tt.ReadOnly);
                k.setDepthMode(W), A.render(k.gl, Z), k.setDirty(), g.setBaseState(), k.bindFramebuffer.set(null);
              }
            }(e, 0, o, d));
          }
          saveTileTexture(e) {
            const n = this._tileTextures[e.size[0]];
            n ? n.push(e) : this._tileTextures[e.size[0]] = [e];
          }
          getTileTexture(e) {
            const n = this._tileTextures[e];
            return n && n.length > 0 ? n.pop() : null;
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const n = this.imageManager.getPattern(e.from.toString()), o = this.imageManager.getPattern(e.to.toString());
            return !n || !o;
          }
          useProgram(e, n, o = !1, c = []) {
            this.cache = this.cache || {};
            const d = !!this.style.map.terrain, g = this.style.projection, v = o ? en.projectionMercator : g.shaderPreludeCode, x = o ? In : g.shaderDefine, M = e + (n ? n.cacheKey : "") + `/${o ? fs : g.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (d ? "/terrain" : "") + (c ? `/${c.join("/")}` : "");
            return this.cache[M] || (this.cache[M] = new Zl(this.context, en[e], n, Kl[e], this._showOverdrawInspector, d, v, x, c)), this.cache[M];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new a.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: e, drawingBufferHeight: n } = this.context.gl;
            return this.width !== e || this.height !== n;
          }
        }
        function Ms(h, e) {
          let n, o = !1, c = null, d = null;
          const g = () => {
            c = null, o && (h.apply(d, n), c = setTimeout(g, e), o = !1);
          };
          return (...v) => (o = !0, d = this, n = v, c || g(), c);
        }
        class qa {
          constructor(e) {
            this._getCurrentHash = () => {
              const n = window.location.hash.replace("#", "");
              if (this._hashName) {
                let o;
                return n.split("&").map((c) => c.split("=")).forEach((c) => {
                  c[0] === this._hashName && (o = c);
                }), (o && o[1] || "").split("/");
              }
              return n.split("/");
            }, this._onHashChange = () => {
              const n = this._getCurrentHash();
              if (!this._isValidHash(n)) return !1;
              const o = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(n[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+n[2], +n[1]], zoom: +n[0], bearing: o, pitch: +(n[4] || 0) }), !0;
            }, this._updateHashUnthrottled = () => {
              const n = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, n);
            }, this._removeHash = () => {
              const n = this._getCurrentHash();
              if (n.length === 0) return;
              const o = n.join("/");
              let c = o;
              c.split("&").length > 0 && (c = c.split("&")[0]), this._hashName && (c = `${this._hashName}=${o}`);
              let d = window.location.hash.replace(c, "");
              d.startsWith("#&") ? d = d.slice(0, 1) + d.slice(2) : d === "#" && (d = "");
              let g = window.location.href.replace(/(#.+)?$/, d);
              g = g.replace("&&", "&"), window.history.replaceState(window.history.state, null, g);
            }, this._updateHash = Ms(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(e) {
            const n = this._map.getCenter(), o = Math.round(100 * this._map.getZoom()) / 100, c = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), d = Math.pow(10, c), g = Math.round(n.lng * d) / d, v = Math.round(n.lat * d) / d, x = this._map.getBearing(), M = this._map.getPitch();
            let C = "";
            if (C += e ? `/${g}/${v}/${o}` : `${o}/${v}/${g}`, (x || M) && (C += "/" + Math.round(10 * x) / 10), M && (C += `/${Math.round(M)}`), this._hashName) {
              const k = this._hashName;
              let A = !1;
              const R = window.location.hash.slice(1).split("&").map((O) => {
                const G = O.split("=")[0];
                return G === k ? (A = !0, `${G}=${C}`) : O;
              }).filter((O) => O);
              return A || R.push(`${k}=${C}`), `#${R.join("&")}`;
            }
            return `#${C}`;
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new a.S(+e[2], +e[1]);
            } catch {
              return !1;
            }
            const n = +e[0], o = +(e[3] || 0), c = +(e[4] || 0);
            return n >= this._map.getMinZoom() && n <= this._map.getMaxZoom() && o >= -180 && o <= 180 && c >= this._map.getMinPitch() && c <= this._map.getMaxPitch();
          }
        }
        const kn = { linearity: 0.3, easing: a.cm(0, 0, 0.3, 1) }, hc = a.e({ deceleration: 2500, maxSpeed: 1400 }, kn), Ou = a.e({ deceleration: 20, maxSpeed: 1400 }, kn), ju = a.e({ deceleration: 1e3, maxSpeed: 360 }, kn), Vu = a.e({ deceleration: 1e3, maxSpeed: 90 }, kn), Nu = a.e({ deceleration: 1e3, maxSpeed: 360 }, kn);
        class $u {
          constructor(e) {
            this._map = e, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: we.now(), settings: e });
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer, n = we.now();
            for (; e.length > 0 && n - e[0].time > 160; ) e.shift();
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const n = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new a.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: d } of this._inertiaBuffer) n.zoom += d.zoomDelta || 0, n.bearing += d.bearingDelta || 0, n.pitch += d.pitchDelta || 0, n.roll += d.rollDelta || 0, d.panDelta && n.pan._add(d.panDelta), d.around && (n.around = d.around), d.pinchAround && (n.pinchAround = d.pinchAround);
            const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, c = {};
            if (n.pan.mag()) {
              const d = Qs(n.pan.mag(), o, a.e({}, hc, e || {})), g = n.pan.mult(d.amount / n.pan.mag()), v = this._map.cameraHelper.handlePanInertia(g, this._map.transform);
              c.center = v.easingCenter, c.offset = v.easingOffset, nn(c, d);
            }
            if (n.zoom) {
              const d = Qs(n.zoom, o, Ou);
              c.zoom = this._map.transform.zoom + d.amount, nn(c, d);
            }
            if (n.bearing) {
              const d = Qs(n.bearing, o, ju);
              c.bearing = this._map.transform.bearing + a.ah(d.amount, -179, 179), nn(c, d);
            }
            if (n.pitch) {
              const d = Qs(n.pitch, o, Vu);
              c.pitch = this._map.transform.pitch + d.amount, nn(c, d);
            }
            if (n.roll) {
              const d = Qs(n.roll, o, Nu);
              c.roll = this._map.transform.roll + a.ah(d.amount, -179, 179), nn(c, d);
            }
            if (c.zoom || c.bearing) {
              const d = n.pinchAround === void 0 ? n.around : n.pinchAround;
              c.around = d ? this._map.unproject(d) : this._map.getCenter();
            }
            return this.clear(), a.e(c, { noMoveStart: !0 });
          }
        }
        function nn(h, e) {
          (!h.duration || h.duration < e.duration) && (h.duration = e.duration, h.easing = e.easing);
        }
        function Qs(h, e, n) {
          const { maxSpeed: o, linearity: c, deceleration: d } = n, g = a.ah(h * c / (e / 1e3), -o, o), v = Math.abs(g) / (d * c);
          return { easing: n.easing, duration: 1e3 * v, amount: g * (v / 2) };
        }
        class Ir extends a.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, n, o, c = {}) {
            o = o instanceof MouseEvent ? o : new MouseEvent(e, o);
            const d = Q.mousePos(n.getCanvas(), o), g = n.unproject(d);
            super(e, a.e({ point: d, lngLat: g, originalEvent: o }, c)), this._defaultPrevented = !1, this.target = n;
          }
        }
        class eo extends a.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, n, o) {
            const c = e === "touchend" ? o.changedTouches : o.touches, d = Q.touchPos(n.getCanvasContainer(), c), g = d.map((x) => n.unproject(x)), v = d.reduce((x, M, C, k) => x.add(M.div(k.length)), new a.P(0, 0));
            super(e, { points: d, point: v, lngLats: g, lngLat: n.unproject(v), originalEvent: o }), this._defaultPrevented = !1;
          }
        }
        class dc extends a.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, n, o) {
            super(e, { originalEvent: o }), this._defaultPrevented = !1;
          }
        }
        class Uu {
          constructor(e, n) {
            this._map = e, this._clickTolerance = n.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e) {
            return this._firePreventable(new dc(e.type, this._map, e));
          }
          mousedown(e, n) {
            return this._mousedownPos = n, this._firePreventable(new Ir(e.type, this._map, e));
          }
          mouseup(e) {
            this._map.fire(new Ir(e.type, this._map, e));
          }
          click(e, n) {
            this._mousedownPos && this._mousedownPos.dist(n) >= this._clickTolerance || this._map.fire(new Ir(e.type, this._map, e));
          }
          dblclick(e) {
            return this._firePreventable(new Ir(e.type, this._map, e));
          }
          mouseover(e) {
            this._map.fire(new Ir(e.type, this._map, e));
          }
          mouseout(e) {
            this._map.fire(new Ir(e.type, this._map, e));
          }
          touchstart(e) {
            return this._firePreventable(new eo(e.type, this._map, e));
          }
          touchmove(e) {
            this._map.fire(new eo(e.type, this._map, e));
          }
          touchend(e) {
            this._map.fire(new eo(e.type, this._map, e));
          }
          touchcancel(e) {
            this._map.fire(new eo(e.type, this._map, e));
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Zu {
          constructor(e) {
            this._map = e;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(e) {
            this._map.fire(new Ir(e.type, this._map, e));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Ir("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Ir(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class to {
          constructor(e) {
            this._map = e;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e) {
            return this.transform.screenPointToLocation(a.P.convert(e), this._map.terrain);
          }
        }
        class pc {
          constructor(e, n) {
            this._map = e, this._tr = new to(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = n.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(e, n) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (Q.disableDrag(), this._startPos = this._lastPos = n, this._active = !0);
          }
          mousemoveWindow(e, n) {
            if (!this._active) return;
            const o = n;
            if (this._lastPos.equals(o) || !this._box && o.dist(this._startPos) < this._clickTolerance) return;
            const c = this._startPos;
            this._lastPos = o, this._box || (this._box = Q.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const d = Math.min(c.x, o.x), g = Math.max(c.x, o.x), v = Math.min(c.y, o.y), x = Math.max(c.y, o.y);
            Q.setTransform(this._box, `translate(${d}px,${v}px)`), this._box.style.width = g - d + "px", this._box.style.height = x - v + "px";
          }
          mouseupWindow(e, n) {
            if (!this._active || e.button !== 0) return;
            const o = this._startPos, c = n;
            if (this.reset(), Q.suppressClick(), o.x !== c.x || o.y !== c.y) return this._map.fire(new a.l("boxzoomend", { originalEvent: e })), { cameraAnimation: (d) => d.fitScreenCoordinates(o, c, this._tr.bearing, { linear: !0 }) };
            this._fireEvent("boxzoomcancel", e);
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (Q.remove(this._box), this._box = null), Q.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e, n) {
            return this._map.fire(new a.l(e, { originalEvent: n }));
          }
        }
        function io(h, e) {
          if (h.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
          const n = {};
          for (let o = 0; o < h.length; o++) n[h[o].identifier] = e[o];
          return n;
        }
        class Gu {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(e, n, o) {
            (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), o.length === this.numTouches && (this.centroid = function(c) {
              const d = new a.P(0, 0);
              for (const g of c) d._add(g);
              return d.div(c.length);
            }(n), this.touches = io(o, n)));
          }
          touchmove(e, n, o) {
            if (this.aborted || !this.centroid) return;
            const c = io(o, n);
            for (const d in this.touches) {
              const g = c[d];
              (!g || g.dist(this.touches[d]) > 30) && (this.aborted = !0);
            }
          }
          touchend(e, n, o) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), o.length === 0) {
              const c = !this.aborted && this.centroid;
              if (this.reset(), c) return c;
            }
          }
        }
        class Er {
          constructor(e) {
            this.singleTap = new Gu(e), this.numTaps = e.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e, n, o) {
            this.singleTap.touchstart(e, n, o);
          }
          touchmove(e, n, o) {
            this.singleTap.touchmove(e, n, o);
          }
          touchend(e, n, o) {
            const c = this.singleTap.touchend(e, n, o);
            if (c) {
              const d = e.timeStamp - this.lastTime < 500, g = !this.lastTap || this.lastTap.dist(c) < 30;
              if (d && g || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = c, this.count === this.numTaps) return this.reset(), c;
            }
          }
        }
        class sn {
          constructor(e) {
            this._tr = new to(e), this._zoomIn = new Er({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Er({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e, n, o) {
            this._zoomIn.touchstart(e, n, o), this._zoomOut.touchstart(e, n, o);
          }
          touchmove(e, n, o) {
            this._zoomIn.touchmove(e, n, o), this._zoomOut.touchmove(e, n, o);
          }
          touchend(e, n, o) {
            const c = this._zoomIn.touchend(e, n, o), d = this._zoomOut.touchend(e, n, o), g = this._tr;
            return c ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (v) => v.easeTo({ duration: 300, zoom: g.zoom + 1, around: g.unproject(c) }, { originalEvent: e }) }) : d ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (v) => v.easeTo({ duration: 300, zoom: g.zoom - 1, around: g.unproject(d) }, { originalEvent: e }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ro {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e);
          }
          _move(...e) {
            const n = this._moveFunction(...e);
            if (n.bearingDelta || n.pitchDelta || n.rollDelta || n.around || n.panDelta) return this._active = !0, n;
          }
          dragStart(e, n) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(n) ? n[0] : n, this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(e, n) {
            if (!this.isEnabled()) return;
            const o = this._lastPoint;
            if (!o) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const c = Array.isArray(n) ? n[0] : n;
            return !this._moved && c.dist(o) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = c, this._move(o, c));
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && Q.suppressClick(), this.reset(e));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const on = 0, no = 2, Pd = { [on]: 1, [no]: 2 };
        class Xo {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent;
          }
          startMove(e) {
            const n = Q.mouseButton(e);
            this._eventButton = n;
          }
          endMove(e) {
            delete this._eventButton;
          }
          isValidStartEvent(e) {
            return this._correctEvent(e);
          }
          isValidMoveEvent(e) {
            return !function(n, o) {
              const c = Pd[o];
              return n.buttons === void 0 || (n.buttons & c) !== c;
            }(e, this._eventButton);
          }
          isValidEndEvent(e) {
            return Q.mouseButton(e) === this._eventButton;
          }
        }
        class Md {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1;
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier;
          }
          endMove(e) {
            delete this._firstTouch;
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e);
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
        }
        class Cd {
          constructor(e = new Xo({ checkCorrectEvent: () => !0 }), n = new Md()) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = n;
          }
          _executeRelevantHandler(e, n, o) {
            return e instanceof MouseEvent ? n(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? o(e) : void 0;
          }
          startMove(e) {
            this._executeRelevantHandler(e, (n) => this.mouseMoveStateManager.startMove(n), (n) => this.oneFingerTouchMoveStateManager.startMove(n));
          }
          endMove(e) {
            this._executeRelevantHandler(e, (n) => this.mouseMoveStateManager.endMove(n), (n) => this.oneFingerTouchMoveStateManager.endMove(n));
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (n) => this.mouseMoveStateManager.isValidStartEvent(n), (n) => this.oneFingerTouchMoveStateManager.isValidStartEvent(n));
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (n) => this.mouseMoveStateManager.isValidMoveEvent(n), (n) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(n));
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (n) => this.mouseMoveStateManager.isValidEndEvent(n), (n) => this.oneFingerTouchMoveStateManager.isValidEndEvent(n));
          }
        }
        const Ko = (h) => {
          h.mousedown = h.dragStart, h.mousemoveWindow = h.dragMove, h.mouseup = h.dragEnd, h.contextmenu = (e) => {
            e.preventDefault();
          };
        };
        class Yo {
          constructor(e, n) {
            this._clickTolerance = e.clickTolerance || 1, this._map = n, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new a.P(0, 0);
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e, n, o) {
            return this._calculateTransform(e, n, o);
          }
          touchmove(e, n, o) {
            if (this._active) {
              if (!this._shouldBePrevented(o.length)) return e.preventDefault(), this._calculateTransform(e, n, o);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
            }
          }
          touchend(e, n, o) {
            this._calculateTransform(e, n, o), this._active && this._shouldBePrevented(o.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e, n, o) {
            o.length > 0 && (this._active = !0);
            const c = io(o, n), d = new a.P(0, 0), g = new a.P(0, 0);
            let v = 0;
            for (const M in c) {
              const C = c[M], k = this._touches[M];
              k && (d._add(C), g._add(C.sub(k)), v++, c[M] = C);
            }
            if (this._touches = c, this._shouldBePrevented(v) || !g.mag()) return;
            const x = g.div(v);
            return this._sum._add(x), this._sum.mag() < this._clickTolerance ? void 0 : { around: d.div(v), panDelta: x };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class an {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          touchstart(e, n, o) {
            this._firstTwoTouches || o.length < 2 || (this._firstTwoTouches = [o[0].identifier, o[1].identifier], this._start([n[0], n[1]]));
          }
          touchmove(e, n, o) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [c, d] = this._firstTwoTouches, g = We(o, n, c), v = We(o, n, d);
            if (!g || !v) return;
            const x = this._aroundCenter ? null : g.add(v).div(2);
            return this._move([g, v], x, e);
          }
          touchend(e, n, o) {
            if (!this._firstTwoTouches) return;
            const [c, d] = this._firstTwoTouches, g = We(o, n, c), v = We(o, n, d);
            g && v || (this._active && Q.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function We(h, e, n) {
          for (let o = 0; o < h.length; o++) if (h[o].identifier === n) return e[o];
        }
        function fc(h, e) {
          return Math.log(h / e) / Math.LN2;
        }
        class Ha extends an {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1]);
          }
          _move(e, n) {
            const o = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(fc(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: fc(this._distance, o), pinchAround: n };
          }
        }
        function mc(h, e) {
          return 180 * h.angleWith(e) / Math.PI;
        }
        class so extends an {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
          }
          _move(e, n, o) {
            const c = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: mc(this._vector, c), pinchAround: n };
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const n = 25 / (Math.PI * this._minDiameter) * 360, o = mc(e, this._startVector);
            return Math.abs(o) < n;
          }
        }
        function Cs(h) {
          return Math.abs(h.y) > Math.abs(h.x);
        }
        class Wa extends an {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e, n, o) {
            super.touchstart(e, n, o), this._currentTouchCount = o.length;
          }
          _start(e) {
            this._lastPoints = e, Cs(e[0].sub(e[1])) && (this._valid = !1);
          }
          _move(e, n, o) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const c = e[0].sub(this._lastPoints[0]), d = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(c, d, o.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, { pitchDelta: (c.y + d.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(e, n, o) {
            if (this._valid !== void 0) return this._valid;
            const c = e.mag() >= 2, d = n.mag() >= 2;
            if (!c && !d) return;
            if (!c || !d) return this._firstMove === void 0 && (this._firstMove = o), o - this._firstMove < 100 && void 0;
            const g = e.y > 0 == n.y > 0;
            return Cs(e) && Cs(n) && g;
          }
        }
        const Nt = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Xa {
          constructor(e) {
            this._tr = new to(e);
            const n = Nt;
            this._panStep = n.panStep, this._bearingStep = n.bearingStep, this._pitchStep = n.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let n = 0, o = 0, c = 0, d = 0, g = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                n = 1;
                break;
              case 189:
              case 109:
              case 173:
                n = -1;
                break;
              case 37:
                e.shiftKey ? o = -1 : (e.preventDefault(), d = -1);
                break;
              case 39:
                e.shiftKey ? o = 1 : (e.preventDefault(), d = 1);
                break;
              case 38:
                e.shiftKey ? c = 1 : (e.preventDefault(), g = -1);
                break;
              case 40:
                e.shiftKey ? c = -1 : (e.preventDefault(), g = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (o = 0, c = 0), { cameraAnimation: (v) => {
              const x = this._tr;
              v.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Id, zoom: n ? Math.round(x.zoom) + n * (e.shiftKey ? 2 : 1) : x.zoom, bearing: x.bearing + o * this._bearingStep, pitch: x.pitch + c * this._pitchStep, offset: [-d * this._panStep, -g * this._panStep], center: x.center }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function Id(h) {
          return h * (2 - h);
        }
        const Ka = 4.000244140625, Ed = 1 / 450;
        class qu {
          constructor(e, n) {
            this._onTimeout = (o) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(o);
            }, this._map = e, this._tr = new to(e), this._triggerRenderFrame = n, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Ed;
          }
          setZoomRate(e) {
            this._defaultZoomRate = e;
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let n = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const o = we.now(), c = o - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o, n !== 0 && n % Ka == 0 ? this._type = "wheel" : n !== 0 && Math.abs(n) < 4 ? this._type = "trackpad" : c > 400 ? (this._type = null, this._lastValue = n, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(c * n) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, n += this._lastValue)), e.shiftKey && n && (n /= 4), this._type && (this._lastWheelEvent = e, this._delta -= n, this._active || this._start(e)), e.preventDefault();
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const n = Q.mousePos(this._map.getCanvas(), e), o = this._tr;
            this._aroundPoint = this._aroundCenter ? o.transform.locationToScreenPoint(a.S.convert(o.center)) : n, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const v = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += v), typeof this._targetZoom == "number" && (this._targetZoom += v);
            }
            if (this._delta !== 0) {
              const v = this._type === "wheel" && Math.abs(this._delta) > Ka ? this._wheelZoomRate : this._defaultZoomRate;
              let x = 2 / (1 + Math.exp(-Math.abs(this._delta * v)));
              this._delta < 0 && x !== 0 && (x = 1 / x);
              const M = typeof this._targetZoom != "number" ? e.scale : a.af(this._targetZoom);
              this._targetZoom = e.getConstrained(e.getCameraLngLat(), a.ak(M * x)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const n = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, o = this._startZoom, c = this._easing;
            let d, g = !1;
            if (this._type === "wheel" && o && c) {
              const v = we.now() - this._lastWheelEventTime, x = Math.min((v + 5) / 200, 1), M = c(x);
              d = a.C.number(o, n, M), x < 1 ? this._frameId || (this._frameId = !0) : g = !0;
            } else d = n, g = !0;
            return this._active = !0, g && (this._active = !1, this._finishTimeout = setTimeout(() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }, 200)), this._lastExpectedZoom = d, { noInertia: !0, needsRenderFrame: !g, zoomDelta: d - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e) {
            let n = a.co;
            if (this._prevEase) {
              const o = this._prevEase, c = (we.now() - o.start) / o.duration, d = o.easing(c + 0.01) - o.easing(c), g = 0.27 / Math.sqrt(d * d + 1e-4) * 0.01, v = Math.sqrt(0.0729 - g * g);
              n = a.cm(g, v, 0.25, 1);
            }
            return this._prevEase = { start: we.now(), duration: e, easing: n }, n;
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class gc {
          constructor(e, n) {
            this._clickZoom = e, this._tapZoom = n;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class _c {
          constructor(e) {
            this._tr = new to(e), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(e, n) {
            return e.preventDefault(), { cameraAnimation: (o) => {
              o.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(n) }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Hu {
          constructor() {
            this._tap = new Er({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e, n, o) {
            if (!this._swipePoint) if (this._tapTime) {
              const c = n[0], d = e.timeStamp - this._tapTime < 500, g = this._tapPoint.dist(c) < 30;
              d && g ? o.length > 0 && (this._swipePoint = c, this._swipeTouch = o[0].identifier) : this.reset();
            } else this._tap.touchstart(e, n, o);
          }
          touchmove(e, n, o) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (o[0].identifier !== this._swipeTouch) return;
                const c = n[0], d = c.y - this._swipePoint.y;
                return this._swipePoint = c, e.preventDefault(), this._active = !0, { zoomDelta: d / 128 };
              }
            } else this._tap.touchmove(e, n, o);
          }
          touchend(e, n, o) {
            if (this._tapTime) this._swipePoint && o.length === 0 && this.reset();
            else {
              const c = this._tap.touchend(e, n, o);
              c && (this._tapTime = e.timeStamp, this._tapPoint = c);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Wu {
          constructor(e, n, o) {
            this._el = e, this._mousePan = n, this._touchPan = o;
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class yc {
          constructor(e, n, o, c) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = n, this._mousePitch = o, this._mouseRoll = c;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Xu {
          constructor(e, n, o, c) {
            this._el = e, this._touchZoom = n, this._touchRotate = o, this._tapDragZoom = c, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Ku {
          constructor(e, n) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = n, this._enabled = !1;
          }
          isActive() {
            return !1;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = Q.create("div", "maplibregl-cooperative-gesture-screen", e);
            let n = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (n = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const o = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), c = document.createElement("div");
            c.className = "maplibregl-desktop-message", c.textContent = n, this._container.appendChild(c);
            const d = document.createElement("div");
            d.className = "maplibregl-mobile-message", d.textContent = o, this._container.appendChild(d), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (Q.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e) {
            return e[this._bypassKey];
          }
          notifyGestureBlocked(e, n) {
            this._enabled && (this._map.fire(new a.l("cooperativegestureprevented", { gestureType: e, originalEvent: n })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
              this._container.classList.remove("maplibregl-show");
            }, 100));
          }
        }
        const ln = (h) => h.zoom || h.drag || h.roll || h.pitch || h.rotate;
        class ai extends a.l {
        }
        function oo(h) {
          return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta || h.rollDelta;
        }
        class vc {
          constructor(e, n) {
            this.handleWindowEvent = (c) => {
              this.handleEvent(c, `${c.type}Window`);
            }, this.handleEvent = (c, d) => {
              if (c.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const g = c.type === "renderFrame" ? void 0 : c, v = { needsRenderFrame: !1 }, x = {}, M = {};
              for (const { handlerName: A, handler: R, allowed: O } of this._handlers) {
                if (!R.isEnabled()) continue;
                let G;
                if (this._blockedByActive(M, O, A)) R.reset();
                else if (R[d || c.type]) {
                  if (a.cp(c, d || c.type)) {
                    const Z = Q.mousePos(this._map.getCanvas(), c);
                    G = R[d || c.type](c, Z);
                  } else if (a.cq(c, d || c.type)) {
                    const Z = this._getMapTouches(c.touches), q = Q.touchPos(this._map.getCanvas(), Z);
                    G = R[d || c.type](c, q, Z);
                  } else a.cr(d || c.type) || (G = R[d || c.type](c));
                  this.mergeHandlerResult(v, x, G, A, g), G && G.needsRenderFrame && this._triggerRenderFrame();
                }
                (G || R.isActive()) && (M[A] = R);
              }
              const C = {};
              for (const A in this._previousActiveHandlers) M[A] || (C[A] = g);
              this._previousActiveHandlers = M, (Object.keys(C).length || oo(v)) && (this._changes.push([v, x, C]), this._triggerRenderFrame()), (Object.keys(M).length || oo(v)) && this._map._stop(!0), this._updatingCamera = !1;
              const { cameraAnimation: k } = v;
              k && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], k(this._map));
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new $u(e), this._bearingSnap = n.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(n);
            const o = this._el;
            this._listeners = [[o, "touchstart", { passive: !0 }], [o, "touchmove", { passive: !1 }], [o, "touchend", void 0], [o, "touchcancel", void 0], [o, "mousedown", void 0], [o, "mousemove", void 0], [o, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [o, "mouseover", void 0], [o, "mouseout", void 0], [o, "dblclick", void 0], [o, "click", void 0], [o, "keydown", { capture: !1 }], [o, "keyup", void 0], [o, "wheel", { passive: !1 }], [o, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [c, d, g] of this._listeners) Q.addEventListener(c, d, c === document ? this.handleWindowEvent : this.handleEvent, g);
          }
          destroy() {
            for (const [e, n, o] of this._listeners) Q.removeEventListener(e, n, e === document ? this.handleWindowEvent : this.handleEvent, o);
          }
          _addDefaultHandlers(e) {
            const n = this._map, o = n.getCanvasContainer();
            this._add("mapEvent", new Uu(n, e));
            const c = n.boxZoom = new pc(n, e);
            this._add("boxZoom", c), e.interactive && e.boxZoom && c.enable();
            const d = n.cooperativeGestures = new Ku(n, e.cooperativeGestures);
            this._add("cooperativeGestures", d), e.cooperativeGestures && d.enable();
            const g = new sn(n), v = new _c(n);
            n.doubleClickZoom = new gc(v, g), this._add("tapZoom", g), this._add("clickZoom", v), e.interactive && e.doubleClickZoom && n.doubleClickZoom.enable();
            const x = new Hu();
            this._add("tapDragZoom", x);
            const M = n.touchPitch = new Wa(n);
            this._add("touchPitch", M), e.interactive && e.touchPitch && n.touchPitch.enable(e.touchPitch);
            const C = () => n.project(n.getCenter()), k = function({ enable: K, clickTolerance: te, aroundCenter: se = !0, minPixelCenterThreshold: Y = 100, rotateDegreesPerPixelMoved: pe = 0.8 }, be) {
              const ge = new Xo({ checkCorrectEvent: (_e) => Q.mouseButton(_e) === 0 && _e.ctrlKey || Q.mouseButton(_e) === 2 && !_e.ctrlKey });
              return new ro({ clickTolerance: te, move: (_e, xe) => {
                const Le = be();
                if (se && Math.abs(Le.y - _e.y) > Y) return { bearingDelta: a.cn(new a.P(_e.x, xe.y), xe, Le) };
                let Oe = (xe.x - _e.x) * pe;
                return se && xe.y < Le.y && (Oe = -Oe), { bearingDelta: Oe };
              }, moveStateManager: ge, enable: K, assignEvents: Ko });
            }(e, C), A = function({ enable: K, clickTolerance: te, pitchDegreesPerPixelMoved: se = -0.5 }) {
              const Y = new Xo({ checkCorrectEvent: (pe) => Q.mouseButton(pe) === 0 && pe.ctrlKey || Q.mouseButton(pe) === 2 });
              return new ro({ clickTolerance: te, move: (pe, be) => ({ pitchDelta: (be.y - pe.y) * se }), moveStateManager: Y, enable: K, assignEvents: Ko });
            }(e), R = function({ enable: K, clickTolerance: te, rollDegreesPerPixelMoved: se = 0.3 }, Y) {
              const pe = new Xo({ checkCorrectEvent: (be) => Q.mouseButton(be) === 2 && be.ctrlKey });
              return new ro({ clickTolerance: te, move: (be, ge) => {
                const _e = Y();
                let xe = (ge.x - be.x) * se;
                return ge.y < _e.y && (xe = -xe), { rollDelta: xe };
              }, moveStateManager: pe, enable: K, assignEvents: Ko });
            }(e, C);
            n.dragRotate = new yc(e, k, A, R), this._add("mouseRotate", k, ["mousePitch"]), this._add("mousePitch", A, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", R, ["mousePitch"]), e.interactive && e.dragRotate && n.dragRotate.enable();
            const O = function({ enable: K, clickTolerance: te }) {
              const se = new Xo({ checkCorrectEvent: (Y) => Q.mouseButton(Y) === 0 && !Y.ctrlKey });
              return new ro({ clickTolerance: te, move: (Y, pe) => ({ around: pe, panDelta: pe.sub(Y) }), activateOnStart: !0, moveStateManager: se, enable: K, assignEvents: Ko });
            }(e), G = new Yo(e, n);
            n.dragPan = new Wu(o, O, G), this._add("mousePan", O), this._add("touchPan", G, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && n.dragPan.enable(e.dragPan);
            const Z = new so(), q = new Ha();
            n.touchZoomRotate = new Xu(o, q, Z, x), this._add("touchRotate", Z, ["touchPan", "touchZoom"]), this._add("touchZoom", q, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && n.touchZoomRotate.enable(e.touchZoomRotate);
            const W = n.scrollZoom = new qu(n, () => this._triggerRenderFrame());
            this._add("scrollZoom", W, ["mousePan"]), e.interactive && e.scrollZoom && n.scrollZoom.enable(e.scrollZoom);
            const J = n.keyboard = new Xa(n);
            this._add("keyboard", J), e.interactive && e.keyboard && n.keyboard.enable(), this._add("blockableMapEvent", new Zu(n));
          }
          _add(e, n, o) {
            this._handlers.push({ handlerName: e, handler: n, allowed: o }), this._handlersById[e] = n;
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const { handler: n } of this._handlers) n.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e } of this._handlers) if (e.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!ln(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(e, n, o) {
            for (const c in e) if (c !== o && (!n || n.indexOf(c) < 0)) return !0;
            return !1;
          }
          _getMapTouches(e) {
            const n = [];
            for (const o of e) this._el.contains(o.target) && n.push(o);
            return n;
          }
          mergeHandlerResult(e, n, o, c, d) {
            if (!o) return;
            a.e(e, o);
            const g = { handlerName: c, originalEvent: o.originalEvent || d };
            o.zoomDelta !== void 0 && (n.zoom = g), o.panDelta !== void 0 && (n.drag = g), o.rollDelta !== void 0 && (n.roll = g), o.pitchDelta !== void 0 && (n.pitch = g), o.bearingDelta !== void 0 && (n.rotate = g);
          }
          _applyChanges() {
            const e = {}, n = {}, o = {};
            for (const [c, d, g] of this._changes) c.panDelta && (e.panDelta = (e.panDelta || new a.P(0, 0))._add(c.panDelta)), c.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + c.zoomDelta), c.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + c.bearingDelta), c.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + c.pitchDelta), c.rollDelta && (e.rollDelta = (e.rollDelta || 0) + c.rollDelta), c.around !== void 0 && (e.around = c.around), c.pinchAround !== void 0 && (e.pinchAround = c.pinchAround), c.noInertia && (e.noInertia = c.noInertia), a.e(n, d), a.e(o, g);
            this._updateMapTransform(e, n, o), this._changes = [];
          }
          _updateMapTransform(e, n, o) {
            const c = this._map, d = c._getTransformForUpdate(), g = c.terrain;
            if (!(oo(e) || g && this._terrainMovement)) return this._fireEvents(n, o, !0);
            c._stop(!0);
            let { panDelta: v, zoomDelta: x, bearingDelta: M, pitchDelta: C, rollDelta: k, around: A, pinchAround: R } = e;
            R !== void 0 && (A = R), A = A || c.transform.centerPoint, g && !d.isPointOnMapSurface(A) && (A = d.centerPoint);
            const O = { panDelta: v, zoomDelta: x, rollDelta: k, pitchDelta: C, bearingDelta: M, around: A };
            this._map.cameraHelper.useGlobeControls && !d.isPointOnMapSurface(A) && (A = d.centerPoint);
            const G = A.distSqr(d.centerPoint) < 0.01 ? d.center : d.screenPointToLocation(v ? A.sub(v) : A);
            g ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(O, d), this._terrainMovement || !n.drag && !n.zoom ? n.drag && this._terrainMovement ? d.setCenter(d.screenPointToLocation(d.centerPoint.sub(v))) : this._map.cameraHelper.handleMapControlsPan(O, d, G) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(O, d, G))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(O, d), this._map.cameraHelper.handleMapControlsPan(O, d, G)), c._applyUpdatedTransform(d), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(n, o, !0);
          }
          _fireEvents(e, n, o) {
            const c = ln(this._eventsInProgress), d = ln(e), g = {};
            for (const k in e) {
              const { originalEvent: A } = e[k];
              this._eventsInProgress[k] || (g[`${k}start`] = A), this._eventsInProgress[k] = e[k];
            }
            !c && d && this._fireEvent("movestart", d.originalEvent);
            for (const k in g) this._fireEvent(k, g[k]);
            d && this._fireEvent("move", d.originalEvent);
            for (const k in e) {
              const { originalEvent: A } = e[k];
              this._fireEvent(k, A);
            }
            const v = {};
            let x;
            for (const k in this._eventsInProgress) {
              const { handlerName: A, originalEvent: R } = this._eventsInProgress[k];
              this._handlersById[A].isActive() || (delete this._eventsInProgress[k], x = n[A] || R, v[`${k}end`] = x);
            }
            for (const k in v) this._fireEvent(k, v[k]);
            const M = ln(this._eventsInProgress), C = (c || d) && !M;
            if (C && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const k = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && k.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(k);
            }
            if (o && C) {
              this._updatingCamera = !0;
              const k = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), A = (R) => R !== 0 && -this._bearingSnap < R && R < this._bearingSnap;
              !k || !k.essential && we.prefersReducedMotion ? (this._map.fire(new a.l("moveend", { originalEvent: x })), A(this._map.getBearing()) && this._map.resetNorth()) : (A(k.bearing || this._map.getBearing()) && (k.bearing = 0), k.freezeElevation = !0, this._map.easeTo(k, { originalEvent: x })), this._updatingCamera = !1;
            }
          }
          _fireEvent(e, n) {
            this._map.fire(new a.l(e, n ? { originalEvent: n } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e) => {
              delete this._frameId, this.handleEvent(new ai("renderFrame", { timeStamp: e })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class Yu extends a.E {
          constructor(e, n, o) {
            super(), this._renderFrameCallback = () => {
              const c = Math.min((we.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(c)), c < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = o.bearingSnap, this.cameraHelper = n, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          migrateProjection(e, n) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = n;
          }
          getCenter() {
            return new a.S(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e, n) {
            return this.jumpTo({ center: e }, n);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e, n) {
            return this.jumpTo({ elevation: e }, n), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e;
          }
          panBy(e, n, o) {
            return e = a.P.convert(e).mult(-1), this.panTo(this.transform.center, a.e({ offset: e }, n), o);
          }
          panTo(e, n, o) {
            return this.easeTo(a.e({ center: e }, n), o);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e, n) {
            return this.jumpTo({ zoom: e }, n), this;
          }
          zoomTo(e, n, o) {
            return this.easeTo(a.e({ zoom: e }, n), o);
          }
          zoomIn(e, n) {
            return this.zoomTo(this.getZoom() + 1, e, n), this;
          }
          zoomOut(e, n) {
            return this.zoomTo(this.getZoom() - 1, e, n), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e, n) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new a.l("movestart", n)).fire(new a.l("move", n)).fire(new a.l("moveend", n))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e, n) {
            return this.jumpTo({ bearing: e }, n), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e, n) {
            return this.jumpTo({ padding: e }, n), this;
          }
          rotateTo(e, n, o) {
            return this.easeTo(a.e({ bearing: e }, n), o);
          }
          resetNorth(e, n) {
            return this.rotateTo(0, a.e({ duration: 1e3 }, e), n), this;
          }
          resetNorthPitch(e, n) {
            return this.easeTo(a.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), n), this;
          }
          snapToNorth(e, n) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, n) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e, n) {
            return this.jumpTo({ pitch: e }, n), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e, n) {
            return this.jumpTo({ roll: e }, n), this;
          }
          cameraForBounds(e, n) {
            e = ae.convert(e).adjustAntiMeridian();
            const o = n && n.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), o, n);
          }
          _cameraForBoxAndBearing(e, n, o, c) {
            const d = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (c = a.e({ padding: d, offset: [0, 0], maxZoom: this.transform.maxZoom }, c)).padding == "number") {
              const M = c.padding;
              c.padding = { top: M, bottom: M, right: M, left: M };
            }
            const g = a.e(d, c.padding);
            c.padding = g;
            const v = this.transform, x = new ae(e, n);
            return this.cameraHelper.cameraForBoxAndBearing(c, g, x, o, v);
          }
          fitBounds(e, n, o) {
            return this._fitInternal(this.cameraForBounds(e, n), n, o);
          }
          fitScreenCoordinates(e, n, o, c, d) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(a.P.convert(e)), this.transform.screenPointToLocation(a.P.convert(n)), o, c), c, d);
          }
          _fitInternal(e, n, o) {
            return e ? (delete (n = a.e(e, n)).padding, n.linear ? this.easeTo(n, o) : this.flyTo(n, o)) : this;
          }
          jumpTo(e, n) {
            this.stop();
            const o = this._getTransformForUpdate();
            let c = !1, d = !1, g = !1;
            const v = o.zoom;
            this.cameraHelper.handleJumpToCenterZoom(o, e);
            const x = o.zoom !== v;
            return "elevation" in e && o.elevation !== +e.elevation && o.setElevation(+e.elevation), "bearing" in e && o.bearing !== +e.bearing && (c = !0, o.setBearing(+e.bearing)), "pitch" in e && o.pitch !== +e.pitch && (d = !0, o.setPitch(+e.pitch)), "roll" in e && o.roll !== +e.roll && (g = !0, o.setRoll(+e.roll)), e.padding == null || o.isPaddingEqual(e.padding) || o.setPadding(e.padding), this._applyUpdatedTransform(o), this.fire(new a.l("movestart", n)).fire(new a.l("move", n)), x && this.fire(new a.l("zoomstart", n)).fire(new a.l("zoom", n)).fire(new a.l("zoomend", n)), c && this.fire(new a.l("rotatestart", n)).fire(new a.l("rotate", n)).fire(new a.l("rotateend", n)), d && this.fire(new a.l("pitchstart", n)).fire(new a.l("pitch", n)).fire(new a.l("pitchend", n)), g && this.fire(new a.l("rollstart", n)).fire(new a.l("roll", n)).fire(new a.l("rollend", n)), this.fire(new a.l("moveend", n));
          }
          calculateCameraOptionsFromTo(e, n, o, c = 0) {
            const d = a.a1.fromLngLat(e, n), g = a.a1.fromLngLat(o, c), v = g.x - d.x, x = g.y - d.y, M = g.z - d.z, C = Math.hypot(v, x, M);
            if (C === 0) throw new Error("Can't calculate camera options with same From and To");
            const k = Math.hypot(v, x), A = a.ak(this.transform.cameraToCenterDistance / C / this.transform.tileSize), R = 180 * Math.atan2(v, -x) / Math.PI;
            let O = 180 * Math.acos(k / C) / Math.PI;
            return O = M < 0 ? 90 - O : 90 + O, { center: g.toLngLat(), elevation: c, zoom: A, pitch: O, bearing: R };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, n, o, c, d) {
            const g = this.transform.calculateCenterFromCameraLngLatAlt(e, n, o, c);
            return { center: g.center, elevation: g.elevation, zoom: g.zoom, bearing: o, pitch: c, roll: d };
          }
          easeTo(e, n) {
            this._stop(!1, e.easeId), ((e = a.e({ offset: [0, 0], duration: 500, easing: a.co }, e)).animate === !1 || !e.essential && we.prefersReducedMotion) && (e.duration = 0);
            const o = this._getTransformForUpdate(), c = this.getBearing(), d = o.pitch, g = o.roll, v = "bearing" in e ? this._normalizeBearing(e.bearing, c) : c, x = "pitch" in e ? +e.pitch : d, M = "roll" in e ? this._normalizeBearing(e.roll, g) : g, C = "padding" in e ? e.padding : o.padding, k = a.P.convert(e.offset);
            let A, R;
            e.around && (A = a.S.convert(e.around), R = o.locationToScreenPoint(A));
            const O = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, G = this.cameraHelper.handleEaseTo(o, { bearing: v, pitch: x, roll: M, padding: C, around: A, aroundPoint: R, offsetAsPoint: k, offset: e.offset, zoom: e.zoom, center: e.center });
            return this._rotating = this._rotating || c !== v, this._pitching = this._pitching || x !== d, this._rolling = this._rolling || M !== g, this._padding = !o.isPaddingEqual(C), this._zooming = this._zooming || G.isZooming, this._easeId = e.easeId, this._prepareEase(n, e.noMoveStart, O), this.terrain && this._prepareElevation(G.elevationCenter), this._ease((Z) => {
              G.easeFunc(Z), this.terrain && !e.freezeElevation && this._updateElevation(Z), this._applyUpdatedTransform(o), this._fireMoveEvents(n);
            }, (Z) => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(n, Z);
            }, e), this;
          }
          _prepareEase(e, n, o = {}) {
            this._moving = !0, n || o.moving || this.fire(new a.l("movestart", e)), this._zooming && !o.zooming && this.fire(new a.l("zoomstart", e)), this._rotating && !o.rotating && this.fire(new a.l("rotatestart", e)), this._pitching && !o.pitching && this.fire(new a.l("pitchstart", e)), this._rolling && !o.rolling && this.fire(new a.l("rollstart", e));
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0;
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const n = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && n !== this._elevationTarget) {
              const o = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (o - (n - (o * e + this._elevationStart)) / (1 - e)), this._elevationTarget = n;
            }
            this.transform.setElevation(a.C.number(this._elevationStart, this._elevationTarget, e));
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const n = e.getCameraLngLat(), o = e.getCameraAltitude(), c = this.terrain ? this.terrain.getElevationForLngLatZoom(n, e.zoom) : 0;
            if (o < c) {
              const d = this.calculateCameraOptionsFromTo(n, c, e.center, e.elevation);
              return { pitch: d.pitch, zoom: d.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e) {
            const n = [];
            if (n.push((c) => this._elevateCameraIfInsideTerrain(c)), this.transformCameraUpdate && n.push((c) => this.transformCameraUpdate(c)), !n.length) return;
            const o = e.clone();
            for (const c of n) {
              const d = o.clone(), { center: g, zoom: v, roll: x, pitch: M, bearing: C, elevation: k } = c(d);
              g && d.setCenter(g), k !== void 0 && d.setElevation(k), v !== void 0 && d.setZoom(v), x !== void 0 && d.setRoll(x), M !== void 0 && d.setPitch(M), C !== void 0 && d.setBearing(C), o.apply(d);
            }
            this.transform.apply(o);
          }
          _fireMoveEvents(e) {
            this.fire(new a.l("move", e)), this._zooming && this.fire(new a.l("zoom", e)), this._rotating && this.fire(new a.l("rotate", e)), this._pitching && this.fire(new a.l("pitch", e)), this._rolling && this.fire(new a.l("roll", e));
          }
          _afterEase(e, n) {
            if (this._easeId && n && this._easeId === n) return;
            delete this._easeId;
            const o = this._zooming, c = this._rotating, d = this._pitching, g = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, o && this.fire(new a.l("zoomend", e)), c && this.fire(new a.l("rotateend", e)), d && this.fire(new a.l("pitchend", e)), g && this.fire(new a.l("rollend", e)), this.fire(new a.l("moveend", e));
          }
          flyTo(e, n) {
            if (!e.essential && we.prefersReducedMotion) {
              const xe = a.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(xe, n);
            }
            this.stop(), e = a.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: a.co }, e);
            const o = this._getTransformForUpdate(), c = o.bearing, d = o.pitch, g = o.roll, v = o.padding, x = "bearing" in e ? this._normalizeBearing(e.bearing, c) : c, M = "pitch" in e ? +e.pitch : d, C = "roll" in e ? this._normalizeBearing(e.roll, g) : g, k = "padding" in e ? e.padding : o.padding, A = a.P.convert(e.offset);
            let R = o.centerPoint.add(A);
            const O = o.screenPointToLocation(R), G = this.cameraHelper.handleFlyTo(o, { bearing: x, pitch: M, roll: C, padding: k, locationAtOffset: O, offsetAsPoint: A, center: e.center, minZoom: e.minZoom, zoom: e.zoom });
            let Z = e.curve;
            const q = Math.max(o.width, o.height), W = q / G.scaleOfZoom, J = G.pixelPathLength;
            typeof G.scaleOfMinZoom == "number" && (Z = Math.sqrt(q / G.scaleOfMinZoom / J * 2));
            const K = Z * Z;
            function te(xe) {
              const Le = (W * W - q * q + (xe ? -1 : 1) * K * K * J * J) / (2 * (xe ? W : q) * K * J);
              return Math.log(Math.sqrt(Le * Le + 1) - Le);
            }
            function se(xe) {
              return (Math.exp(xe) - Math.exp(-xe)) / 2;
            }
            function Y(xe) {
              return (Math.exp(xe) + Math.exp(-xe)) / 2;
            }
            const pe = te(!1);
            let be = function(xe) {
              return Y(pe) / Y(pe + Z * xe);
            }, ge = function(xe) {
              return q * ((Y(pe) * (se(Le = pe + Z * xe) / Y(Le)) - se(pe)) / K) / J;
              var Le;
            }, _e = (te(!0) - pe) / Z;
            if (Math.abs(J) < 2e-6 || !isFinite(_e)) {
              if (Math.abs(q - W) < 1e-6) return this.easeTo(e, n);
              const xe = W < q ? -1 : 1;
              _e = Math.abs(Math.log(W / q)) / Z, ge = () => 0, be = (Le) => Math.exp(xe * Z * Le);
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * _e / ("screenSpeed" in e ? +e.screenSpeed / Z : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = c !== x, this._pitching = M !== d, this._rolling = C !== g, this._padding = !o.isPaddingEqual(k), this._prepareEase(n, !1), this.terrain && this._prepareElevation(G.targetCenter), this._ease((xe) => {
              const Le = xe * _e, Oe = 1 / be(Le), Ie = ge(Le);
              this._rotating && o.setBearing(a.C.number(c, x, xe)), this._pitching && o.setPitch(a.C.number(d, M, xe)), this._rolling && o.setRoll(a.C.number(g, C, xe)), this._padding && (o.interpolatePadding(v, k, xe), R = o.centerPoint.add(A)), G.easeFunc(xe, Oe, Ie, R), this.terrain && !e.freezeElevation && this._updateElevation(xe), this._applyUpdatedTransform(o), this._fireMoveEvents(n);
            }, () => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(n);
            }, e), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e, n) {
            var o;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const c = this._onEaseEnd;
              delete this._onEaseEnd, c.call(this, n);
            }
            return e || (o = this.handlers) === null || o === void 0 || o.stop(!1), this;
          }
          _ease(e, n, o) {
            o.animate === !1 || o.duration === 0 ? (e(1), n()) : (this._easeStart = we.now(), this._easeOptions = o, this._onEaseFrame = e, this._onEaseEnd = n, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e, n) {
            e = a.aO(e, -180, 180);
            const o = Math.abs(e - n);
            return Math.abs(e - 360 - n) < o && (e -= 360), Math.abs(e + 360 - n) < o && (e += 360), e;
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(a.S.convert(e), this.transform.tileZoom) : null;
          }
        }
        const xc = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class bc {
          constructor(e = xc) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (n) => {
              !n || n.sourceDataType !== "metadata" && n.sourceDataType !== "visibility" && n.dataType !== "style" && n.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = Q.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = Q.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = Q.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            Q.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e, n) {
            const o = this._map._getUIString(`AttributionControl.${n}`);
            e.title = o, e.setAttribute("aria-label", o);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((c) => typeof c != "string" ? "" : c)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const c = this._map.style.stylesheet;
              this.styleOwner = c.owner, this.styleId = c.id;
            }
            const n = this._map.style.sourceCaches;
            for (const c in n) {
              const d = n[c];
              if (d.used || d.usedForTerrain) {
                const g = d.getSource();
                g.attribution && e.indexOf(g.attribution) < 0 && e.push(g.attribution);
              }
            }
            e = e.filter((c) => String(c).trim()), e.sort((c, d) => c.length - d.length), e = e.filter((c, d) => {
              for (let g = d + 1; g < e.length; g++) if (e[g].indexOf(c) >= 0) return !1;
              return !0;
            });
            const o = e.join(" | ");
            o !== this._attribHTML && (this._attribHTML = o, e.length ? (this._innerContainer.innerHTML = Q.sanitize(o), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class Ju {
          constructor(e = {}) {
            this._updateCompact = () => {
              const n = this._container.children;
              if (n.length) {
                const o = n[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && o.classList.add("maplibregl-compact") : o.classList.remove("maplibregl-compact");
              }
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = Q.create("div", "maplibregl-ctrl");
            const n = Q.create("a", "maplibregl-ctrl-logo");
            return n.target = "_blank", n.rel = "noopener nofollow", n.href = "https://maplibre.org/", n.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), n.setAttribute("rel", "noopener nofollow"), this._container.appendChild(n), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            Q.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Pn {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(e) {
            const n = ++this._id;
            return this._queue.push({ callback: e, id: n, cancelled: !1 }), n;
          }
          remove(e) {
            const n = this._currentlyRunning, o = n ? this._queue.concat(n) : this._queue;
            for (const c of o) if (c.id === e) return void (c.cancelled = !0);
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const n = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const o of n) if (!o.cancelled && (o.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        var Ya = a.aJ([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class nt extends a.E {
          constructor(e) {
            super(), this._lastTilesetChange = we.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
          }
          update(e, n) {
            this.sourceCache.update(e, n), this._renderableTilesKeys = [];
            const o = {};
            for (const c of fe(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: n, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) o[c.key] = !0, this._renderableTilesKeys.push(c.key), this._tiles[c.key] || (c.terrainRttPosMatrix32f = new Float64Array(16), a.bY(c.terrainRttPosMatrix32f, 0, a.$, a.$, 0, 0, 1), this._tiles[c.key] = new Ht(c, this.tileSize), this._lastTilesetChange = we.now());
            for (const c in this._tiles) o[c] || delete this._tiles[c];
          }
          freeRtt(e) {
            for (const n in this._tiles) {
              const o = this._tiles[n];
              (!e || o.tileID.equals(e) || o.tileID.isChildOf(e) || e.isChildOf(o.tileID)) && (o.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e) => this.getTileByID(e));
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          getTerrainCoords(e, n) {
            return n ? this._getTerrainCoordsForTileRanges(e, n) : this._getTerrainCoordsForRegularTile(e);
          }
          _getTerrainCoordsForRegularTile(e) {
            const n = {};
            for (const o of this._renderableTilesKeys) {
              const c = this._tiles[o].tileID, d = e.clone(), g = a.ba();
              if (c.canonical.equals(e.canonical)) a.bY(g, 0, a.$, a.$, 0, 0, 1);
              else if (c.canonical.isChildOf(e.canonical)) {
                const v = c.canonical.z - e.canonical.z, x = c.canonical.x - (c.canonical.x >> v << v), M = c.canonical.y - (c.canonical.y >> v << v), C = a.$ >> v;
                a.bY(g, 0, C, C, 0, 0, 1), a.M(g, g, [-x * C, -M * C, 0]);
              } else {
                if (!e.canonical.isChildOf(c.canonical)) continue;
                {
                  const v = e.canonical.z - c.canonical.z, x = e.canonical.x - (e.canonical.x >> v << v), M = e.canonical.y - (e.canonical.y >> v << v), C = a.$ >> v;
                  a.bY(g, 0, a.$, a.$, 0, 0, 1), a.M(g, g, [x * C, M * C, 0]), a.N(g, g, [1 / 2 ** v, 1 / 2 ** v, 0]);
                }
              }
              d.terrainRttPosMatrix32f = new Float32Array(g), n[o] = d;
            }
            return n;
          }
          _getTerrainCoordsForTileRanges(e, n) {
            const o = {};
            for (const c of this._renderableTilesKeys) {
              const d = this._tiles[c].tileID;
              if (!this._isWithinTileRanges(d, n)) continue;
              const g = e.clone(), v = a.ba();
              if (d.canonical.z === e.canonical.z) {
                const x = e.canonical.x - d.canonical.x, M = e.canonical.y - d.canonical.y;
                a.bY(v, 0, a.$, a.$, 0, 0, 1), a.M(v, v, [x * a.$, M * a.$, 0]);
              } else if (d.canonical.z > e.canonical.z) {
                const x = d.canonical.z - e.canonical.z, M = d.canonical.x - (d.canonical.x >> x << x), C = d.canonical.y - (d.canonical.y >> x << x), k = e.canonical.x - (d.canonical.x >> x), A = e.canonical.y - (d.canonical.y >> x), R = a.$ >> x;
                a.bY(v, 0, R, R, 0, 0, 1), a.M(v, v, [-M * R + k * a.$, -C * R + A * a.$, 0]);
              } else {
                const x = e.canonical.z - d.canonical.z, M = e.canonical.x - (e.canonical.x >> x << x), C = e.canonical.y - (e.canonical.y >> x << x), k = (e.canonical.x >> x) - d.canonical.x, A = (e.canonical.y >> x) - d.canonical.y, R = a.$ << x;
                a.bY(v, 0, R, R, 0, 0, 1), a.M(v, v, [M * a.$ + k * R, C * a.$ + A * R, 0]);
              }
              g.terrainRttPosMatrix32f = new Float32Array(v), o[c] = g;
            }
            return o;
          }
          getSourceTile(e, n) {
            const o = this.sourceCache._source;
            let c = e.overscaledZ - this.deltaZoom;
            if (c > o.maxzoom && (c = o.maxzoom), c < o.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(c).key);
            let d = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!d || !d.dem) && n) for (; c >= o.minzoom && (!d || !d.dem); ) d = this.sourceCache.getTileByID(e.scaledTo(c--).key);
            return d;
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e;
          }
          _isWithinTileRanges(e, n) {
            return n[e.canonical.z] && e.canonical.x >= n[e.canonical.z].minTileX && e.canonical.x <= n[e.canonical.z].maxTileX && e.canonical.y >= n[e.canonical.z].minTileY && e.canonical.y <= n[e.canonical.z].maxTileY;
          }
        }
        class dt {
          constructor(e, n, o) {
            this._meshCache = {}, this.painter = e, this.sourceCache = new nt(n), this.options = o, this.exaggeration = typeof o.exaggeration == "number" ? o.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e, n, o, c = a.$) {
            var d;
            if (!(n >= 0 && n < c && o >= 0 && o < c)) return 0;
            const g = this.getTerrainData(e), v = (d = g.tile) === null || d === void 0 ? void 0 : d.dem;
            if (!v) return 0;
            const x = a.cs([], [n / c * a.$, o / c * a.$], g.u_terrain_matrix), M = [x[0] * v.dim, x[1] * v.dim], C = Math.floor(M[0]), k = Math.floor(M[1]), A = M[0] - C, R = M[1] - k;
            return v.get(C, k) * (1 - A) * (1 - R) + v.get(C + 1, k) * A * (1 - R) + v.get(C, k + 1) * (1 - A) * R + v.get(C + 1, k + 1) * A * R;
          }
          getElevationForLngLatZoom(e, n) {
            if (!a.ct(n, e.wrap())) return 0;
            const { tileID: o, mercatorX: c, mercatorY: d } = this._getOverscaledTileIDFromLngLatZoom(e, n);
            return this.getElevation(o, c % a.$, d % a.$, a.$);
          }
          getElevation(e, n, o, c = a.$) {
            return this.getDEMElevation(e, n, o, c) * this.exaggeration;
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const c = this.painter.context, d = new a.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new a.T(c, d, c.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new a.T(c, new a.R({ width: 1, height: 1 }), c.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(c.gl.NEAREST, c.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = a.ag([]);
            }
            const n = this.sourceCache.getSourceTile(e, !0);
            if (n && n.dem && (!n.demTexture || n.needsTerrainPrepare)) {
              const c = this.painter.context;
              n.demTexture = this.painter.getTileTexture(n.dem.stride), n.demTexture ? n.demTexture.update(n.dem.getPixels(), { premultiply: !1 }) : n.demTexture = new a.T(c, n.dem.getPixels(), c.gl.RGBA, { premultiply: !1 }), n.demTexture.bind(c.gl.NEAREST, c.gl.CLAMP_TO_EDGE), n.needsTerrainPrepare = !1;
            }
            const o = n && n + n.tileID.key + e.key;
            if (o && !this._demMatrixCache[o]) {
              const c = this.sourceCache.sourceCache._source.maxzoom;
              let d = e.canonical.z - n.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= c ? d = e.canonical.z - c : a.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const g = e.canonical.x - (e.canonical.x >> d << d), v = e.canonical.y - (e.canonical.y >> d << d), x = a.cu(new Float64Array(16), [1 / (a.$ << d), 1 / (a.$ << d), 0]);
              a.M(x, x, [g * a.$, v * a.$, 0]), this._demMatrixCache[e.key] = { matrix: x, coord: e };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: n && n.dem && n.dem.dim || 1, u_terrain_matrix: o ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: n && n.dem && n.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (n && n.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: n };
          }
          getFramebuffer(e) {
            const n = this.painter, o = n.width / devicePixelRatio, c = n.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === o && this._fbo.height === c || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new a.T(n.context, { width: o, height: c, data: null }, n.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(n.context.gl.NEAREST, n.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new a.T(n.context, { width: o, height: c, data: null }, n.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(n.context.gl.NEAREST, n.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = n.context.createFramebuffer(o, c, !0, !1), this._fbo.depthAttachment.set(n.context.createRenderbuffer(n.context.gl.DEPTH_COMPONENT16, o, c))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const n = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let d = 0, g = 0; d < this._coordsTextureSize; d++) for (let v = 0; v < this._coordsTextureSize; v++, g += 4) n[g + 0] = 255 & v, n[g + 1] = 255 & d, n[g + 2] = v >> 8 << 4 | d >> 8, n[g + 3] = 0;
            const o = new a.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(n.buffer)), c = new a.T(e, o, e.gl.RGBA, { premultiply: !1 });
            return c.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = c, c;
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const n = new Uint8Array(4), o = this.painter.context, c = o.gl, d = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), g = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), v = Math.round(this.painter.height / devicePixelRatio);
            o.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), c.readPixels(d, v - g - 1, 1, 1, c.RGBA, c.UNSIGNED_BYTE, n), o.bindFramebuffer.set(null);
            const x = n[0] + (n[2] >> 4 << 8), M = n[1] + ((15 & n[2]) << 8), C = this.coordsIndex[255 - n[3]], k = C && this.sourceCache.getTileByID(C);
            if (!k) return null;
            const A = this._coordsTextureSize, R = (1 << k.tileID.canonical.z) * A;
            return new a.a1((k.tileID.canonical.x * A + x) / R + k.tileID.wrap, (k.tileID.canonical.y * A + M) / R, this.getElevation(k.tileID, x, M, A));
          }
          depthAtPoint(e) {
            const n = new Uint8Array(4), o = this.painter.context, c = o.gl;
            return o.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), c.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, c.RGBA, c.UNSIGNED_BYTE, n), o.bindFramebuffer.set(null), (n[0] / 16777216 + n[1] / 65536 + n[2] / 256 + n[3]) / 256;
          }
          getTerrainMesh(e) {
            var n;
            const o = ((n = this.painter.style.projection) === null || n === void 0 ? void 0 : n.transitionState) > 0, c = o && e.canonical.y === 0, d = o && e.canonical.y === (1 << e.canonical.z) - 1, g = `m_${c ? "n" : ""}_${d ? "s" : ""}`;
            if (this._meshCache[g]) return this._meshCache[g];
            const v = this.painter.context, x = new a.cv(), M = new a.aN(), C = this.meshSize, k = a.$ / C, A = C * C;
            for (let Y = 0; Y <= C; Y++) for (let pe = 0; pe <= C; pe++) x.emplaceBack(pe * k, Y * k, 0);
            for (let Y = 0; Y < A; Y += C + 1) for (let pe = 0; pe < C; pe++) M.emplaceBack(pe + Y, C + pe + Y + 1, C + pe + Y + 2), M.emplaceBack(pe + Y, C + pe + Y + 2, pe + Y + 1);
            const R = x.length, O = R + (C + 1), G = (C + 1) * C, Z = c ? a.bh : 0, q = c ? 0 : 1, W = d ? a.bi : a.$, J = d ? 0 : 1;
            for (let Y = 0; Y <= C; Y++) x.emplaceBack(Y * k, Z, q);
            for (let Y = 0; Y <= C; Y++) x.emplaceBack(Y * k, W, J);
            for (let Y = 0; Y < C; Y++) M.emplaceBack(G + Y, O + Y, O + Y + 1), M.emplaceBack(G + Y, O + Y + 1, G + Y + 1), M.emplaceBack(0 + Y, R + Y + 1, R + Y), M.emplaceBack(0 + Y, 0 + Y + 1, R + Y + 1);
            const K = x.length, te = K + 2 * (C + 1);
            for (const Y of [0, 1]) for (let pe = 0; pe <= C; pe++) for (const be of [0, 1]) x.emplaceBack(Y * a.$, pe * k, be);
            for (let Y = 0; Y < 2 * C; Y += 2) M.emplaceBack(K + Y, K + Y + 1, K + Y + 3), M.emplaceBack(K + Y, K + Y + 3, K + Y + 2), M.emplaceBack(te + Y, te + Y + 3, te + Y + 1), M.emplaceBack(te + Y, te + Y + 2, te + Y + 3);
            const se = new ps(v.createVertexBuffer(x, Ya.members), v.createIndexBuffer(M), a.aM.simpleSegment(0, 0, x.length, M.length));
            return this._meshCache[g] = se, se;
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * a.bu / Math.pow(2, Math.max(e, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e, n) {
            var o;
            const { tileID: c } = this._getOverscaledTileIDFromLngLatZoom(e, n);
            return (o = this.getMinMaxElevation(c).minElevation) !== null && o !== void 0 ? o : 0;
          }
          getMinMaxElevation(e) {
            const n = this.getTerrainData(e).tile, o = { minElevation: null, maxElevation: null };
            return n && n.dem && (o.minElevation = n.dem.min * this.exaggeration, o.maxElevation = n.dem.max * this.exaggeration), o;
          }
          _getOverscaledTileIDFromLngLatZoom(e, n) {
            const o = a.a1.fromLngLat(e.wrap()), c = (1 << n) * a.$, d = o.x * c, g = o.y * c, v = Math.floor(d / a.$), x = Math.floor(g / a.$);
            return { tileID: new a.Z(n, 0, n, v, x), mercatorX: d, mercatorY: g };
          }
        }
        class Ja {
          constructor(e, n, o) {
            this._context = e, this._size = n, this._tileSize = o, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
          }
          _createObject(e) {
            const n = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), o = new a.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return o.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), n.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), n.colorAttachment.set(o.texture), { id: e, fbo: n, texture: o, stamp: -1, inUse: !1 };
          }
          getObjectForId(e) {
            return this._objects[e];
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((n) => e.id !== n), this._recentlyUsed.push(e.id);
          }
          stampObject(e) {
            e.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const n of this._recentlyUsed) if (!this._objects[n].inUse) return this._objects[n];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e;
          }
          freeObject(e) {
            e.inUse = !1;
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e) => !e.inUse) === !1;
          }
        }
        const Kn = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0, "color-relief": !0 };
        class Qa {
          constructor(e, n) {
            this.painter = e, this.terrain = n, this.pool = new Ja(e.context, 30, n.sourceCache.tileSize * n.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(e, n) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((o) => !e._layers[o].isHidden(n)), this._coordsAscending = {};
            for (const o in e.sourceCaches) {
              this._coordsAscending[o] = {};
              const c = e.sourceCaches[o].getVisibleCoordinates(), d = e.sourceCaches[o].getSource(), g = d instanceof Ue ? d.terrainTileRanges : null;
              for (const v of c) {
                const x = this.terrain.sourceCache.getTerrainCoords(v, g);
                for (const M in x) this._coordsAscending[o][M] || (this._coordsAscending[o][M] = []), this._coordsAscending[o][M].push(x[M]);
              }
            }
            this._coordsAscendingStr = {};
            for (const o of e._order) {
              const c = e._layers[o], d = c.source;
              if (Kn[c.type] && !this._coordsAscendingStr[d]) {
                this._coordsAscendingStr[d] = {};
                for (const g in this._coordsAscending[d]) this._coordsAscendingStr[d][g] = this._coordsAscending[d][g].map((v) => v.key).sort().join();
              }
            }
            for (const o of this._renderableTiles) for (const c in this._coordsAscendingStr) {
              const d = this._coordsAscendingStr[c][o.tileID.key];
              d && d !== o.rttCoords[c] && (o.rtt = []);
            }
          }
          renderLayer(e, n) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const o = Object.assign(Object.assign({}, n), { isRenderingToTexture: !0 }), c = e.type, d = this.painter, g = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (Kn[c] && (this._prevType && Kn[this._prevType] || this._stacks.push([]), this._prevType = c, this._stacks[this._stacks.length - 1].push(e.id), !g)) return !0;
            if (Kn[this._prevType] || Kn[c] && g) {
              this._prevType = c;
              const v = this._stacks.length - 1, x = this._stacks[v] || [];
              for (const M of this._renderableTiles) {
                if (this.pool.isFull() && (Ga(this.painter, this.terrain, this._rttTiles, o), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(M), M.rtt[v]) {
                  const k = this.pool.getObjectForId(M.rtt[v].id);
                  if (k.stamp === M.rtt[v].stamp) {
                    this.pool.useObject(k);
                    continue;
                  }
                }
                const C = this.pool.getOrCreateFreeObject();
                this.pool.useObject(C), this.pool.stampObject(C), M.rtt[v] = { id: C.id, stamp: C.stamp }, d.context.bindFramebuffer.set(C.fbo.framebuffer), d.context.clear({ color: a.bf.transparent, stencil: 0 }), d.currentStencilSource = void 0;
                for (let k = 0; k < x.length; k++) {
                  const A = d.style._layers[x[k]], R = A.source ? this._coordsAscending[A.source][M.tileID.key] : [M.tileID];
                  d.context.viewport.set([0, 0, C.fbo.width, C.fbo.height]), d._renderTileClippingMasks(A, R, !0), d.renderLayer(d, d.style.sourceCaches[A.source], A, R, o), A.source && (M.rttCoords[A.source] = this._coordsAscendingStr[A.source][M.tileID.key]);
                }
              }
              return Ga(this.painter, this.terrain, this._rttTiles, o), this._rttTiles = [], this.pool.freeAllObjects(), Kn[c];
            }
            return !1;
          }
        }
        const br = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Qu = U, Kr = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: xc, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: a.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0 }, Ad = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
        class Jo {
          constructor(e, n, o = !1) {
            this.mousedown = (d) => {
              this.startMove(d, Q.mousePos(this.element, d)), Q.addEventListener(window, "mousemove", this.mousemove), Q.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (d) => {
              this.move(d, Q.mousePos(this.element, d));
            }, this.mouseup = (d) => {
              this._rotatePitchHandler.dragEnd(d), this.offTemp();
            }, this.touchstart = (d) => {
              d.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = Q.touchPos(this.element, d.targetTouches)[0], this.startMove(d, this._startPos), Q.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), Q.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (d) => {
              d.targetTouches.length !== 1 ? this.reset() : (this._lastPos = Q.touchPos(this.element, d.targetTouches)[0], this.move(d, this._lastPos));
            }, this.touchend = (d) => {
              d.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = n;
            const c = new Cd();
            this._rotatePitchHandler = new ro({ clickTolerance: 3, move: (d, g) => {
              const v = n.getBoundingClientRect(), x = new a.P((v.bottom - v.top) / 2, (v.right - v.left) / 2);
              return { bearingDelta: a.cn(new a.P(d.x, g.y), g, x), pitchDelta: o ? -0.5 * (g.y - d.y) : void 0 };
            }, moveStateManager: c, enable: !0, assignEvents: () => {
            } }), this.map = e, Q.addEventListener(n, "mousedown", this.mousedown), Q.addEventListener(n, "touchstart", this.touchstart, { passive: !1 }), Q.addEventListener(n, "touchcancel", this.reset);
          }
          startMove(e, n) {
            this._rotatePitchHandler.dragStart(e, n), Q.disableDrag();
          }
          move(e, n) {
            const o = this.map, { bearingDelta: c, pitchDelta: d } = this._rotatePitchHandler.dragMove(e, n) || {};
            c && o.setBearing(o.getBearing() + c), d && o.setPitch(o.getPitch() + d);
          }
          off() {
            const e = this.element;
            Q.removeEventListener(e, "mousedown", this.mousedown), Q.removeEventListener(e, "touchstart", this.touchstart, { passive: !1 }), Q.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), Q.removeEventListener(window, "touchend", this.touchend), Q.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            Q.enableDrag(), Q.removeEventListener(window, "mousemove", this.mousemove), Q.removeEventListener(window, "mouseup", this.mouseup), Q.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), Q.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let ii;
        function Pi(h, e, n, o = !1) {
          if (o || !n.getCoveringTilesDetailsProvider().allowWorldCopies()) return h == null ? void 0 : h.wrap();
          const c = new a.S(h.lng, h.lat);
          if (h = new a.S(h.lng, h.lat), e) {
            const d = new a.S(h.lng - 360, h.lat), g = new a.S(h.lng + 360, h.lat), v = n.locationToScreenPoint(h).distSqr(e);
            n.locationToScreenPoint(d).distSqr(e) < v ? h = d : n.locationToScreenPoint(g).distSqr(e) < v && (h = g);
          }
          for (; Math.abs(h.lng - n.center.lng) > 180; ) {
            const d = n.locationToScreenPoint(h);
            if (d.x >= 0 && d.y >= 0 && d.x <= n.width && d.y <= n.height) break;
            h.lng > n.center.lng ? h.lng -= 360 : h.lng += 360;
          }
          return h.lng !== c.lng && n.isPointOnMapSurface(n.locationToScreenPoint(h)) ? h : c;
        }
        const el = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function ao(h, e, n) {
          const o = h.classList;
          for (const c in el) o.remove(`maplibregl-${n}-anchor-${c}`);
          o.add(`maplibregl-${n}-anchor-${e}`);
        }
        class lo extends a.E {
          constructor(e) {
            if (super(), this._onKeyPress = (n) => {
              const o = n.code, c = n.charCode || n.keyCode;
              o !== "Space" && o !== "Enter" && c !== 32 && c !== 13 || this.togglePopup();
            }, this._onMapClick = (n) => {
              const o = n.originalEvent.target, c = this._element;
              this._popup && (o === c || c.contains(o)) && this.togglePopup();
            }, this._update = (n) => {
              if (!this._map) return;
              const o = this._map.loaded() && !this._map.isMoving();
              ((n == null ? void 0 : n.type) === "terrain" || (n == null ? void 0 : n.type) === "render" && !o) && this._map.once("render", this._update), this._lngLat = Pi(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let c = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? c = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (c = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let d = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? d = "rotateX(0deg)" : this._pitchAlignment === "map" && (d = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || n && n.type !== "moveend" || (this._pos = this._pos.round()), Q.setTransform(this._element, `${el[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${d} ${c}`), we.frameAsync(new AbortController()).then(() => {
                this._updateOpacity(n && n.type === "moveend");
              }).catch(() => {
              });
            }, this._onMove = (n) => {
              if (!this._isDragging) {
                const o = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = n.point.dist(this._pointerdownPos) >= o;
              }
              this._isDragging && (this._pos = n.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new a.l("dragstart"))), this.fire(new a.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new a.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (n) => {
              this._element.contains(n.originalEvent.target) && (n.preventDefault(), this._positionDelta = n.point.sub(this._pos).add(this._offset), this._pointerdownPos = n.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = a.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = Q.create("div");
              const n = Q.createNS("http://www.w3.org/2000/svg", "svg"), o = 41, c = 27;
              n.setAttributeNS(null, "display", "block"), n.setAttributeNS(null, "height", `${o}px`), n.setAttributeNS(null, "width", `${c}px`), n.setAttributeNS(null, "viewBox", `0 0 ${c} ${o}`);
              const d = Q.createNS("http://www.w3.org/2000/svg", "g");
              d.setAttributeNS(null, "stroke", "none"), d.setAttributeNS(null, "stroke-width", "1"), d.setAttributeNS(null, "fill", "none"), d.setAttributeNS(null, "fill-rule", "evenodd");
              const g = Q.createNS("http://www.w3.org/2000/svg", "g");
              g.setAttributeNS(null, "fill-rule", "nonzero");
              const v = Q.createNS("http://www.w3.org/2000/svg", "g");
              v.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), v.setAttributeNS(null, "fill", "#000000");
              const x = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const q of x) {
                const W = Q.createNS("http://www.w3.org/2000/svg", "ellipse");
                W.setAttributeNS(null, "opacity", "0.04"), W.setAttributeNS(null, "cx", "10.5"), W.setAttributeNS(null, "cy", "5.80029008"), W.setAttributeNS(null, "rx", q.rx), W.setAttributeNS(null, "ry", q.ry), v.appendChild(W);
              }
              const M = Q.createNS("http://www.w3.org/2000/svg", "g");
              M.setAttributeNS(null, "fill", this._color);
              const C = Q.createNS("http://www.w3.org/2000/svg", "path");
              C.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), M.appendChild(C);
              const k = Q.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "opacity", "0.25"), k.setAttributeNS(null, "fill", "#000000");
              const A = Q.createNS("http://www.w3.org/2000/svg", "path");
              A.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), k.appendChild(A);
              const R = Q.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), R.setAttributeNS(null, "fill", "#FFFFFF");
              const O = Q.createNS("http://www.w3.org/2000/svg", "g");
              O.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const G = Q.createNS("http://www.w3.org/2000/svg", "circle");
              G.setAttributeNS(null, "fill", "#000000"), G.setAttributeNS(null, "opacity", "0.25"), G.setAttributeNS(null, "cx", "5.5"), G.setAttributeNS(null, "cy", "5.5"), G.setAttributeNS(null, "r", "5.4999962");
              const Z = Q.createNS("http://www.w3.org/2000/svg", "circle");
              Z.setAttributeNS(null, "fill", "#FFFFFF"), Z.setAttributeNS(null, "cx", "5.5"), Z.setAttributeNS(null, "cy", "5.5"), Z.setAttributeNS(null, "r", "5.4999962"), O.appendChild(G), O.appendChild(Z), g.appendChild(v), g.appendChild(M), g.appendChild(k), g.appendChild(R), g.appendChild(O), n.appendChild(g), n.setAttributeNS(null, "height", o * this._scale + "px"), n.setAttributeNS(null, "width", c * this._scale + "px"), this._element.appendChild(n), this._offset = a.P.convert(e && e.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (n) => {
              n.preventDefault();
            }), this._element.addEventListener("mousedown", (n) => {
              n.preventDefault();
            }), ao(this._element, this._anchor, "marker"), e && e.className) for (const n of e.className.split(" ")) this._element.classList.add(n);
            this._popup = null;
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), Q.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return this._lngLat = a.S.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const c = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [c, -1 * (38.1 - 13.5 + c)], "bottom-right": [-c, -1 * (38.1 - 13.5 + c)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
          }
          _updateOpacity(e = !1) {
            var n, o;
            const c = (n = this._map) === null || n === void 0 ? void 0 : n.terrain, d = this._map.transform.isLocationOccluded(this._lngLat);
            if (!c || d) {
              const R = d ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== R && (this._element.style.opacity = R));
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout(() => {
                this._opacityTimeout = null;
              }, 100);
            }
            const g = this._map, v = g.terrain.depthAtPoint(this._pos), x = g.terrain.getElevationForLngLatZoom(this._lngLat, g.transform.tileZoom);
            if (g.transform.lngLatToCameraDepth(this._lngLat, x) - v < 6e-3) return void (this._element.style.opacity = this._opacity);
            const M = -this._offset.y / g.transform.pixelsPerMeter, C = Math.sin(g.getPitch() * Math.PI / 180) * M, k = g.terrain.depthAtPoint(new a.P(this._pos.x, this._pos.y - this._offset.y)), A = g.transform.lngLatToCameraDepth(this._lngLat, x + C) - k > 6e-3;
            !((o = this._popup) === null || o === void 0) && o.isOpen() && A && this._popup.remove(), this._element.style.opacity = A ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e) {
            return this._offset = a.P.convert(e), this._update(), this;
          }
          addClassName(e) {
            this._element.classList.add(e);
          }
          removeClassName(e) {
            this._element.classList.remove(e);
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e);
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e, n) {
            return (this._opacity === void 0 || e === void 0 && n === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), n !== void 0 && (this._opacityWhenCovered = n), this._map && this._updateOpacity(!0), this;
          }
        }
        const wc = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
        let co = 0, Is = !1;
        const Qo = { maxWidth: 100, unit: "metric" };
        function tl(h, e, n) {
          const o = n && n.maxWidth || 100, c = h._container.clientHeight / 2, d = h._container.clientWidth / 2, g = h.unproject([d - o / 2, c]), v = h.unproject([d + o / 2, c]), x = Math.round(h.project(v).x - h.project(g).x), M = Math.min(o, x, h._container.clientWidth), C = g.distanceTo(v);
          if (n && n.unit === "imperial") {
            const k = 3.2808 * C;
            k > 5280 ? Es(e, M, k / 5280, h._getUIString("ScaleControl.Miles")) : Es(e, M, k, h._getUIString("ScaleControl.Feet"));
          } else n && n.unit === "nautical" ? Es(e, M, C / 1852, h._getUIString("ScaleControl.NauticalMiles")) : C >= 1e3 ? Es(e, M, C / 1e3, h._getUIString("ScaleControl.Kilometers")) : Es(e, M, C, h._getUIString("ScaleControl.Meters"));
        }
        function Es(h, e, n, o) {
          const c = function(d) {
            const g = Math.pow(10, `${Math.floor(d)}`.length - 1);
            let v = d / g;
            return v = v >= 10 ? 10 : v >= 5 ? 5 : v >= 3 ? 3 : v >= 2 ? 2 : v >= 1 ? 1 : function(x) {
              const M = Math.pow(10, Math.ceil(-Math.log(x) / Math.LN10));
              return Math.round(x * M) / M;
            }(v), g * v;
          }(n);
          h.style.width = e * (c / n) + "px", h.innerHTML = `${c}&nbsp;${o}`;
        }
        const Tc = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0 }, Sc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function il(h) {
          if (h) {
            if (typeof h == "number") {
              const e = Math.round(Math.abs(h) / Math.SQRT2);
              return { center: new a.P(0, 0), top: new a.P(0, h), "top-left": new a.P(e, e), "top-right": new a.P(-e, e), bottom: new a.P(0, -h), "bottom-left": new a.P(e, -e), "bottom-right": new a.P(-e, -e), left: new a.P(h, 0), right: new a.P(-h, 0) };
            }
            if (h instanceof a.P || Array.isArray(h)) {
              const e = a.P.convert(h);
              return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
            }
            return { center: a.P.convert(h.center || [0, 0]), top: a.P.convert(h.top || [0, 0]), "top-left": a.P.convert(h["top-left"] || [0, 0]), "top-right": a.P.convert(h["top-right"] || [0, 0]), bottom: a.P.convert(h.bottom || [0, 0]), "bottom-left": a.P.convert(h["bottom-left"] || [0, 0]), "bottom-right": a.P.convert(h["bottom-right"] || [0, 0]), left: a.P.convert(h.left || [0, 0]), right: a.P.convert(h.right || [0, 0]) };
          }
          return il(new a.P(0, 0));
        }
        const Pc = U;
        T.AJAXError = a.cz, T.Event = a.l, T.Evented = a.E, T.LngLat = a.S, T.MercatorCoordinate = a.a1, T.Point = a.P, T.addProtocol = a.cA, T.config = a.a, T.removeProtocol = a.cB, T.AttributionControl = bc, T.BoxZoomHandler = pc, T.CanvasSource = De, T.CooperativeGesturesHandler = Ku, T.DoubleClickZoomHandler = gc, T.DragPanHandler = Wu, T.DragRotateHandler = yc, T.EdgeInsets = ms, T.FullscreenControl = class extends a.E {
          constructor(h = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let n = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = n == null ? void 0 : n.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) n = n.shadowRoot.fullscreenElement;
              n === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = !1, h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : a.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(h) {
            return this._map = h, this._container || (this._container = this._map.getContainer()), this._controlContainer = Q.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            Q.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const h = this._fullscreenButton = Q.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            Q.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"), h.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const h = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", h), this._fullscreenButton.title = h;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new a.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new a.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, T.GeoJSONSource = He, T.GeolocateControl = class extends a.E {
          constructor(h) {
            super(), this._onSuccess = (e) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new a.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new a.l("geolocate", e)), this._finish();
              }
            }, this._updateCamera = (e) => {
              const n = new a.S(e.coords.longitude, e.coords.latitude), o = e.coords.accuracy, c = this._map.getBearing(), d = a.e({ bearing: c }, this.options.fitBoundsOptions), g = ae.fromLngLat(n, o);
              this._map.fitBounds(g, d, { geolocateSource: !0 });
            }, this._updateMarker = (e) => {
              if (e) {
                const n = new a.S(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(n).addTo(this._map), this._userLocationDotMarker.setLngLat(n).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded();
            }, this._onError = (e) => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (e.code === 3 && Is) return;
                  this.options.trackUserLocation && this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new a.l("error", e)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this._geolocateButton = Q.create("button", "maplibregl-ctrl-geolocate", this._container), Q.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
            }, this._finishSetupUI = (e) => {
              if (this._map) {
                if (e === !1) {
                  a.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
                } else {
                  const n = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = Q.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new lo({ element: this._dotElement }), this._circleElement = Q.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new lo({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (n) => {
                  const o = (n == null ? void 0 : n[0]) instanceof ResizeObserverEntry;
                  n.geolocateSource || this._watchState !== "ACTIVE_LOCK" || o || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new a.l("trackuserlocationend")), this.fire(new a.l("userlocationlostfocus")));
                });
              }
            }, this.options = a.e({}, wc, h);
          }
          onAdd(h) {
            return this._map = h, this._container = Q.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
              return a._(this, arguments, void 0, function* (e = !1) {
                if (ii !== void 0 && !e) return ii;
                if (window.navigator.permissions === void 0) return ii = !!window.navigator.geolocation, ii;
                try {
                  ii = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  ii = !!window.navigator.geolocation;
                }
                return ii;
              });
            }().then((e) => this._finishSetupUI(e)), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), Q.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, co = 0, Is = !1;
          }
          _isOutOfMapMaxBounds(h) {
            const e = this._map.getMaxBounds(), n = h.coords;
            return e && (n.longitude < e.getWest() || n.longitude > e.getEast() || n.latitude < e.getSouth() || n.latitude > e.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const h = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && h)) return;
            const e = this._map.project(h), n = this._map.unproject([e.x + 100, e.y]), o = h.distanceTo(n) / 100, c = 2 * this._accuracy / o;
            this._circleElement.style.width = `${c.toFixed(2)}px`, this._circleElement.style.height = `${c.toFixed(2)}px`;
          }
          trigger() {
            if (!this._setup) return a.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new a.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  co--, Is = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new a.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new a.l("trackuserlocationstart")), this.fire(new a.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let h;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), co++, co > 1 ? (h = { maximumAge: 6e5, timeout: 0 }, Is = !0) : (h = this.options.positionOptions, Is = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, T.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var h;
              const e = (h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type;
              this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var h;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(h) {
            return this._map = h, this._container = Q.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = Q.create("button", "maplibregl-ctrl-globe", this._container), Q.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            Q.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, T.Hash = qa, T.ImageSource = Ue, T.KeyboardHandler = Xa, T.LngLatBounds = ae, T.LogoControl = Ju, T.Map = class extends Yu {
          constructor(h) {
            var e, n;
            a.cw.mark(a.cx.create);
            const o = Object.assign(Object.assign(Object.assign({}, Kr), h), { canvasContextAttributes: Object.assign(Object.assign({}, Kr.canvasContextAttributes), h.canvasContextAttributes) });
            if (o.minZoom != null && o.maxZoom != null && o.minZoom > o.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (o.minPitch != null && o.maxPitch != null && o.minPitch > o.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (o.minPitch != null && o.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (o.maxPitch != null && o.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const c = new oi(), d = new dr();
            if (o.minZoom !== void 0 && c.setMinZoom(o.minZoom), o.maxZoom !== void 0 && c.setMaxZoom(o.maxZoom), o.minPitch !== void 0 && c.setMinPitch(o.minPitch), o.maxPitch !== void 0 && c.setMaxPitch(o.maxPitch), o.renderWorldCopies !== void 0 && c.setRenderWorldCopies(o.renderWorldCopies), super(c, d, { bearingSnap: o.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Pn(), this._controls = [], this._mapId = a.a7(), this._contextLost = (v) => {
              v.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new a.l("webglcontextlost", { originalEvent: v }));
            }, this._contextRestored = (v) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new a.l("webglcontextrestored", { originalEvent: v }));
            }, this._onMapScroll = (v) => {
              if (v.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = o.interactive, this._maxTileCacheSize = o.maxTileCacheSize, this._maxTileCacheZoomLevels = o.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, o.canvasContextAttributes), this._trackResize = o.trackResize === !0, this._bearingSnap = o.bearingSnap, this._centerClampedToGround = o.centerClampedToGround, this._refreshExpiredTiles = o.refreshExpiredTiles === !0, this._fadeDuration = o.fadeDuration, this._crossSourceCollisions = o.crossSourceCollisions === !0, this._collectResourceTiming = o.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, br), o.locale), this._clickTolerance = o.clickTolerance, this._overridePixelRatio = o.pixelRatio, this._maxCanvasSize = o.maxCanvasSize, this.transformCameraUpdate = o.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = o.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Qe.addThrottleControl(() => this.isMoving()), this._requestManager = new It(o.transformRequest), typeof o.container == "string") {
              if (this._container = document.getElementById(o.container), !this._container) throw new Error(`Container '${o.container}' not found.`);
            } else {
              if (!(o.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = o.container;
            }
            if (o.maxBounds && this.setMaxBounds(o.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            }), this.once("idle", () => {
              this._idleTriggered = !0;
            }), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let v = !1;
              const x = Ms((M) => {
                this._trackResize && !this._removed && (this.resize(M), this.redraw());
              }, 50);
              this._resizeObserver = new ResizeObserver((M) => {
                v ? x(M) : v = !0;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new vc(this, o), this._hash = o.hash && new qa(typeof o.hash == "string" && o.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: o.center, elevation: o.elevation, zoom: o.zoom, bearing: o.bearing, pitch: o.pitch, roll: o.roll }), o.bounds && (this.resize(), this.fitBounds(o.bounds, a.e({}, o.fitBoundsOptions, { duration: 0 }))));
            const g = typeof o.style == "string" || ((n = (e = o.style) === null || e === void 0 ? void 0 : e.projection) === null || n === void 0 ? void 0 : n.type) !== "globe";
            this.resize(null, g), this._localIdeographFontFamily = o.localIdeographFontFamily, this._validateStyle = o.validateStyle, o.style && this.setStyle(o.style, { localIdeographFontFamily: o.localIdeographFontFamily }), o.attributionControl && this.addControl(new bc(typeof o.attributionControl == "boolean" ? void 0 : o.attributionControl)), o.maplibreLogo && this.addControl(new Ju(), o.logoPosition), this.on("style.load", () => {
              if (g || this._resizeTransform(), this.transform.unmodified) {
                const v = a.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(v);
              }
            }), this.on("data", (v) => {
              this._update(v.dataType === "style"), this.fire(new a.l(`${v.dataType}data`, v));
            }), this.on("dataloading", (v) => {
              this.fire(new a.l(`${v.dataType}dataloading`, v));
            }), this.on("dataabort", (v) => {
              this.fire(new a.l("sourcedataabort", v));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(h, e) {
            return this.style.setGlobalStateProperty(h, e), this._update(!0);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(h, e) {
            if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"), !h || !h.onAdd) return this.fire(new a.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const n = h.onAdd(this);
            this._controls.push(h);
            const o = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? o.insertBefore(n, o.firstChild) : o.appendChild(n), this;
          }
          removeControl(h) {
            if (!h || !h.onRemove) return this.fire(new a.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(h);
            return e > -1 && this._controls.splice(e, 1), h.onRemove(this), this;
          }
          hasControl(h) {
            return this._controls.indexOf(h) > -1;
          }
          coveringTiles(h) {
            return fe(this.transform, h);
          }
          calculateCameraOptionsFromTo(h, e, n, o) {
            return o == null && this.terrain && (o = this.terrain.getElevationForLngLatZoom(n, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(h, e, n, o);
          }
          resize(h, e = !0) {
            const [n, o] = this._containerDimensions(), c = this._getClampedPixelRatio(n, o);
            if (this._resizeCanvas(n, o, c), this.painter.resize(n, o, c), this.painter.overLimit()) {
              const g = this.painter.context.gl;
              this._maxCanvasSize = [g.drawingBufferWidth, g.drawingBufferHeight];
              const v = this._getClampedPixelRatio(n, o);
              this._resizeCanvas(n, o, v), this.painter.resize(n, o, v);
            }
            this._resizeTransform(e);
            const d = !this._moving;
            return d && (this.stop(), this.fire(new a.l("movestart", h)).fire(new a.l("move", h))), this.fire(new a.l("resize", h)), d && this.fire(new a.l("moveend", h)), this;
          }
          _resizeTransform(h = !0) {
            var e;
            const [n, o] = this._containerDimensions();
            this.transform.resize(n, o, h), (e = this._requestedCameraState) === null || e === void 0 || e.resize(n, o, h);
          }
          _getClampedPixelRatio(h, e) {
            const { 0: n, 1: o } = this._maxCanvasSize, c = this.getPixelRatio(), d = h * c, g = e * c;
            return Math.min(d > n ? n / d : 1, g > o ? o / g : 1) * c;
          }
          getPixelRatio() {
            var h;
            return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio;
          }
          setPixelRatio(h) {
            this._overridePixelRatio = h, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(h) {
            return this.transform.setMaxBounds(ae.convert(h)), this._update();
          }
          setMinZoom(h) {
            if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom) return this.transform.setMinZoom(h), this._update(), this.getZoom() < h && this.setZoom(h), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(h) {
            if ((h = h ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(h), this._update(), this.getZoom() > h && this.setZoom(h), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(h) {
            if ((h = h ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (h >= 0 && h <= this.transform.maxPitch) return this.transform.setMinPitch(h), this._update(), this.getPitch() < h && this.setPitch(h), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(h) {
            if ((h = h ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (h >= this.transform.minPitch) return this.transform.setMaxPitch(h), this._update(), this.getPitch() > h && this.setPitch(h), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(h) {
            return this.transform.setRenderWorldCopies(h), this._update();
          }
          project(h) {
            return this.transform.locationToScreenPoint(a.S.convert(h), this.style && this.terrain);
          }
          unproject(h) {
            return this.transform.screenPointToLocation(a.P.convert(h), this.terrain);
          }
          isMoving() {
            var h;
            return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving());
          }
          isZooming() {
            var h;
            return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming());
          }
          isRotating() {
            var h;
            return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating());
          }
          _createDelegatedListener(h, e, n) {
            if (h === "mouseenter" || h === "mouseover") {
              let o = !1;
              return { layers: e, listener: n, delegates: { mousemove: (d) => {
                const g = e.filter((x) => this.getLayer(x)), v = g.length !== 0 ? this.queryRenderedFeatures(d.point, { layers: g }) : [];
                v.length ? o || (o = !0, n.call(this, new Ir(h, this, d.originalEvent, { features: v }))) : o = !1;
              }, mouseout: () => {
                o = !1;
              } } };
            }
            if (h === "mouseleave" || h === "mouseout") {
              let o = !1;
              return { layers: e, listener: n, delegates: { mousemove: (g) => {
                const v = e.filter((x) => this.getLayer(x));
                (v.length !== 0 ? this.queryRenderedFeatures(g.point, { layers: v }) : []).length ? o = !0 : o && (o = !1, n.call(this, new Ir(h, this, g.originalEvent)));
              }, mouseout: (g) => {
                o && (o = !1, n.call(this, new Ir(h, this, g.originalEvent)));
              } } };
            }
            {
              const o = (c) => {
                const d = e.filter((v) => this.getLayer(v)), g = d.length !== 0 ? this.queryRenderedFeatures(c.point, { layers: d }) : [];
                g.length && (c.features = g, n.call(this, c), delete c.features);
              };
              return { layers: e, listener: n, delegates: { [h]: o } };
            }
          }
          _saveDelegatedListener(h, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[h] = this._delegatedListeners[h] || [], this._delegatedListeners[h].push(e);
          }
          _removeDelegatedListener(h, e, n) {
            if (!this._delegatedListeners || !this._delegatedListeners[h]) return;
            const o = this._delegatedListeners[h];
            for (let c = 0; c < o.length; c++) {
              const d = o[c];
              if (d.listener === n && d.layers.length === e.length && d.layers.every((g) => e.includes(g))) {
                for (const g in d.delegates) this.off(g, d.delegates[g]);
                return void o.splice(c, 1);
              }
            }
          }
          on(h, e, n) {
            if (n === void 0) return super.on(h, e);
            const o = typeof e == "string" ? [e] : e, c = this._createDelegatedListener(h, o, n);
            this._saveDelegatedListener(h, c);
            for (const d in c.delegates) this.on(d, c.delegates[d]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(h, o, n);
            } };
          }
          once(h, e, n) {
            if (n === void 0) return super.once(h, e);
            const o = typeof e == "string" ? [e] : e, c = this._createDelegatedListener(h, o, n);
            for (const d in c.delegates) {
              const g = c.delegates[d];
              c.delegates[d] = (...v) => {
                this._removeDelegatedListener(h, o, n), g(...v);
              };
            }
            this._saveDelegatedListener(h, c);
            for (const d in c.delegates) this.once(d, c.delegates[d]);
            return this;
          }
          off(h, e, n) {
            return n === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, n), this);
          }
          queryRenderedFeatures(h, e) {
            if (!this.style) return [];
            let n;
            const o = h instanceof a.P || Array.isArray(h), c = o ? h : [[0, 0], [this.transform.width, this.transform.height]];
            if (e = e || (o ? {} : h) || {}, c instanceof a.P || typeof c[0] == "number") n = [a.P.convert(c)];
            else {
              const d = a.P.convert(c[0]), g = a.P.convert(c[1]);
              n = [d, new a.P(g.x, d.y), g, new a.P(d.x, g.y), d];
            }
            return this.style.queryRenderedFeatures(n, e, this.transform);
          }
          querySourceFeatures(h, e) {
            return this.style.querySourceFeatures(h, e);
          }
          setStyle(h, e) {
            return (e = a.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(h, e));
          }
          setTransformRequest(h) {
            return this._requestManager.setTransformRequest(h), this;
          }
          _getUIString(h) {
            const e = this._locale[h];
            if (e == null) throw new Error(`Missing UI string '${h}'`);
            return e;
          }
          _updateStyle(h, e) {
            var n, o;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(h, e));
            const c = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!h)), h ? (this.style = new $l(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof h == "string" ? this.style.loadURL(h, e, c) : this.style.loadJSON(h, e, c), this) : ((o = (n = this.style) === null || n === void 0 ? void 0 : n.projection) === null || o === void 0 || o.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new $l(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(h, e) {
            if (typeof h == "string") {
              const n = this._requestManager.transformRequest(h, "Style");
              a.j(n, new AbortController()).then((o) => {
                this._updateDiff(o.data, e);
              }).catch((o) => {
                o && this.fire(new a.k(o));
              });
            } else typeof h == "object" && this._updateDiff(h, e);
          }
          _updateDiff(h, e) {
            try {
              this.style.setState(h, e) && this._update(!0);
            } catch (n) {
              a.w(`Unable to perform style diff: ${n.message || n.error || n}.  Rebuilding the style from scratch.`), this._updateStyle(h, e);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : a.w("There is no style added to the map.");
          }
          addSource(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(h, e), this._update(!0);
          }
          isSourceLoaded(h) {
            const e = this.style && this.style.sourceCaches[h];
            if (e !== void 0) return e.loaded();
            this.fire(new a.k(new Error(`There is no source with ID '${h}'`)));
          }
          setTerrain(h) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), h) {
              const e = this.style.sourceCaches[h.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
              this.terrain === null && e.reload();
              for (const n in this.style._layers) {
                const o = this.style._layers[n];
                o.type === "hillshade" && o.source === h.source && a.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), o.type === "color-relief" && o.source === h.source && a.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new dt(this.painter, e, h), this.painter.renderToTexture = new Qa(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (n) => {
                var o;
                n.dataType === "style" ? this.terrain.sourceCache.freeRtt() : n.dataType === "source" && n.tile && (n.sourceId !== h.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((o = n.source) === null || o === void 0 ? void 0 : o.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(n.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new a.l("terrain", { terrain: h })), this;
          }
          getTerrain() {
            var h, e;
            return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null;
          }
          areTilesLoaded() {
            const h = this.style && this.style.sourceCaches;
            for (const e in h) {
              const n = h[e]._tiles;
              for (const o in n) {
                const c = n[o];
                if (c.state !== "loaded" && c.state !== "errored") return !1;
              }
            }
            return !0;
          }
          removeSource(h) {
            return this.style.removeSource(h), this._update(!0);
          }
          getSource(h) {
            return this.style.getSource(h);
          }
          setSourceTileLodParams(h, e, n) {
            if (n) {
              const o = this.getSource(n);
              if (!o) throw new Error(`There is no source with ID "${n}", cannot set LOD parameters`);
              o.calculateTileZoom = ke(Math.max(1, h), Math.max(1, e));
            } else for (const o in this.style.sourceCaches) this.style.sourceCaches[o].getSource().calculateTileZoom = ke(Math.max(1, h), Math.max(1, e));
            return this._update(!0), this;
          }
          refreshTiles(h, e) {
            const n = this.style.sourceCaches[h];
            if (!n) throw new Error(`There is no source cache with ID "${h}", cannot refresh tile`);
            e === void 0 ? n.reload(!0) : n.refreshTiles(e.map((o) => new a.a4(o.z, o.x, o.y)));
          }
          addImage(h, e, n = {}) {
            const { pixelRatio: o = 1, sdf: c = !1, stretchX: d, stretchY: g, content: v, textFitWidth: x, textFitHeight: M } = n;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || a.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new a.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: C, height: k, data: A } = e, R = e;
                return this.style.addImage(h, { data: new a.R({ width: C, height: k }, new Uint8Array(A)), pixelRatio: o, stretchX: d, stretchY: g, content: v, textFitWidth: x, textFitHeight: M, sdf: c, version: 0, userImage: R }), R.onAdd && R.onAdd(this, h), this;
              }
            }
            {
              const { width: C, height: k, data: A } = we.getImageData(e);
              this.style.addImage(h, { data: new a.R({ width: C, height: k }, A), pixelRatio: o, stretchX: d, stretchY: g, content: v, textFitWidth: x, textFitHeight: M, sdf: c, version: 0 });
            }
          }
          updateImage(h, e) {
            const n = this.style.getImage(h);
            if (!n) return this.fire(new a.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const o = e instanceof HTMLImageElement || a.b(e) ? we.getImageData(e) : e, { width: c, height: d, data: g } = o;
            if (c === void 0 || d === void 0) return this.fire(new a.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (c !== n.data.width || d !== n.data.height) return this.fire(new a.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const v = !(e instanceof HTMLImageElement || a.b(e));
            return n.data.replace(g, v), this.style.updateImage(h, n), this;
          }
          getImage(h) {
            return this.style.getImage(h);
          }
          hasImage(h) {
            return h ? !!this.style.getImage(h) : (this.fire(new a.k(new Error("Missing required image id"))), !1);
          }
          removeImage(h) {
            this.style.removeImage(h);
          }
          loadImage(h) {
            return Qe.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(h, e), this._update(!0);
          }
          moveLayer(h, e) {
            return this.style.moveLayer(h, e), this._update(!0);
          }
          removeLayer(h) {
            return this.style.removeLayer(h), this._update(!0);
          }
          getLayer(h) {
            return this.style.getLayer(h);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(h, e, n) {
            return this.style.setLayerZoomRange(h, e, n), this._update(!0);
          }
          setFilter(h, e, n = {}) {
            return this.style.setFilter(h, e, n), this._update(!0);
          }
          getFilter(h) {
            return this.style.getFilter(h);
          }
          setPaintProperty(h, e, n, o = {}) {
            return this.style.setPaintProperty(h, e, n, o), this._update(!0);
          }
          getPaintProperty(h, e) {
            return this.style.getPaintProperty(h, e);
          }
          setLayoutProperty(h, e, n, o = {}) {
            return this.style.setLayoutProperty(h, e, n, o), this._update(!0);
          }
          getLayoutProperty(h, e) {
            return this.style.getLayoutProperty(h, e);
          }
          setGlyphs(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(h, e), this._update(!0);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(h, e, n = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(h, e, n, (o) => {
              o || this._update(!0);
            }), this;
          }
          removeSprite(h) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(h), this._update(!0);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(h, e, (n) => {
              n || this._update(!0);
            }), this;
          }
          setLight(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(h, e), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(h, e), this._update(!0);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(h, e) {
            return this.style.setFeatureState(h, e), this._update();
          }
          removeFeatureState(h, e) {
            return this.style.removeFeatureState(h, e), this._update();
          }
          getFeatureState(h) {
            return this.style.getFeatureState(h);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let h = 0, e = 0;
            return this._container && (h = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [h, e];
          }
          _setupContainer() {
            const h = this._container;
            h.classList.add("maplibregl-map");
            const e = this._canvasContainer = Q.create("div", "maplibregl-canvas-container", h);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = Q.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const n = this._containerDimensions(), o = this._getClampedPixelRatio(n[0], n[1]);
            this._resizeCanvas(n[0], n[1], o);
            const c = this._controlContainer = Q.create("div", "maplibregl-control-container", h), d = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((g) => {
              d[g] = Q.create("div", `maplibregl-ctrl-${g} `, c);
            }), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(h, e, n) {
            this._canvas.width = Math.floor(n * h), this._canvas.height = Math.floor(n * e), this._canvas.style.width = `${h}px`, this._canvas.style.height = `${e}px`;
          }
          _setupPainter() {
            const h = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (o) => {
              e = { requestedAttributes: h }, o && (e.statusMessage = o.statusMessage, e.type = o.type);
            }, { once: !0 });
            let n = null;
            if (n = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, h) : this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h), !n) {
              const o = "Failed to initialize WebGL";
              throw e ? (e.message = o, new Error(JSON.stringify(e))) : new Error(o);
            }
            this.painter = new Bu(n, this.transform), Je.testSupport(n);
          }
          migrateProjection(h, e) {
            super.migrateProjection(h, e), this.painter.transform = h, this.fire(new a.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(h) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(h) {
            return this._update(), this._renderTaskQueue.add(h);
          }
          _cancelRenderFrame(h) {
            this._renderTaskQueue.remove(h);
          }
          _render(h) {
            var e, n, o, c, d;
            const g = this._idleTriggered ? this._fadeDuration : 0, v = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(h), this._removed) return;
            let x = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const k = this.transform.zoom, A = we.now();
              this.style.zoomHistory.update(k, A);
              const R = new a.F(k, { now: A, fadeDuration: g, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition(), globalState: this.style.getGlobalState() }), O = R.crossFadingFactor();
              O === 1 && O === this._crossFadingFactor || (x = !0, this._crossFadingFactor = O), this.style.update(R);
            }
            const M = ((n = this.style.projection) === null || n === void 0 ? void 0 : n.transitionState) > 0 !== v;
            (o = this.style.projection) === null || o === void 0 || o.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((c = this.style.projection) === null || c === void 0 ? void 0 : c.transitionState, (d = this.style.projection) === null || d === void 0 ? void 0 : d.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || M) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, g, this._crossSourceCollisions, M), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: g, showPadding: this.showPadding }), this.fire(new a.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, a.cw.mark(a.cx.load), this.fire(new a.l("load"))), this.style && (this.style.hasTransitions() || x) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const C = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return C || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new a.l("idle")), !this._loaded || this._fullyLoaded || C || (this._fullyLoaded = !0, a.cw.mark(a.cx.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var h;
            this._hash && this._hash.remove();
            for (const n of this._controls) n.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Qe.removeThrottleControl(this._imageQueueHandle), (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), Q.remove(this._canvasContainer), Q.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), a.cw.clearMetrics(), this._removed = !0, this.fire(new a.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), we.frame(this._frameRequest, (h) => {
              a.cw.frame(h), this._frameRequest = null;
              try {
                this._render(h);
              } catch (e) {
                if (!a.cy(e) && !function(n) {
                  return n.message === $o;
                }(e)) throw e;
              }
            }, () => {
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(h) {
            this._showTileBoundaries !== h && (this._showTileBoundaries = h, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(h) {
            this._showPadding !== h && (this._showPadding = h, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(h) {
            this._showCollisionBoxes !== h && (this._showCollisionBoxes = h, h ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(h) {
            this._showOverdrawInspector !== h && (this._showOverdrawInspector = h, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(h) {
            this._repaint !== h && (this._repaint = h, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(h) {
            this._vertices = h, this._update();
          }
          get version() {
            return Qu;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(h) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(h), this._update(!0);
          }
        }, T.MapMouseEvent = Ir, T.MapTouchEvent = eo, T.MapWheelEvent = dc, T.Marker = lo, T.NavigationControl = class {
          constructor(h) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(), n = e === this._map.getMaxZoom(), o = e === this._map.getMinZoom();
              this._zoomInButton.disabled = n, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", n.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (e, n) => {
              const o = this._map._getUIString(`NavigationControl.${n}`);
              e.title = o, e.setAttribute("aria-label", o);
            }, this.options = a.e({}, Ad, h), this._container = Q.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e) => this._map.zoomIn({}, { originalEvent: e })), Q.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e) => this._map.zoomOut({}, { originalEvent: e })), Q.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
            }), this._compassIcon = Q.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(h) {
            return this._map = h, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Jo(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            Q.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(h, e) {
            const n = Q.create("button", h, this._container);
            return n.type = "button", n.addEventListener("click", e), n;
          }
        }, T.Popup = class extends a.E {
          constructor(h) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && Q.remove(this._content), this._container && (Q.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new a.l("close"))), this), this._onMouseUp = (e) => {
              this._update(e.point);
            }, this._onMouseMove = (e) => {
              this._update(e.point);
            }, this._onDrag = (e) => {
              this._update(e.point);
            }, this._update = (e) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = Q.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = Q.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const g of this.options.className.split(" ")) this._container.classList.add(g);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Pi(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const n = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let o = this.options.anchor;
              const c = il(this.options.offset);
              if (!o) {
                const g = this._container.offsetWidth, v = this._container.offsetHeight;
                let x;
                x = n.y + c.bottom.y < v ? ["top"] : n.y > this._map.transform.height - v ? ["bottom"] : [], n.x < g / 2 ? x.push("left") : n.x > this._map.transform.width - g / 2 && x.push("right"), o = x.length === 0 ? "bottom" : x.join("-");
              }
              let d = n.add(c[o]);
              this.options.subpixelPositioning || (d = d.round()), Q.setTransform(this._container, `${el[o]} translate(${d.x}px,${d.y}px)`), ao(this._container, o, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = a.e(Object.create(Tc), h);
          }
          addTo(h) {
            return this._map && this.remove(), this._map = h, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new a.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(h) {
            return this._lngLat = a.S.convert(h), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(h) {
            return this.setDOMContent(document.createTextNode(h));
          }
          setHTML(h) {
            const e = document.createDocumentFragment(), n = document.createElement("body");
            let o;
            for (n.innerHTML = h; o = n.firstChild, o; ) e.appendChild(o);
            return this.setDOMContent(e);
          }
          getMaxWidth() {
            var h;
            return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth;
          }
          setMaxWidth(h) {
            return this.options.maxWidth = h, this._update(), this;
          }
          setDOMContent(h) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = Q.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(h), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(h) {
            return this._container && this._container.classList.add(h), this;
          }
          removeClassName(h) {
            return this._container && this._container.classList.remove(h), this;
          }
          setOffset(h) {
            return this.options.offset = h, this._update(), this;
          }
          toggleClassName(h) {
            if (this._container) return this._container.classList.toggle(h);
          }
          setSubpixelPositioning(h) {
            this.options.subpixelPositioning = h;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = Q.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const h = this._container.querySelector(Sc);
            h && h.focus();
          }
        }, T.RasterDEMTileSource = Re, T.RasterTileSource = Ae, T.ScaleControl = class {
          constructor(h) {
            this._onMove = () => {
              tl(this._map, this._container, this.options);
            }, this.setUnit = (e) => {
              this.options.unit = e, tl(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, Qo), h);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(h) {
            return this._map = h, this._container = Q.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            Q.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, T.ScrollZoomHandler = qu, T.Style = $l, T.TerrainControl = class {
          constructor(h) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = h;
          }
          onAdd(h) {
            return this._map = h, this._container = Q.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = Q.create("button", "maplibregl-ctrl-terrain", this._container), Q.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            Q.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, T.TwoFingersTouchPitchHandler = Wa, T.TwoFingersTouchRotateHandler = so, T.TwoFingersTouchZoomHandler = Ha, T.TwoFingersTouchZoomRotateHandler = Xu, T.VectorTileSource = ze, T.VideoSource = Ge, T.addSourceType = (h, e) => a._(void 0, void 0, void 0, function* () {
          if (Ye(h)) throw new Error(`A source type called "${h}" already exists.`);
          ((n, o) => {
            ht[n] = o;
          })(h, e);
        }), T.clearPrewarmedResources = function() {
          const h = Dr;
          h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(qr), Dr = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, T.createTileMesh = Vl, T.getMaxParallelImageRequests = function() {
          return a.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, T.getRTLTextPluginStatus = function() {
          return Wt().getRTLTextPluginStatus();
        }, T.getVersion = function() {
          return Pc;
        }, T.getWorkerCount = function() {
          return mi.workerCount;
        }, T.getWorkerUrl = function() {
          return a.a.WORKER_URL;
        }, T.importScriptInWorkers = function(h) {
          return Qr().broadcast("IS", h);
        }, T.prewarm = function() {
          Cn().acquire(qr);
        }, T.setMaxParallelImageRequests = function(h) {
          a.a.MAX_PARALLEL_IMAGE_REQUESTS = h;
        }, T.setRTLTextPlugin = function(h, e) {
          return Wt().setRTLTextPlugin(h, e);
        }, T.setWorkerCount = function(h) {
          mi.workerCount = h;
        }, T.setWorkerUrl = function(h) {
          a.a.WORKER_URL = h;
        };
      });
      var D = b;
      return D;
    });
  }(Ih)), Ih.exports;
}
var So = Eb();
const Ab = /* @__PURE__ */ Cb(So), Nn = /* @__PURE__ */ vb("instance", () => {
  const { config: u } = js(), m = On(null), b = On(null), S = On([]), E = On(!0), D = On(null), T = On("overlays"), a = On(), U = On("marker"), ue = On(!1), ce = ls({
    text: "",
    inBounds: !0
  }), ve = ls({
    bearing: null,
    pitch: null,
    bounds: null,
    zoom: null,
    center: null
  }), we = (vt = {}) => {
    js().init(vt), u.value.getMapOption("debug_mode") && (T.value = "debug");
  }, Q = cr(() => {
    const vt = {
      marker: {},
      line: {},
      shape: {}
    };
    return S.value.forEach((Ze) => {
      const Ke = Ze.typeKey || "undefined";
      vt[Ze.featureType][Ke] || (vt[Ze.featureType][Ke] = []), vt[Ze.featureType][Ke].push(Ze);
    }), vt;
  }), Je = cr(() => {
    const vt = [];
    return S.value.forEach((Ze) => {
      ce.value.inBounds && !Ze.inBounds(ve.value.bounds) || ce.value.text !== "" && !Ze.containsText(ce.value.text) || vt.push(Ze);
    }), vt;
  }), it = cr(() => {
    if (S.value.length === 0)
      return null;
    const vt = new So.LngLatBounds();
    return S.value.forEach((Ze) => {
      vt.extend(Ze.getBounds());
    }), vt;
  });
  return {
    // State
    config: u,
    mapReady: ue,
    container: m,
    panelOpen: E,
    overlays: S,
    overlaysByType: Q,
    map: b,
    layerFilters: ce,
    activeOverlay: D,
    activePanelKey: T,
    activeNavKey: a,
    activeFeatureType: U,
    view: ve,
    // Actions
    init: we,
    // Computed
    overlaysByType: Q,
    filteredOverlays: Je,
    overlaysBounds: it
  };
});
var gn = 63710088e-1, kb = {
  centimeters: gn * 100,
  centimetres: gn * 100,
  degrees: 360 / (2 * Math.PI),
  feet: gn * 3.28084,
  inches: gn * 39.37,
  kilometers: gn / 1e3,
  kilometres: gn / 1e3,
  meters: gn,
  metres: gn,
  miles: gn / 1609.344,
  millimeters: gn * 1e3,
  millimetres: gn * 1e3,
  nauticalmiles: gn / 1852,
  radians: 1,
  yards: gn * 1.0936
};
function $p(u, m, b = {}) {
  const S = { type: "Feature" };
  return (b.id === 0 || b.id) && (S.id = b.id), b.bbox && (S.bbox = b.bbox), S.properties = m || {}, S.geometry = u, S;
}
function zb(u, m, b = {}) {
  if (u.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  return $p({
    type: "LineString",
    coordinates: u
  }, m, b);
}
function Rb(u, m = "kilometers") {
  const b = kb[m];
  if (!b)
    throw new Error(m + " units is invalid");
  return u * b;
}
function wh(u) {
  return u % 360 * Math.PI / 180;
}
function Pg(u) {
  if (!u)
    throw new Error("coord is required");
  if (!Array.isArray(u)) {
    if (u.type === "Feature" && u.geometry !== null && u.geometry.type === "Point")
      return [...u.geometry.coordinates];
    if (u.type === "Point")
      return [...u.coordinates];
  }
  if (Array.isArray(u) && u.length >= 2 && !Array.isArray(u[0]) && !Array.isArray(u[1]))
    return [...u];
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function Db(u, m, b = {}) {
  var S = Pg(u), E = Pg(m), D = wh(E[1] - S[1]), T = wh(E[0] - S[0]), a = wh(S[1]), U = wh(E[1]), ue = Math.pow(Math.sin(D / 2), 2) + Math.pow(Math.sin(T / 2), 2) * Math.cos(a) * Math.cos(U);
  return Rb(
    2 * Math.atan2(Math.sqrt(ue), Math.sqrt(1 - ue)),
    b.units
  );
}
function H_(u, m, b) {
  if (u !== null)
    for (var S, E, D, T, a, U, ue, ce = 0, ve = 0, we, Q = u.type, Je = Q === "FeatureCollection", it = Q === "Feature", vt = Je ? u.features.length : 1, Ze = 0; Ze < vt; Ze++) {
      ue = Je ? u.features[Ze].geometry : it ? u.geometry : u, we = ue ? ue.type === "GeometryCollection" : !1, a = we ? ue.geometries.length : 1;
      for (var Ke = 0; Ke < a; Ke++) {
        var ut = 0, Qe = 0;
        if (T = we ? ue.geometries[Ke] : ue, T !== null) {
          U = T.coordinates;
          var It = T.type;
          switch (ce = 0, It) {
            case null:
              break;
            case "Point":
              if (m(
                U,
                ve,
                Ze,
                ut,
                Qe
              ) === !1)
                return !1;
              ve++, ut++;
              break;
            case "LineString":
            case "MultiPoint":
              for (S = 0; S < U.length; S++) {
                if (m(
                  U[S],
                  ve,
                  Ze,
                  ut,
                  Qe
                ) === !1)
                  return !1;
                ve++, It === "MultiPoint" && ut++;
              }
              It === "LineString" && ut++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (S = 0; S < U.length; S++) {
                for (E = 0; E < U[S].length - ce; E++) {
                  if (m(
                    U[S][E],
                    ve,
                    Ze,
                    ut,
                    Qe
                  ) === !1)
                    return !1;
                  ve++;
                }
                It === "MultiLineString" && ut++, It === "Polygon" && Qe++;
              }
              It === "Polygon" && ut++;
              break;
            case "MultiPolygon":
              for (S = 0; S < U.length; S++) {
                for (Qe = 0, E = 0; E < U[S].length; E++) {
                  for (D = 0; D < U[S][E].length - ce; D++) {
                    if (m(
                      U[S][E][D],
                      ve,
                      Ze,
                      ut,
                      Qe
                    ) === !1)
                      return !1;
                    ve++;
                  }
                  Qe++;
                }
                ut++;
              }
              break;
            case "GeometryCollection":
              for (S = 0; S < T.geometries.length; S++)
                if (H_(T.geometries[S], m) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function Lb(u, m) {
  var b, S, E, D, T, a, U, ue, ce, ve, we = 0, Q = u.type === "FeatureCollection", Je = u.type === "Feature", it = Q ? u.features.length : 1;
  for (b = 0; b < it; b++) {
    for (a = Q ? u.features[b].geometry : Je ? u.geometry : u, ue = Q ? u.features[b].properties : Je ? u.properties : {}, ce = Q ? u.features[b].bbox : Je ? u.bbox : void 0, ve = Q ? u.features[b].id : Je ? u.id : void 0, U = a ? a.type === "GeometryCollection" : !1, T = U ? a.geometries.length : 1, E = 0; E < T; E++) {
      if (D = U ? a.geometries[E] : a, D === null) {
        if (m(
          null,
          we,
          ue,
          ce,
          ve
        ) === !1)
          return !1;
        continue;
      }
      switch (D.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (m(
            D,
            we,
            ue,
            ce,
            ve
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (S = 0; S < D.geometries.length; S++)
            if (m(
              D.geometries[S],
              we,
              ue,
              ce,
              ve
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    we++;
  }
}
function Fb(u, m) {
  Lb(u, function(b, S, E, D, T) {
    var a = b === null ? null : b.type;
    switch (a) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return m(
          $p(b, E, { bbox: D, id: T }),
          S,
          0
        ) === !1 ? !1 : void 0;
    }
    var U;
    switch (a) {
      case "MultiPoint":
        U = "Point";
        break;
      case "MultiLineString":
        U = "LineString";
        break;
      case "MultiPolygon":
        U = "Polygon";
        break;
    }
    for (var ue = 0; ue < b.coordinates.length; ue++) {
      var ce = b.coordinates[ue], ve = {
        type: U,
        coordinates: ce
      };
      if (m($p(ve, E), S, ue) === !1)
        return !1;
    }
  });
}
function Bb(u, m) {
  Fb(u, function(b, S, E) {
    var D = 0;
    if (b.geometry) {
      var T = b.geometry.type;
      if (!(T === "Point" || T === "MultiPoint")) {
        var a, U = 0, ue = 0, ce = 0;
        if (H_(
          b,
          function(ve, we, Q, Je, it) {
            if (a === void 0 || S > U || Je > ue || it > ce) {
              a = ve, U = S, ue = Je, ce = it, D = 0;
              return;
            }
            var vt = zb(
              [a, ve],
              b.properties
            );
            if (m(
              vt,
              S,
              E,
              it,
              D
            ) === !1)
              return !1;
            D++, a = ve;
          }
        ) === !1)
          return !1;
      }
    }
  });
}
function Ob(u, m, b) {
  var S = b, E = !1;
  return Bb(
    u,
    function(D, T, a, U, ue) {
      E === !1 && b === void 0 ? S = D : S = m(
        S,
        D,
        T,
        a,
        U,
        ue
      ), E = !0;
    }
  ), S;
}
function jb(u, m = {}) {
  return Ob(
    u,
    (b, S) => {
      const E = S.geometry.coordinates;
      return b + Db(E[0], E[1], m);
    },
    0
  );
}
class td {
  constructor(m, b, S = null) {
    if (!m || m.type !== "Feature")
      throw new Error("Valid GeoJSON Feature required");
    if (this.feature = m, S == null || typeof S != "string")
      throw new Error("Valid ID string required");
    if (this.id = S, !(b instanceof G_))
      throw new Error("Valid Config required");
    if (this.config = b, this.featureType = U_(this.feature) || null, this.feature.properties = this.feature.properties || {}, this.title = this.feature.properties.title || "", this.description = this.feature.properties.description || "", this.images = Tb(this.feature), this.typeKey = this.getTypeKey() || null, this.type = this.config.getType(this.featureType, this.typeKey), !this.type) {
      console.error(
        `Type not found for ${featureType} Type ${typeKey}`,
        m
      );
      return;
    }
  }
  addTo(m) {
    !m || !m.addLayer || (this.map = m, this.map.addSource(this.id, {
      type: "geojson",
      data: this.feature
    }), this.source = this.map.getSource(this.id), this instanceof Vh ? (this.marker = this.toMarker(), this.marker.addTo(this.map)) : (this.style = this.toStyle(), this.map.addLayer(this.style)), this.layer = this.map.getLayer(this.id), this instanceof Up && this.addStroke(), this.addEvents());
  }
  remove() {
    this.map && (this instanceof Vh && this.marker && (this.marker.remove(), this.marker = null), this instanceof Up && this.map.getLayer(`${this.id}-stroke`) && this.map.removeLayer(`${this.id}-stroke`), this.map.getLayer(this.id) && this.map.removeLayer(this.id), this.map.getSource(this.id) && this.map.removeSource(this.id), this.map = null, this.source = null, this.layer = null, this.style = null);
  }
  toGeoJSON() {
    return this.feature;
  }
  getTypeKey() {
    return !this.feature.properties.type || typeof this.feature.properties.type != "string" ? null : this.feature.properties.type;
  }
  hasImage() {
    return this.feature.properties.image_thumbnail_url || this.feature.properties.image_medium_url || this.feature.properties.image_large_url;
  }
  getImage(m = "thumbnail") {
    return this.images[m];
  }
  getTitle() {
    return this.title;
  }
  getDescription() {
    return this.description;
  }
  containsText(m = "") {
    let b = 0;
    return b += this.type.getTitle().toString().toLowerCase().includes(m.toLowerCase()), b += Object.values(this.feature.properties).some((S) => S.toString().toLowerCase().includes(m.toLowerCase())), b > 0;
  }
  zoomIn() {
    if (!this.map)
      return;
    const m = 16;
    this.map.getZoom() < m && this.map.flyTo({
      center: [
        this.feature.geometry.coordinates[0],
        this.feature.geometry.coordinates[1]
      ],
      zoom: m,
      ..._a
    });
  }
}
class Vh extends td {
  constructor(m, b, S) {
    super(m, b, S);
  }
  toMarker() {
    const m = document.createElement("div");
    m.className = this.type.iconData.className, m.innerHTML = this.type.iconData.html, m.style.width = `${this.type.iconData.iconSize[0]}px`, m.style.height = `${this.type.iconData.iconSize[1]}px`;
    const b = new So.Marker({
      element: m,
      offset: this.type.iconData.iconAnchor
    });
    return b.setLngLat(this.feature.geometry.coordinates), b;
  }
  addEvents() {
  }
  show() {
    this.marker && (this.marker.getElement().style.visibility = "visible");
  }
  hide() {
    this.marker && (this.marker.getElement().style.visibility = "hidden");
  }
  hasElevationData() {
    return this.feature.geometry.coordinates.length === 3;
  }
  getElevationString() {
    if (!this.hasElevationData())
      return "";
    const m = this.config.getMapOption("units") === "metric" ? "m" : "ft";
    return "Elevation: " + Math.round(this.feature.geometry.coordinates[2] * 10) / 10 + m;
  }
  getBounds() {
    return new So.LngLatBounds(
      [
        this.feature.geometry.coordinates[0],
        this.feature.geometry.coordinates[1]
      ],
      [
        this.feature.geometry.coordinates[0],
        this.feature.geometry.coordinates[1]
      ]
    );
  }
  getCoordsString() {
    return "Lat,Lng: " + this.feature.geometry.coordinates[1].toFixed(6) + ", " + this.feature.geometry.coordinates[0].toFixed(6);
  }
  addHighlight() {
    const m = this.marker.getElement(), b = m.querySelector(".waymark-marker-background");
    b && (b.style.borderColor = lf), m.classList.add("waymark-active");
  }
  removeHighlight() {
    this.marker.getElement().classList.remove("waymark-active");
  }
  flyTo() {
    this.map.flyTo({
      center: [
        this.feature.geometry.coordinates[0],
        this.feature.geometry.coordinates[1]
      ],
      ..._a
    });
  }
  inBounds(m) {
    return m.contains({
      lng: this.feature.geometry.coordinates[0],
      lat: this.feature.geometry.coordinates[1]
    });
  }
}
class Vb extends td {
  constructor(m, b, S) {
    super(m, b, S);
  }
  toStyle() {
    return {
      id: this.id,
      type: "line",
      source: this.id,
      layout: {
        "line-join": "round",
        "line-cap": "round"
      },
      paint: {
        "line-color": this.type.getPrimaryColour(),
        "line-width": parseFloat(this.type.data.line_weight)
      }
    };
  }
  addEvents() {
    this.map.on("mouseenter", this.id, () => {
      this.map.getCanvas().style.cursor = "pointer";
    }), this.map.on("mouseleave", this.id, () => {
      this.map.getCanvas().style.cursor = "";
    });
  }
  show() {
    this.map.getLayer(this.id) && this.map.setLayoutProperty(this.id, "visibility", "visible");
  }
  hide() {
    this.map.getLayer(this.id) && this.map.setLayoutProperty(this.id, "visibility", "none");
  }
  getLengthString() {
    let m = "";
    m += "Length: ";
    const b = jb(this.feature, {
      units: this.config.getMapOption("units") === "metric" ? "kilometers" : "miles"
    });
    return m += Math.round(b * 100) / 100, m += this.config.getMapOption("units") === "metric" ? "km" : "mi", m;
  }
  hasElevationData() {
    return this.getLinePositions().some((m) => m.length === 3);
  }
  getElevationString() {
    if (!this.hasElevationData())
      return "";
    const m = this.config.getMapOption("units") === "metric" ? "m" : "ft", b = this.getLinePositions();
    if (b.length === 0)
      return "";
    let S = 0, E = 0, D = b[0][2], T = b[0][2];
    for (let a = 1; a < b.length; a++) {
      const U = b[a][2] - b[a - 1][2];
      U > 0 ? S += U : E -= U, D = Math.max(D, b[a][2]), T = Math.min(T, b[a][2]);
    }
    return this.config.getMapOption("units") === "imperial" && (S *= 3.28084, E *= 3.28084, D *= 3.28084, T *= 3.28084), "Elevation Gain: " + Math.round(S * 10) / 10 + m + ", Loss: " + Math.round(E * 10) / 10 + m + ", Max: " + Math.round(D * 10) / 10 + m + ", Min: " + Math.round(T * 10) / 10 + m;
  }
  getBounds() {
    const m = this.getLinePositions();
    return m.length ? m.reduce(
      (b, S) => b.extend({ lng: S[0], lat: S[1] }),
      new So.LngLatBounds(
        { lng: m[0][0], lat: m[0][1] },
        { lng: m[0][0], lat: m[0][1] }
      )
    ) : new So.LngLatBounds([0, 0], [0, 0]);
  }
  getCoordsString() {
    const b = this.getBounds().getCenter();
    return "Centre Lat,Lng: " + b.lat.toFixed(6) + ", " + b.lng.toFixed(6);
  }
  addHighlight() {
    this.map.addLayer(
      {
        id: `${this.id}-highlight`,
        type: "line",
        source: this.id,
        layout: {},
        paint: {
          "line-color": lf,
          "line-width": parseFloat(this.type.data.line_weight) + 2
        }
      },
      this.id
    );
  }
  removeHighlight() {
    this.map.getLayer(`${this.id}-highlight`) && this.map.removeLayer(`${this.id}-highlight`);
  }
  flyTo() {
    const m = this.getBounds();
    this.map.fitBounds(m, _a);
  }
  inBounds(m) {
    return this.getLinePositions().some(
      (S) => m.contains({ lng: S[0], lat: S[1] })
    );
  }
  zoomIn() {
    if (this.map.getZoom() < 16) {
      const S = this.getLinePositions(), E = S.length ? S[0] : [0, 0];
      this.map.flyTo({
        center: [E[0], E[1]],
        zoom: 16,
        ..._a
      });
    }
  }
  getLinePositions() {
    const m = this.feature.geometry;
    return m.type === "MultiLineString" ? m.coordinates.reduce((b, S) => b.concat(S), []) : m.coordinates || [];
  }
}
class Up extends td {
  constructor(m, b, S) {
    super(m, b, S);
  }
  toStyle() {
    return {
      id: this.id,
      type: "fill",
      source: this.id,
      layout: {},
      paint: {
        "fill-color": this.type.data.shape_colour || "#000000",
        "fill-opacity": parseFloat(this.type.data.fill_opacity) || 0.5,
        "fill-outline-color": this.type.data.shape_colour || "#000000"
      }
    };
  }
  show() {
    this.map.getLayer(this.id) && this.map.setLayoutProperty(this.id, "visibility", "visible"), this.map.getLayer(`${this.id}-stroke`) && this.map.setLayoutProperty(`${this.id}-stroke`, "visibility", "visible");
  }
  hide() {
    this.map.getLayer(this.id) && this.map.setLayoutProperty(this.id, "visibility", "none"), this.map.getLayer(`${this.id}-stroke`) && this.map.setLayoutProperty(`${this.id}-stroke`, "visibility", "none");
  }
  addStroke() {
    this.map.addLayer({
      id: `${this.id}-stroke`,
      type: "line",
      source: this.id,
      layout: {
        "line-join": "round",
        "line-cap": "round"
      },
      paint: {
        "line-color": this.type.data.shape_colour || "#000000",
        "line-width": 1,
        "line-opacity": 1
      }
    });
  }
  addEvents() {
    this.map.on("mouseenter", this.id, () => {
      this.map.getCanvas().style.cursor = "pointer";
    }), this.map.on("mouseleave", this.id, () => {
      this.map.getCanvas().style.cursor = "";
    });
  }
  hasElevationData() {
    return this.getPolygonPositions().some((m) => m.length === 3);
  }
  getElevationString() {
    return this.hasElevationData() ? (this.config.getMapOption("units"), "Elevation data available") : "";
  }
  getBounds() {
    const m = this.getPolygonPositions();
    return m.length ? m.reduce(
      (b, S) => b.extend({ lng: S[0], lat: S[1] }),
      new So.LngLatBounds(
        { lng: m[0][0], lat: m[0][1] },
        { lng: m[0][0], lat: m[0][1] }
      )
    ) : new So.LngLatBounds([0, 0], [0, 0]);
  }
  getCoordsString() {
    const b = this.getBounds().getCenter();
    return "Centre Lat,Lng: " + b.lat.toFixed(6) + ", " + b.lng.toFixed(6);
  }
  addHighlight() {
    this.map.addLayer({
      id: `${this.id}-highlight`,
      type: "line",
      source: this.id,
      layout: {},
      paint: {
        "line-color": lf,
        "line-width": 2
      }
    });
  }
  removeHighlight() {
    this.map.getLayer(`${this.id}-highlight`) && this.map.removeLayer(`${this.id}-highlight`);
  }
  zoomIn() {
    const b = this.getBounds().getCenter();
    this.map.flyTo({
      center: [b.lng, b.lat],
      zoom: Math.max(this.map.getZoom(), 16),
      ..._a
    });
  }
  getPolygonPositions() {
    const m = this.feature.geometry;
    return m.type === "MultiPolygon" ? m.coordinates.reduce((b, S) => (S.forEach((E) => b.push(...E)), b), []) : m.coordinates ? m.coordinates.reduce((b, S) => b.concat(S), []) : [];
  }
  flyTo() {
    const m = this.getBounds();
    this.map.fitBounds(m, _a);
  }
  inBounds(m) {
    const b = this.getBounds();
    return !(b.getNorth() < m.getSouth() || b.getSouth() > m.getNorth() || b.getEast() < m.getWest() || b.getWest() > m.getEast());
  }
}
function cf() {
  const {
    panelOpen: u,
    activePanelKey: m,
    activeNavKey: b,
    overlays: S,
    activeFeatureType: E,
    layerFilters: D
  } = Vn(Nn()), T = cr(() => S.value.length > 0), a = (Ke) => u.value && m.value === Ke, U = (Ke) => m.value === Ke && u.value, ue = () => {
    u.value = !u.value;
  }, ce = (Ke = "overlays") => {
    m.value = Ke, u.value = !0;
  }, ve = (Ke = "overlays") => {
    it(), Ke === m.value ? ue() : ce(Ke);
  }, we = () => {
    u.value = !1, m.value = "";
  }, Q = () => m.value, Je = (Ke = "") => {
    we(), b.value = b.value === Ke ? "" : Ke, console.log("activeNavKey", b.value);
  }, it = () => {
    b.value = "";
  };
  return {
    isActivePanel: a,
    openPanel: ve,
    showPanel: U,
    closePanel: we,
    togglePanel: ue,
    setActivePanel: ce,
    getActivePanelKey: Q,
    mapHasOverlays: T,
    showNav: Je,
    closeNav: it,
    isActiveNav: (Ke = "") => b.value === Ke,
    activeFeatureType: E,
    setActiveFeatureType: (Ke) => {
      E.value = Ke;
    },
    layerFilters: D
  };
}
function fa() {
  const { config: u } = js(), { setActivePanel: m, closePanel: b } = cf(), {
    map: S,
    mapReady: E,
    overlays: D,
    overlaysBounds: T,
    activeOverlay: a,
    activeFeatureType: U,
    panelOpen: ue,
    activePanelKey: ce,
    activeNavKey: ve,
    view: we
  } = Vn(Nn()), Q = () => {
    const pt = {
      ...u.value.getMapLibreOptions(),
      container: `${u.value.getMapOption("div_id")}-map`
    };
    S.value = new Ab.Map(pt), S.value.on("load", () => {
      E.value = !0, u.value.getTileLayers().forEach((at) => {
        at.addTo(S.value);
      }), we.value.bounds = S.value.getBounds(), we.value.bearing = S.value.getBearing(), we.value.pitch = S.value.getPitch(), we.value.zoom = S.value.getZoom(), we.value.center = S.value.getCenter();
    }), S.value.on("rotateend", () => {
      we.value.bearing = S.value.getBearing();
    }), S.value.on("pitchend", () => {
      we.value.pitch = S.value.getPitch();
    }), S.value.on("moveend", () => {
      we.value.bounds = S.value.getBounds(), we.value.center = S.value.getCenter(), we.value.zoom = S.value.getZoom();
    }), S.value.on("click", (at) => {
      const _t = [
        [at.point.x - 10, at.point.y - 10],
        [at.point.x + 10, at.point.y + 10]
      ], Et = S.value.queryRenderedFeatures(_t, {
        layers: D.value.filter((Ut) => Ut.featureType !== "marker").map((Ut) => Ut.id)
      });
      if (Et.length) {
        const Ut = D.value.find(
          (fi) => fi.id === Et[0].layer.id
        );
        Ut && Ze(Ut);
      } else
        a.value ? Ze() : b();
    });
  }, Je = (pt) => {
    if (pt && Array.isArray(pt.features)) {
      if (!E.value) {
        S.value.on("load", () => {
          Je(pt);
        });
        return;
      }
      pt.features.forEach((at) => {
        const _t = U_(at);
        if (!_t || !$_.includes(_t)) {
          console.warn(
            "Feature Type not recognised or supported - skipping",
            at
          );
          return;
        }
        const Et = `overlay-${D.value.length}`, Ut = (() => {
          switch (_t) {
            case "marker":
              return new Vh(at, u.value, Et);
            case "line":
              return new Vb(at, u.value, Et);
            case "shape":
              return new Up(at, u.value, Et);
          }
        })();
        D.value = [...D.value, Ut], Ut.addTo(S.value), Ut instanceof Vh && Ut.marker.getElement().addEventListener("click", (fi) => {
          fi.stopPropagation(), Ze(Ut);
        });
      }), u.value.getInitialView() || S.value.fitBounds(T.value, bb);
    }
  }, it = () => {
    D.value.forEach((pt) => {
      pt.remove();
    }), D.value = [], a.value = null;
  }, vt = () => {
    const pt = {
      type: "FeatureCollection",
      features: []
    };
    return D.value.forEach((at) => {
      pt.features.push(at.toGeoJSON());
    }), pt;
  }, Ze = (pt = null) => {
    if (!pt) {
      a.value && a.value.removeHighlight(), a.value = null;
      return;
    }
    if (a.value) {
      if (a.value === pt) {
        pt.zoomIn();
        return;
      }
      a.value.removeHighlight(), a.value = null;
    }
    ve.value = "", U.value = pt.featureType, m("overlays"), a.value = pt, pt.flyTo(), pt.addHighlight(), setTimeout(() => {
      if (pt.rowElement) {
        const _t = document.querySelector(".panel.overlay .panel-top").clientHeight;
        pt.rowElement.value.style.scrollMarginTop = `${_t}px`, pt.rowElement.value.scrollIntoView({
          behavior: "smooth",
          block: "nearest"
        });
      }
    }, 750);
  };
  return {
    init: Q,
    loadGeoJSON: Je,
    clearGeoJSON: it,
    toGeoJSON: vt,
    setActiveOverlay: Ze,
    resetView: () => {
      S.value.fitBounds(T.value, _a);
    },
    rotateMap: (pt = "cw", at = 90) => {
      if (S.value.isRotating())
        return;
      const _t = S.value.getBearing(), Et = pt === "cw" ? _t + at : _t - at;
      S.value.rotateTo(Et, wb);
    },
    pointNorth: () => {
      S.value && S.value.easeTo({
        bearing: 0,
        ...bh
      });
    },
    pitchMap: (pt = "down", at = 15) => {
      const _t = S.value.getPitch();
      let Et = pt === "down" ? _t + at : _t - at;
      Et = Math.max(0, Math.min(60, Et)), S.value.easeTo(
        {
          pitch: Et,
          ...bh
        },
        { easing: (Ut) => Ut * (2 - Ut) }
      );
    },
    toggle3D: () => {
      we.value.pitch > 0 ? S.value.easeTo(
        {
          pitch: 0,
          ...bh
        },
        { easing: (pt) => pt * (2 - pt) }
      ) : S.value.easeTo(
        {
          pitch: 60,
          ...bh
        },
        { easing: (pt) => pt * (2 - pt) }
      );
    }
  };
}
const Nb = ["id"], $b = {
  __name: "Map",
  setup(u) {
    const { config: m } = js(), { init: b } = fa();
    return h_(() => {
      b();
    }), (S, E) => (wt(), Yt("div", {
      class: "map",
      id: `${Xe(m).getMapOption("div_id")}-map`,
      style: { height: "100%" }
    }, null, 8, Nb));
  }
}, Ub = { class: "preview" }, Zb = {
  key: 0,
  class: "marker"
}, Gb = ["innerHTML"], qb = {
  key: 1,
  class: "line"
}, Hb = {
  key: 2,
  class: "shape"
}, Wb = {
  width: "100%",
  height: "100%",
  viewBox: "0 0 100 100",
  xmlns: "http://www.w3.org/2000/svg"
}, Xb = ["fill", "opacity"], W_ = {
  __name: "Preview",
  props: {
    type: {
      type: ed,
      required: !0
    }
  },
  setup(u) {
    return (m, b) => (wt(), Yt("div", Ub, [
      u.type instanceof Xe(ua) ? (wt(), Yt("div", Zb, [
        yt("div", {
          class: us(["waymark-marker", u.type.iconData.className]),
          innerHTML: u.type.iconData.html,
          style: ma(`width:${u.type.iconData.iconSize[0]}px;height:${u.type.iconData.iconSize[1]}px`)
        }, null, 14, Gb)
      ])) : u.type instanceof Xe(Pl) ? (wt(), Yt("div", qb, [
        yt("div", {
          class: "inner",
          style: ma(`background-color:${u.type.getPrimaryColour()};height:${u.type.getLineWeight()}px`)
        }, null, 4)
      ])) : u.type instanceof Xe(Ml) ? (wt(), Yt("div", Hb, [
        (wt(), Yt("svg", Wb, [
          yt("circle", {
            cx: "50",
            cy: "50",
            r: "40",
            fill: u.type.getPrimaryColour(),
            opacity: u.type.getFillOpacity()
          }, null, 8, Xb)
        ]))
      ])) : Ei("", !0)
    ]));
  }
}, Kb = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M169.4 470.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 370.8 224 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 306.7L54.6 265.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"/></svg>', Yb = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z"/></svg>', Jb = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 0c53 0 96 43 96 96v3.6c0 15.7-12.7 28.4-28.4 28.4H188.4c-15.7 0-28.4-12.7-28.4-28.4V96c0-53 43-96 96-96zM41.4 105.4c12.5-12.5 32.8-12.5 45.3 0l64 64c.7 .7 1.3 1.4 1.9 2.1c14.2-7.3 30.4-11.4 47.5-11.4H312c17.1 0 33.2 4.1 47.5 11.4c.6-.7 1.2-1.4 1.9-2.1l64-64c12.5-12.5 32.8-12.5 45.3 0s12.5 32.8 0 45.3l-64 64c-.9 .9-1.9 1.7-2.8 2.6C436.3 231.3 456 265.3 456 304v16 192c0 17.7-14.3 32-32 32s-32-14.3-32-32V464H120v48c0 17.7-14.3 32-32 32s-32-14.3-32-32V320c0-38.7 19.7-72.7 51.5-89.4c-1-.9-1.9-1.7-2.8-2.6l-64-64c-12.5-12.5-12.5-32.8 0-45.3zM312 224H200c-17.7 0-32 14.3-32 32V416H344V256c0-17.7-14.3-32-32-32z"/></svg>', Qb = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"/></svg>', e1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M233.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L256 173.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"/></svg>', t1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"/></svg>', i1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 8-15.7 10.8-23.8 6.8l-55.7-22.2c-7.6 6-15.9 11.3-24.6 15.8l-9.3 58.1c-1.5 9.2-8.5 16.6-17.8 17.6c-12.1 1.3-24.4 2-36.8 2s-24.7-.7-36.8-2c-9.3-1-16.3-8.4-17.8-17.6l-9.3-58.1c-8.7-4.5-17-9.8-24.6-15.8l-55.7 22.2c-8.1 4-17.9 1.2-23.8-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 262.8 64 254.4s.6-17.1 1.7-25.4L22.4 189.6c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-8 15.7-10.8 23.8-6.8l55.7 22.2c7.6-6 15.9-11.3 24.6-15.8l9.3-58.1c1.5-9.2 8.5-16.6 17.8-17.6C201.6 16.7 213.9 16 226.3 16s24.7 .7 36.8 2c9.3 1 16.3 8.4 17.8 17.6l9.3 58.1c8.7 4.5 17 9.8 24.6 15.8l55.7-22.2c8.1-4 17.9-1.2 23.8 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"/></svg>', r1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c8.4-19.3 10.6-41.4 4.8-63.3c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zM373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5L373 389.9z"/></svg>', n1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.5 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z"/></svg>', s1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 13-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"/></svg>', o1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336h24V272H216c-13.3 0-24-10.7-24-24s10.7-24 24-24h48c13.3 0 24 10.7 24 24v88h8c13.3 0 24 10.7 24 24s-10.7 24-24 24H216c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/></svg>', a1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M444.5 219.9L487 177.4c25-25 25-65.5 0-90.5L425.1 25c-25-25-65.5-25-90.5 0L292.1 67.5c-25 25-25 65.5 0 90.5l42.4 42.4c-25.9 18.9-54.1 35.6-84.6 48.6C137.9 296.7 65.1 312 0 312v96c0 17.7 14.3 32 32 32h64c17.7 0 32-14.3 32-32V384c0-17.7 14.3-32 32-32h64c17.7 0 32-14.3 32-32V296c72.3 0 138.7-13.9 196.1-38.6c28-12.1 53.8-27.4 76.4-45.4zM341.7 104.1L384.2 61.6l61.9 61.9L403.6 166l-61.9-61.9z"/></svg>', l1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M215.7 499.2C267 435 384 279.4 384 192C384 86 298 0 192 0S0 86 0 192c0 87.4 117 243 168.3 307.2c12.3 15.3 35.1 15.3 47.4 0zM192 128a64 64 0 1 1 0 128 64 64 0 1 1 0-128z"/></svg>', c1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M384 476.1L192 421.2V35.9L384 90.8V476.1zm32-1.2V88.4l149.7-42.7c5.6-1.6 11.4 .9 14.3 6L576 57.6V424c0 10.7-6.8 20.2-17.1 23.1l-160 45.7c-5.4 1.5-11.1-1.2-13.6-6.2l-1.3-2.7zm-384-6.2L178.9 423c5.4-1.5 11.1 1.2 13.6 6.2l1.3 2.7L160 476.1V423.6l-128 36.5c-10.7 3.1-21.6-2.9-26.2-12.9L0 436.3V69.9c0-10.7 6.8-20.2 17.1-23.1L177.1 1.1c5.4-1.5 11.1 1.2 13.6 6.2l1.3 2.7L160 35.9V88.4L32 51.8V468.7zM160 88.4V35.9l-128 36.5V423.6l128-36.5V88.4zM416 423.6l128 36.5V93.3l-128-36.5V423.6z"/></svg>', u1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg>', h1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M152.1 38.2c9.9 8.9 10.7 24 1.8 33.9l-72 80c-4.4 4.9-10.6 7.8-17.2 7.9s-12.9-2.4-17.6-7L7 113C-2.3 103.6-2.3 88.4 7 79s24.6-9.4 33.9 0l22.1 22.1 55.1-61.2c8.9-9.9 24-10.7 33.9-1.8zm0 160c9.9 8.9 10.7 24 1.8 33.9l-72 80c-4.4 4.9-10.6 7.8-17.2 7.9s-12.9-2.4-17.6-7L7 273c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l22.1 22.1 55.1-61.2c8.9-9.9 24-10.7 33.9-1.8zM224 96c-17.7 0-32-14.3-32-32s14.3-32 32-32H480c17.7 0 32 14.3 32 32s-14.3 32-32 32H224zm0 160c-17.7 0-32-14.3-32-32s14.3-32 32-32H480c17.7 0 32 14.3 32 32s-14.3 32-32 32H224zM160 416c0-17.7 14.3-32 32-32H480c17.7 0 32 14.3 32 32s-14.3 32-32 32H192c-17.7 0-32-14.3-32-32zM48 368a48 48 0 1 1 0 96 48 48 0 1 1 0-96z"/></svg>', d1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M352 224c53 0 96-43 96-96s-43-96-96-96s-96 43-96 96c0 4 .2 8 .7 11.9l-94.1 47C145.4 170.2 121.9 160 96 160c-53 0-96 43-96 96s43 96 96 96c25.9 0 49.4-10.2 66.6-26.9l94.1 47c-.5 3.9-.7 7.8-.7 11.9c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-25.9 0-49.4 10.2-66.6 26.9l-94.1-47c.5-3.9 .7-7.8 .7-11.9s-.2-8-.7-11.9l94.1-47C302.6 213.8 326.1 224 352 224z"/></svg>', p1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M384 80c8.8 0 16 7.2 16 16V416c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V96c0-8.8 7.2-16 16-16H384zM64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64z"/></svg>', f1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M125.7 160H176c17.7 0 32 14.3 32 32s-14.3 32-32 32H48c-17.7 0-32-14.3-32-32V64c0-17.7 14.3-32 32-32s32 14.3 32 32v51.2L97.6 97.6c87.5-87.5 229.3-87.5 316.8 0s87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3s-163.8-62.5-226.3 0L125.7 160z"/></svg>', m1 = ["innerHTML"], g1 = {
  __name: "Icon",
  props: {
    icon: {
      type: String,
      required: !0
    },
    color: {
      type: String,
      default: null
    },
    rotate: {
      type: Number,
      default: 0
    },
    mirror: {
      type: Boolean,
      default: !1
    }
  },
  setup(u) {
    const m = /* @__PURE__ */ Object.assign({
      "/library/assets/img/icons/angle-down.svg": Kb,
      "/library/assets/img/icons/angle-up.svg": Yb,
      "/library/assets/img/icons/bug.svg": Jb,
      "/library/assets/img/icons/chevron-down.svg": Qb,
      "/library/assets/img/icons/chevron-up.svg": e1,
      "/library/assets/img/icons/close.svg": t1,
      "/library/assets/img/icons/cog.svg": i1,
      "/library/assets/img/icons/eye-slash.svg": r1,
      "/library/assets/img/icons/eye.svg": n1,
      "/library/assets/img/icons/home.svg": s1,
      "/library/assets/img/icons/info.svg": o1,
      "/library/assets/img/icons/location-arrow.svg": a1,
      "/library/assets/img/icons/map-marker.svg": l1,
      "/library/assets/img/icons/map.svg": c1,
      "/library/assets/img/icons/navicon.svg": u1,
      "/library/assets/img/icons/object-group.svg": h1,
      "/library/assets/img/icons/share-alt.svg": d1,
      "/library/assets/img/icons/square-o.svg": p1,
      "/library/assets/img/icons/undo.svg": f1
    }), b = u, S = cr(() => {
      if (!b.icon) return null;
      const D = b.icon.replace(/^(fa-|ion-)/, ""), T = Object.keys(m).find(
        (a) => a.endsWith(`/${D}.svg`)
      );
      return T ? m[T] : null;
    }), E = cr(() => {
      const D = [];
      b.rotate && D.push(`rotate(${b.rotate}deg)`), b.mirror && D.push("scaleX(-1)");
      const T = {};
      return D.length && (T.transform = D.join(" ")), b.color && (T.color = b.color), T;
    });
    return (D, T) => S.value ? (wt(), Yt("span", {
      key: 0,
      class: "waymark-icon",
      innerHTML: S.value,
      style: ma(E.value)
    }, null, 12, m1)) : Ei("", !0);
  }
}, _1 = ["aria-disabled"], y1 = { class: "content" }, er = {
  __name: "Button",
  props: {
    icon: {
      type: String,
      default: ""
    },
    active: {
      type: Boolean,
      default: !1
    },
    size: {
      type: String,
      default: "medium"
      // small, medium, large
    },
    rotate: {
      type: Number,
      default: 0
      // degrees
    },
    mirror: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  setup(u) {
    const m = u, b = cr(() => {
      let S = ["button"];
      switch (m.active && S.push("button-active"), m.size) {
        case "small":
          S.push("button-small");
          break;
        case "medium":
        default:
          S.push("button-medium");
          break;
        case "large":
          S.push("button-large");
          break;
      }
      return m.disabled && S.push("button-disabled"), S.join(" ");
    });
    return (S, E) => (wt(), Yt("div", {
      class: us(b.value),
      "aria-disabled": u.disabled
    }, [
      u.icon ? (wt(!0), Yt(lr, { key: 0 }, kl(u.icon.split(" "), (D, T) => (wt(), gr(g1, {
        key: T,
        icon: D,
        class: "icon-svg",
        rotate: u.rotate,
        mirror: u.mirror
      }, null, 8, ["icon", "rotate", "mirror"]))), 128)) : Ei("", !0),
      yt("span", y1, [
        Xx(S.$slots, "default")
      ])
    ], 10, _1));
  }
}, v1 = { class: "overlay-top" }, x1 = { class: "type" }, b1 = { class: "title" }, w1 = { class: "overlay-content" }, T1 = {
  key: 0,
  class: "image"
}, S1 = ["src"], P1 = ["innerHTML"], M1 = { class: "stats" }, C1 = { class: "coordinates" }, I1 = ["innerHTML"], E1 = {
  key: 1,
  class: "elevation"
}, A1 = {
  __name: "Active",
  setup(u) {
    const { activeOverlay: m } = Vn(Nn()), { setActiveOverlay: b } = fa();
    return (S, E) => Xe(m) ? (wt(), Yt("div", {
      key: 0,
      class: us(`active-overlay feature-${Xe(m).featureType}`)
    }, [
      yt("div", v1, [
        yt("div", x1, [
          ci(W_, {
            type: Xe(m).type
          }, null, 8, ["type"])
        ]),
        yt("div", b1, as(Xe(m).getTitle()), 1),
        ci(er, {
          icon: "fa-close",
          onClick: E[0] || (E[0] = (D) => Xe(b)(null))
        })
      ]),
      yt("div", w1, [
        Xe(m).hasImage() ? (wt(), Yt("div", T1, [
          Xe(m).images.thumbnail ? (wt(), Yt("img", {
            key: 0,
            src: Xe(m).images.thumbnail
          }, null, 8, S1)) : Ei("", !0)
        ])) : Ei("", !0),
        Xe(m).getDescription() ? (wt(), Yt("div", {
          key: 1,
          class: "description",
          innerHTML: Xe(m).getDescription()
        }, null, 8, P1)) : Ei("", !0),
        yt("div", M1, [
          yt("div", C1, as(Xe(m).getCoordsString()), 1),
          Xe(m).featureType === "line" ? (wt(), Yt("div", {
            key: 0,
            class: "length",
            innerHTML: Xe(m).getLengthString()
          }, null, 8, I1)) : Ei("", !0),
          Xe(m).hasElevationData() ? (wt(), Yt("div", E1, as(Xe(m).getElevationString()), 1)) : Ei("", !0)
        ])
      ])
    ], 2)) : Ei("", !0);
  }
}, k1 = { class: "image" }, z1 = ["alt", "src"], R1 = {
  class: "title",
  colspan: "2"
}, D1 = { class: "content" }, L1 = { class: "action visible" }, F1 = {
  __name: "Overlay",
  props: {
    overlay: td
  },
  setup(u) {
    const { setActiveOverlay: m } = fa(), b = Nn(), { map: S, activeOverlay: E, filteredOverlays: D } = Vn(b), T = u;
    let a = ls(!0);
    const U = cr(() => E.value === T.overlay), ue = cr(() => D.value.includes(T.overlay)), ce = () => {
      a.value = !a.value, U.value && (E.value.removeHighlight(), E.value = null), a.value ? T.overlay.show() : T.overlay.hide();
    }, ve = cr(() => {
      let we = T.overlay.featureType;
      return U.value && (we += " active "), ue.value || (we += " hidden "), we;
    });
    return T.overlay.rowElement = Fx("row"), (we, Q) => (wt(), Yt("tr", {
      ref: "row",
      class: us(["overlay", ve.value]),
      onClick: Q[1] || (Q[1] = (Je) => Xe(m)(u.overlay))
    }, [
      yt("td", k1, [
        u.overlay.hasImage() ? (wt(), Yt("img", {
          key: 0,
          alt: u.overlay.getTitle(),
          src: u.overlay.getImage("thumbnail")
        }, null, 8, z1)) : Ei("", !0)
      ]),
      yt("td", R1, [
        yt("div", D1, as(u.overlay.getTitle()), 1)
      ]),
      yt("td", L1, [
        ci(er, {
          icon: Xe(Z_)(Xe(a)),
          onClick: Q[0] || (Q[0] = Oh((Je) => ce(), ["stop"]))
        }, null, 8, ["icon"])
      ])
    ], 2));
  }
}, B1 = { class: "icon" }, O1 = { class: "title" }, j1 = { class: "content" }, V1 = { class: "action expand" }, N1 = { class: "count" }, $1 = { class: "action visible" }, Ip = {
  __name: "Type",
  props: {
    featureType: String,
    typeKey: String,
    overlays: Array
  },
  setup(u) {
    const { map: m, filteredOverlays: b } = Vn(Nn()), { config: S } = js(), E = u;
    let D = ls(!0), T = ls(!0);
    const a = cr(() => {
      let Q = 0;
      return E.overlays.forEach((Je) => {
        b.value.includes(Je) && Q++;
      }), Q;
    }), U = () => {
      T.value = !T.value, T.value || (D.value = !1), E.overlays.forEach((Q) => {
        T.value ? Q.show() : Q.hide();
      });
    }, ue = S.value.getType(E.featureType, E.typeKey), ce = () => {
      let Q = "";
      switch (E.featureType) {
        case "marker":
          Q += `color:${ue.getIconColour()};`, Q += `border-color:${ue.getIconColour()};`, Q += `background-color:${ue.getPrimaryColour()};`;
          break;
        case "line":
          Q += `border-color:${ue.getPrimaryColour()};`, Q += `background-color:${ue.getPrimaryColour()};`;
          break;
      }
      return Q;
    }, ve = () => {
      D.value = !D.value;
    }, we = () => {
      let Q = "";
      return Q += ` ${E.featureType}`, Q += ` ${E.typeKey}`, a.value || (Q += " hidden"), Q;
    };
    return (Q, Je) => (wt(), Yt(lr, null, [
      yt("tr", {
        class: us(["heading", we()]),
        style: ma(ce()),
        onClick: Je[1] || (Je[1] = Oh((it) => ve(), ["stop"]))
      }, [
        yt("td", B1, [
          ci(W_, { type: Xe(ue) }, null, 8, ["type"])
        ]),
        yt("td", O1, [
          yt("div", j1, as(Xe(ue).getTitle()), 1)
        ]),
        yt("td", V1, [
          ci(er, {
            icon: Xe(Pb)(Xe(D))
          }, {
            default: da(() => [
              yt("span", N1, as(a.value), 1)
            ]),
            _: 1
          }, 8, ["icon"])
        ]),
        yt("td", $1, [
          ci(er, {
            icon: Xe(Z_)(Xe(T)),
            onClick: Je[0] || (Je[0] = Oh((it) => U(), ["stop"]))
          }, null, 8, ["icon"])
        ])
      ], 6),
      (wt(!0), Yt(lr, null, kl(u.overlays, (it) => qc((wt(), gr(F1, { overlay: it }, null, 8, ["overlay"])), [
        [Mh, Xe(D)]
      ])), 256))
    ], 64));
  }
}, U1 = { class: "panel overlay" }, Z1 = { class: "panel-top" }, G1 = { class: "feature-nav" }, q1 = { class: "feature-types" }, H1 = ["innerHTML"], W1 = ["innerHTML"], X1 = ["innerHTML"], K1 = { class: "feature-filters" }, Y1 = { class: "panel-content" }, J1 = { class: "marker-types type-list" }, Q1 = { class: "line-types type-list" }, ew = { class: "shape-types type-list" }, tw = {
  __name: "Overlays",
  setup(u) {
    const { overlaysByType: m, filteredOverlays: b } = Vn(Nn()), { activeFeatureType: S, setActiveFeatureType: E, layerFilters: D } = cf(), T = cr(() => b.value.filter(
      (ue) => ue.featureType === "marker"
    ).length), a = cr(() => b.value.filter(
      (ue) => ue.featureType === "line"
    ).length), U = cr(() => b.value.filter(
      (ue) => ue.featureType === "shape"
    ).length);
    return (ue, ce) => (wt(), Yt("div", U1, [
      yt("header", Z1, [
        ci(A1),
        yt("nav", G1, [
          yt("div", q1, [
            T.value ? (wt(), gr(er, {
              key: 0,
              title: "Show only Markers",
              class: "marker",
              icon: "fa-map-marker",
              onClick: ce[0] || (ce[0] = (ve) => Xe(E)("marker")),
              active: Xe(S) === "marker"
            }, {
              default: da(() => [
                yt("span", {
                  class: "count",
                  innerHTML: T.value
                }, null, 8, H1)
              ]),
              _: 1
            }, 8, ["active"])) : Ei("", !0),
            a.value ? (wt(), gr(er, {
              key: 1,
              title: "Show only Lines",
              class: "line",
              icon: "fa-share-alt",
              onClick: ce[1] || (ce[1] = (ve) => Xe(E)("line")),
              active: Xe(S) === "line"
            }, {
              default: da(() => [
                yt("span", {
                  class: "count",
                  innerHTML: a.value
                }, null, 8, W1)
              ]),
              _: 1
            }, 8, ["active"])) : Ei("", !0),
            U.value ? (wt(), gr(er, {
              key: 2,
              title: "Show only Shapes",
              class: "shape",
              icon: "fa-square-o",
              onClick: ce[2] || (ce[2] = (ve) => Xe(E)("shape")),
              active: Xe(S) === "shape"
            }, {
              default: da(() => [
                yt("span", {
                  class: "count",
                  innerHTML: U.value
                }, null, 8, X1)
              ]),
              _: 1
            }, 8, ["active"])) : Ei("", !0)
          ]),
          yt("div", K1, [
            ci(er, {
              title: "Show only overlays in view",
              icon: "fa-object-group",
              onClick: ce[3] || (ce[3] = (ve) => Xe(D).inBounds = !Xe(D).inBounds),
              active: Xe(D).inBounds
            }, null, 8, ["active"]),
            qc(yt("input", {
              type: "search",
              placeholder: "Search",
              "onUpdate:modelValue": ce[4] || (ce[4] = (ve) => Xe(D).text = ve)
            }, null, 512), [
              [sb, Xe(D).text]
            ])
          ])
        ])
      ]),
      yt("div", Y1, [
        qc(yt("table", J1, [
          (wt(!0), Yt(lr, null, kl(Object.keys(Xe(m).marker), (ve) => (wt(), gr(Ip, {
            key: ve,
            featureType: "marker",
            overlays: Xe(m).marker[ve],
            typeKey: ve
          }, null, 8, ["overlays", "typeKey"]))), 128))
        ], 512), [
          [Mh, Xe(S) === "marker"]
        ]),
        qc(yt("table", Q1, [
          (wt(!0), Yt(lr, null, kl(Object.keys(Xe(m).line), (ve) => (wt(), gr(Ip, {
            key: ve,
            featureType: "line",
            overlays: Xe(m).line[ve],
            typeKey: ve
          }, null, 8, ["overlays", "typeKey"]))), 128))
        ], 512), [
          [Mh, Xe(S) === "line"]
        ]),
        qc(yt("table", ew, [
          (wt(!0), Yt(lr, null, kl(Object.keys(Xe(m).shape), (ve) => (wt(), gr(Ip, {
            key: ve,
            featureType: "shape",
            overlays: Xe(m).shape[ve],
            typeKey: ve
          }, null, 8, ["overlays", "typeKey"]))), 128))
        ], 512), [
          [Mh, Xe(S) === "shape"]
        ])
      ])
    ]));
  }
}, iw = { class: "panel info" }, rw = {
  __name: "Info",
  setup(u) {
    const { view: m } = Vn(Nn());
    return (b, S) => (wt(), Yt("div", iw, [
      S[0] || (S[0] = yt("h3", null, "Info", -1)),
      Lh(" " + as(JSON.stringify(Xe(m))), 1)
    ]));
  }
}, nw = { class: "panel basemaps" }, sw = {
  key: 0,
  class: "rasters list"
}, ow = { class: "controls" }, aw = ["onClick"], lw = ["src", "alt"], cw = ["checked", "onClick"], uw = { class: "info" }, hw = ["onInput"], dw = ["onClick"], pw = ["innerHTML"], fw = {
  __name: "Basemaps",
  setup(u) {
    const { view: m, map: b } = Vn(Nn()), { config: S } = js(), E = ls([]);
    return E.value = S.value.getTileLayers().slice().reverse(), (D, T) => (wt(), Yt("div", nw, [
      E.value && E.value.length ? (wt(), Yt("div", sw, [
        (wt(!0), Yt(lr, null, kl(E.value, (a, U) => (wt(), Yt("div", {
          class: us(["list-item", {
            isVisible: a.isVisible()
          }]),
          key: U
        }, [
          yt("div", ow, [
            yt("div", {
              class: "preview",
              onClick: (ue) => a.toggleVisibility()
            }, [
              yt("img", {
                src: a.previewCoords(
                  Xe(m).bounds.getCenter().lat,
                  Xe(m).bounds.getCenter().lng,
                  parseInt(Xe(b).getZoom())
                ),
                alt: a.data.layer_name
              }, null, 8, lw),
              yt("input", {
                type: "checkbox",
                checked: a.isVisible(),
                onClick: Oh((ue) => a.toggleVisibility(), ["stop"]),
                title: "Active"
              }, null, 8, cw)
            ], 8, aw)
          ]),
          yt("div", uw, [
            yt("input", {
              type: "range",
              min: "0",
              max: "1",
              step: "0.01",
              onInput: (ue) => a.setOpacity(ue.target.value),
              title: "Opacity"
            }, null, 40, hw),
            yt("h4", {
              onClick: (ue) => a.toggleVisibility()
            }, as(a.data.layer_name), 9, dw),
            yt("p", {
              innerHTML: a.data.layer_attribution
            }, null, 8, pw)
          ])
        ], 2))), 128))
      ])) : Ei("", !0)
    ]));
  }
}, mw = { class: "debug-config" }, gw = {
  __name: "Config",
  setup(u) {
    const { config: m } = js();
    return (b, S) => (wt(), Yt("div", mw, [
      yt("pre", null, as(JSON.stringify(Xe(m), null, 2)), 1)
    ]));
  }
}, _w = { class: "panel debug" }, yw = { class: "panel-top" }, vw = { class: "tabs" }, xw = { class: "panel-content" }, bw = {
  __name: "Debug",
  setup(u) {
    const m = ls("config");
    return (b, S) => (wt(), Yt("div", _w, [
      yt("div", yw, [
        S[1] || (S[1] = yt("h3", null, "Debug", -1)),
        yt("div", vw, [
          ci(er, {
            size: "medium",
            icon: "fa-cog",
            active: m.value === "config",
            onClick: S[0] || (S[0] = (E) => m.value = "config"),
            title: "Config"
          }, null, 8, ["active"])
        ])
      ]),
      yt("div", xw, [
        m.value === "config" ? (wt(), gr(gw, { key: 0 })) : Ei("", !0)
      ])
    ]));
  }
}, ww = { class: "ui" }, Tw = { class: "panels-nav" }, Sw = { class: "nav-item nav-overlays" }, Pw = { class: "nav-item nav-basemaps" }, Mw = {
  key: 0,
  class: "nav-item nav-debug"
}, Cw = { class: "nav-item nav-view" }, Iw = {
  key: 0,
  class: "nav-panel panel-view"
}, Ew = { class: "panels-content" }, Aw = {
  __name: "UI",
  setup(u) {
    const { view: m, map: b } = Vn(Nn()), {
      showNav: S,
      openPanel: E,
      isActiveNav: D,
      showPanel: T,
      isActivePanel: a,
      mapHasOverlays: U
    } = cf(), { resetView: ue, rotateMap: ce, toggle3D: ve, pointNorth: we, pitchMap: Q } = fa(), { config: Je } = js(), it = cr(() => 315 - (m.value.bearing || 0));
    return (vt, Ze) => (wt(), Yt("div", ww, [
      yt("nav", Tw, [
        yt("div", Sw, [
          Xe(U) ? (wt(), gr(er, {
            key: 0,
            size: "large",
            icon: "fa-navicon",
            onClick: Ze[0] || (Ze[0] = (Ke) => Xe(E)("overlays")),
            active: Xe(a)("overlays")
          }, null, 8, ["active"])) : Ei("", !0)
        ]),
        yt("div", Pw, [
          ci(er, {
            size: "large",
            icon: "fa-map",
            onClick: Ze[1] || (Ze[1] = (Ke) => Xe(E)("basemaps")),
            active: Xe(a)("basemaps")
          }, null, 8, ["active"])
        ]),
        Xe(Je).getMapOption("debug_mode") ? (wt(), Yt("div", Mw, [
          ci(er, {
            size: "large",
            icon: "fa-bug",
            onClick: Ze[2] || (Ze[2] = (Ke) => Xe(E)("debug")),
            active: Xe(a)("debug")
          }, null, 8, ["active"])
        ])) : Ei("", !0),
        yt("div", Cw, [
          ci(er, {
            size: "large",
            icon: "fa-eye",
            onClick: Ze[3] || (Ze[3] = (Ke) => Xe(S)("view")),
            active: Xe(D)("view")
          }, null, 8, ["active"]),
          Xe(D)("view") ? (wt(), Yt("div", Iw, [
            ci(er, {
              class: "view-reset",
              size: "medium",
              icon: "fa-home",
              onClick: Xe(ue)
            }, null, 8, ["onClick"]),
            ci(er, {
              class: "view-north",
              size: "medium",
              icon: "fa-location-arrow",
              rotate: it.value,
              onClick: Ze[4] || (Ze[4] = (Ke) => Xe(we)())
            }, {
              default: da(() => Ze[10] || (Ze[10] = [
                Lh("N")
              ])),
              _: 1
            }, 8, ["rotate"]),
            ci(er, {
              class: "view-rotate-ccw",
              size: "medium",
              icon: "fa-undo",
              onClick: Ze[5] || (Ze[5] = (Ke) => Xe(ce)("ccw", 45))
            }),
            ci(er, {
              class: "view-rotate-cw",
              size: "medium",
              icon: "fa-undo",
              mirror: "true",
              onClick: Ze[6] || (Ze[6] = (Ke) => Xe(ce)("cw", 45))
            }),
            ci(er, {
              class: "view-3d",
              size: "medium",
              onClick: Ze[7] || (Ze[7] = (Ke) => Xe(ve)("3d")),
              active: Xe(m).pitch
            }, {
              default: da(() => Ze[11] || (Ze[11] = [
                Lh("3D")
              ])),
              _: 1
            }, 8, ["active"]),
            ci(er, {
              class: "view-pitch-up",
              size: "medium",
              icon: "fa-angle-up",
              onClick: Ze[8] || (Ze[8] = (Ke) => Xe(Q)("up")),
              disabled: Xe(m).pitch === 0
            }, null, 8, ["disabled"]),
            ci(er, {
              class: "view-pitch-down",
              size: "medium",
              icon: "fa-angle-down",
              onClick: Ze[9] || (Ze[9] = (Ke) => Xe(Q)("down")),
              disabled: Xe(m).pitch === 60
            }, null, 8, ["disabled"])
          ])) : Ei("", !0)
        ])
      ]),
      yt("div", Ew, [
        Xe(U) && Xe(T)("overlays") ? (wt(), gr(tw, { key: 0 })) : Ei("", !0),
        Xe(T)("info") ? (wt(), gr(rw, { key: 1 })) : Ei("", !0),
        Xe(T)("basemaps") ? (wt(), gr(fw, { key: 2 })) : Ei("", !0),
        Xe(T)("debug") ? (wt(), gr(bw, { key: 3 })) : Ei("", !0)
      ])
    ]));
  }
}, kw = ["id"], zw = {
  __name: "App",
  props: {
    map_options: {
      type: Object,
      default: () => ({})
    },
    viewer_options: {
      type: Object,
      default: () => ({})
    }
  },
  setup(u) {
    const m = Nn(), { config: b } = js(), { mapReady: S, container: E, panelOpen: D, activeOverlay: T } = Vn(m), a = u;
    m.init(a), E.value = document.getElementById(
      `${b.value.getMapOption("div_id")}`
    );
    const U = cr(() => {
      let ue = [""];
      return D.value ? ue.push("panel-open") : ue.push("panel-closed"), E.value.clientWidth > E.value.clientHeight ? ue.push("orientation-landscape") : ue.push("orientation-portrait"), E.value.clientWidth <= 375 && ue.push("display-narrow"), E.value.clientHeight <= 375 && ue.push("display-short"), T.value && ue.push("has-active-overlay"), E.value.clientWidth <= 640 ? ue.push("size-small") : E.value.clientWidth > 640 && E.value.clientWidth <= 1024 ? ue.push("size-medium") : ue.push("size-large"), ue.join(" ");
    });
    return (ue, ce) => (wt(), Yt("div", {
      class: us(`instance ${U.value}`),
      id: `${Xe(b).map_options.div_id}-instance`
    }, [
      ci($b),
      Xe(S) ? (wt(), gr(Aw, { key: 0 })) : Ei("", !0)
    ], 10, kw));
  }
};
class Rw {
  constructor(m = {}) {
    if (m.map_options = {
      div_id: "waymark-instance",
      ...m.map_options || {}
    }, !document.getElementById(m.map_options.div_id)) {
      const E = document.createElement("div");
      E.id = m.map_options.div_id, E.style.height = "100%", document.body.appendChild(E);
    }
    const b = ub(zw, m), S = pb();
    b.use(S), b.mount("#" + m.map_options.div_id), this.store = Vn(Nn()), this.loadGeoJSON = fa().loadGeoJSON, this.toGeoJSON = fa().toGeoJSON, this.clearGeoJSON = fa().clearGeoJSON;
  }
}
export {
  Rw as Instance
};
